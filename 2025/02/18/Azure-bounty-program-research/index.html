<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 掌控微软Azure赏金计划(Mastering the Microsoft Azure Bounty Program) · VictorV的小博客</title><meta name="description" content="掌控微软Azure赏金计划(Mastering the Microsoft Azure Bounty Program) - VictorV"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://474172261.github.io/atom.xml" title="VictorV的小博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="VictorV的小博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/vv474172261" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/474172261" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">掌控微软Azure赏金计划(Mastering the Microsoft Azure Bounty Program)</h1><div class="post-info">2025年2月18日</div><div class="post-content"><p>本来这个是打算在 <a target="_blank" rel="noopener" href="https://insomnihack.ch/talks-2025/">Insomni’hack 2025</a> 讲的, 由于个人原因没办法参与, 所以写个blog分享一下. 本文主要内容包括我是如何开始的Azure bounty program的研究, 如何扩展的研究, 以及部分成果的分享. </p>
<span id="more"></span>

<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>我在 Azure 下的所有成果都离不开肖伟大神的帮助, 感谢他的指导和分享.</p>
<h2 id="Azure-Bounty-Program-规则"><a href="#Azure-Bounty-Program-规则" class="headerlink" title="Azure Bounty Program 规则"></a>Azure Bounty Program 规则</h2><p>知己知彼, 百战不殆. 要想挖微软的<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/msrc/bounty-microsoft-azure">azure bounty program</a>, 先看看他们规则咋写的(2022年时):</p>
<p><img src="/images/Azure-bounty-program-research.assets/1739849231708.png" alt="1739849231708"></p>
<p>可以看到, 它规定了目标得是Azure Products页面里的产品.</p>
<p>不属于范围内的规则(2022年时):</p>
<p><img src="/images/Azure-bounty-program-research.assets/1739849391880.png" alt="1739849391880"></p>
<p>因为我主要擅长二进制相关的安全研究, 所以我比较关注的是二进制相关的产品. 这里列举的 Azure Site Recovery和Azure Defender for IOT 就是二进制程序. 所以, 这个奖励计划其实是包括二进制程序的. (以前我并没有意识到这个事情, 当我知道的时候, 那两个目标已经属于Out of Scope了 (T-T), 错过了一波致富经. 好在机会还是有的, 这次我没错过:) </p>
<h2 id="Azure-产品"><a href="#Azure-产品" class="headerlink" title="Azure 产品"></a>Azure 产品</h2><p>访问上面bounty页面的<a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/products/">azure产品链接</a>, 就可以看到如下列表:</p>
<p><img src="/images/Azure-bounty-program-research.assets/1739849787948.png" alt="1739849787948"></p>
<p>涵盖的产品非常多, 我只截取了一小部分.  而故事一开始的重点, 就在于Azure RTOS.</p>
<p>一开始, 是肖伟大神先看到了这个IOT系统, 鉴于微软的尿性, 它们往往可能不认可该产品的漏洞属于Azure Bounty Program. 所以, 在提交之前, 我发了一封邮件给 <a href="mailto:&#x62;&#111;&#117;&#110;&#x74;&#121;&#64;&#109;&#105;&#x63;&#114;&#111;&#x73;&#x6f;&#102;&#116;&#x2e;&#99;&#x6f;&#109;">&#x62;&#111;&#117;&#110;&#x74;&#121;&#64;&#109;&#105;&#x63;&#114;&#111;&#x73;&#x6f;&#102;&#116;&#x2e;&#99;&#x6f;&#109;</a>, 问他们Azure RTOS的NextX和NetX Duo是否在奖励计划内, 好在这次他们答复了我:</p>
<p><img src="/images/Azure-bounty-program-research.assets/1739850443172.png" alt="1739850443172"></p>
<blockquote>
<p>然而, 有时候他们根本不会答复, 所以这次也很幸运.</p>
</blockquote>
<h2 id="一血-ICMP"><a href="#一血-ICMP" class="headerlink" title="一血 ICMP"></a>一血 ICMP</h2><p>在这一周内, 肖伟大神已经发现了好几个RCE的问题, 而我也开始了尝试, 希望可以在肖伟大神的后面拣点漏.</p>
<p>然而这块的代码还是比我想象中严谨, 我一开始并没有任何收获, 只有挫败感. 在肖伟大神分享了一两个发现后, 我才发现原来自己错过了那么多. 这也让我重新找回信心, 开始继续挖掘. </p>
<p>很快, 我在NetX发现了和肖伟大神在NetX Duo上发现的相似的问题, NetX Duo比NetX功能强大一点, 所以理论上NetX Duo应该包含NetX的代码, 没想到NetX还多了点bug. </p>
<p>一开始, 微软复现后, 就将NetX项目从Github移除了, 然后告诉我, 该项目已经被废弃, 不算在奖金范畴了, 于是我祭出当初的回复邮件, 以及他们给我的答复中关于项目何时被废弃的时间(即废弃时间在我提交bug的时间之后), 他们终于承认了这个漏洞并给予了奖励.</p>
<p>下面看看怎么回事:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ULONG  _nx_icmp_checksum_compute(NX_PACKET *packet_ptr)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ULONG      checksum =  <span class="number">0</span>;</span><br><span class="line">ULONG      long_temp;</span><br><span class="line">USHORT     short_temp;</span><br><span class="line">ULONG      length;</span><br><span class="line">UCHAR     *word_ptr;</span><br><span class="line">NX_PACKET *current_packet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the length of the packet checksum.  */</span></span><br><span class="line">    length =  packet_ptr -&gt; nx_packet_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determine if we need to add a padding byte.  */</span></span><br><span class="line">    <span class="keyword">if</span> (((length / <span class="keyword">sizeof</span>(USHORT)) * <span class="keyword">sizeof</span>(USHORT)) != length)<span class="comment">// tag2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We have single byte alignment and we need two byte alignment.  */</span></span><br><span class="line">        length++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Determine if there is a last packet pointer.  */</span></span><br><span class="line">        <span class="keyword">if</span> (packet_ptr -&gt; nx_packet_last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Multi-packet message, add a zero byte at the end.  */</span></span><br><span class="line">            *((packet_ptr -&gt; nx_packet_last) -&gt; nx_packet_append_ptr) =  <span class="number">0</span>;<span class="comment">// tag1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Write a zero byte at the end of the first and only packet.  */</span></span><br><span class="line">            *(packet_ptr -&gt; nx_packet_append_ptr) =  <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>tag1处会向packet的<code>nx_packet_append_ptr</code>指向处写入0. 然而, 如果packet是ip 分片传入的, 它可以在<code>nx_packet_append_ptr</code>指向buffer末尾时, buffer长度还是奇数, 所以tag2的判断就成立, 导致越界写入了packet结构体的末尾. 而该结构体的末尾就是一个结构体指针, 所以刚好可能造成RCE.</p>
<h2 id="二血-SNMP奖金池"><a href="#二血-SNMP奖金池" class="headerlink" title="二血 SNMP奖金池"></a>二血 SNMP奖金池</h2><p>在NetX Duo 的addon目录, 有很多网络服务:</p>
<p><img src="/images/Azure-bounty-program-research.assets/1739851988954.png" alt="1739851988954"></p>
<p>其中, snmp, 就是此章节的重点, 我在其中总共发现了 12个漏洞, 虽然被合并了几个, 但是也足够幸运了.</p>
<p>简单列举一个案例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    buffer_length = (INT)(packet_ptr -&gt; nx_packet_length);</span><br><span class="line"></span><br><span class="line">    /* Setup a pointer to the buffer.  */</span><br><span class="line">    buffer_ptr =  packet_ptr -&gt; nx_packet_prepend_ptr;</span><br><span class="line">......</span><br><span class="line">    </span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        variable_start_ptr =  buffer_ptr;</span><br><span class="line">        length =  _nx_snmp_utility_sequence_get(buffer_ptr, &amp;variable_length, buffer_length);</span><br><span class="line">        total_variable_length =  variable_length + length;// tag1 length 为 len1</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        buffer_ptr =  buffer_ptr + length;</span><br><span class="line">        buffer_length -= (INT)length;</span><br><span class="line">        length =  _nx_snmp_utility_object_id_get(buffer_ptr, agent_ptr -&gt; nx_snmp_agent_current_octet_string, buffer_length);</span><br><span class="line">        ......</span><br><span class="line">        buffer_ptr =  buffer_ptr + length;</span><br><span class="line">        buffer_length -= (INT)length;// tag2 length 为 len2</span><br><span class="line">        ......</span><br><span class="line">        if (length != variable_length)</span><br><span class="line">        &#123;</span><br><span class="line">            length =  _nx_snmp_utility_object_data_get(buffer_ptr, &amp;(agent_ptr -&gt; nx_snmp_agent_current_object_data), buffer_length);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        buffer_ptr =  variable_start_ptr + total_variable_length;</span><br><span class="line">        variable_list_length =  variable_list_length - total_variable_length;</span><br><span class="line">        objects++;</span><br><span class="line"></span><br><span class="line">    &#125; while (variable_list_length);</span><br></pre></td></tr></table></figure>

<p>在一次循环里, <code>buffer_ptr</code>增加了 <code>total_variable_length</code>的长度, 即 variable_length + len1, <code>buffer_length</code>减少了<code>len1+len2</code>. 而事实上, len2不一定等于variable_length. 当 <code>variable_length  &gt; len2</code>时, 就会导致 <code>buffer_ptr</code>的剩余空间小于<code>buffer_length</code>的值. 而在<code>_nx_snmp_utility_object_id_get </code>中, 会修改buffer的内容, 导致越界写入, 从而造成RCE.</p>
<p>snmp中其它的bug也差不多是这种越界写入的问题.</p>
<h2 id="三血-FTP"><a href="#三血-FTP" class="headerlink" title="三血 FTP"></a>三血 FTP</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">VOID  _nx_ftp_server_command_process(NX_FTP_SERVER *ftp_server_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    client_req_ptr =  &amp;(ftp_server_ptr -&gt; nx_ftp_server_client_list[i]);</span><br><span class="line">    ......</span><br><span class="line">    switch(ftp_command)</span><br><span class="line">    &#123;</span><br><span class="line">            ......</span><br><span class="line">            case NX_FTP_QUIT:</span><br><span class="line">            &#123;</span><br><span class="line">                if (client_req_ptr -&gt; nx_ftp_client_request_packet)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    /* Yes, release it!  */</span><br><span class="line">                    nx_packet_release(client_req_ptr -&gt; nx_ftp_client_request_packet);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                break;</span><br><span class="line">            ......</span><br><span class="line">            case NX_FTP_RNFR:</span><br><span class="line">            &#123;</span><br><span class="line">                ......</span><br><span class="line">                client_req_ptr -&gt; nx_ftp_client_request_packet =  packet_ptr;</span><br></pre></td></tr></table></figure>

<p>这个漏洞比较简单, 就是这个函数可以重复多次, 而释放操作并没有置零<code>client_req_ptr -&gt; nx_ftp_client_request_packet</code>指针, 导致double free.</p>
<p>这个漏洞并不复杂, 我之所以要讲, 是因为我是通过vs code, 全局搜索所有的释放操作, 然后一个个检查是否有置零操作, 从而发现了它. 而我在AMQP项目也用同样的方法找到了好几个问题.</p>
<h2 id="四血-double-free"><a href="#四血-double-free" class="headerlink" title="四血 double free"></a>四血 double free</h2><p>找完以上bug后, 似乎已经没什么新的问题了. 但是snmp中的一个问题, 引起了我的注意.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">VOID  _nx_snmp_version_1_process(NX_SNMP_AGENT *agent_ptr, NX_PACKET *packet_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        variable_start_ptr =  buffer_ptr;</span><br><span class="line">        ......</span><br><span class="line">        if (length != variable_length)</span><br><span class="line">        &#123;</span><br><span class="line">            length =  _nx_snmp_utility_object_data_get(buffer_ptr, &amp;(agent_ptr -&gt; nx_snmp_agent_current_object_data), buffer_length);</span><br><span class="line">        if (length != variable_length)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            /* Pickup the value associated with this variable.  */</span><br><span class="line">            length =  _nx_snmp_utility_object_data_get(buffer_ptr, &amp;(agent_ptr -&gt; nx_snmp_agent_current_object_data), buffer_length);</span><br><span class="line"></span><br><span class="line">            /* Determine if the object value was successful.  */ </span><br><span class="line">            if (length == 0) </span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                /* Increment the invalid packet error counter.  */</span><br><span class="line">                agent_ptr -&gt; nx_snmp_agent_invalid_packets++;</span><br><span class="line"></span><br><span class="line">                /* Increment the internal error counter.  */</span><br><span class="line">                agent_ptr -&gt; nx_snmp_agent_internal_errors++;</span><br><span class="line"></span><br><span class="line">                /* Send an SNMP version error response.  */</span><br><span class="line">                _nx_snmp_version_error_response(agent_ptr, packet_ptr, request_type_ptr, error_ptr, NX_SNMP_ERROR_BADVALUE, objects+1); // 1. 函数有可能释放 packet_ptr</span><br><span class="line"></span><br><span class="line">                /* Release the packet.  */</span><br><span class="line">                nx_packet_release(packet_ptr);// 2. 直接释放 packet_ptr</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    &#125; while (variable_list_length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID  _nx_snmp_version_error_response(NX_SNMP_AGENT *agent_ptr, NX_PACKET *packet_ptr, UCHAR *request_type_ptr, </span><br><span class="line">                                      UCHAR *error_string_ptr, UINT error_code, UINT error_index)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    status =  nxd_udp_socket_send(&amp;(agent_ptr -&gt; nx_snmp_agent_socket), packet_ptr, </span><br><span class="line">                                                &amp;(agent_ptr -&gt; nx_snmp_agent_current_manager_ip),</span><br><span class="line">                                                agent_ptr -&gt; nx_snmp_agent_current_manager_port);</span><br><span class="line"></span><br><span class="line">    if (status)</span><br><span class="line">    &#123;</span><br><span class="line">        nx_packet_release(packet_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述操作可以明显看到, 假如<code>nxd_udp_socket_send</code>返回非0结果, 它就会释放<code>packet_ptr</code>, 而上层函数不管发生了什么, 都会再次释放packet_ptr.</p>
<p>如果是单线程, 这其实是没有问题的, 因为<code>nx_packet_release</code>里有判断操作, 所以不会导致double free问题. 一开始我也是这么认为的. 直到某次测试时, 发现它是多线程的. 然后重新重视起这个问题, 测试后发现, 确实可以多线程竞争, 造成double free的问题.</p>
<p>另外, 即使<code>nxd_udp_socket_send</code>发送成功, 也会在<code>nxd_udp_socket_send</code>内部的子函数实现中释放packet_ptr.</p>
<p>从这一个问题, 我就开始想, 是不是调用方并不知道<code>nxd_udp_socket_send</code>其实会释放<code>packet</code>?</p>
<p>通过遍历所有类似的调用函数, 我在不同模块里找到了7个相似问题. 还有几个还没有来得及确认, MSRC就已经将 RTOS加入out of scope了:</p>
<ul>
<li>August 16, 2023: Added to out of scope – vulnerabilities found in Azure RTOS.</li>
</ul>
<blockquote>
<p>有好的目标确实应该不舍昼夜地挖, 不然你永远不知道他们什么时候不给钱了.</p>
</blockquote>
<h2 id="寻找下一个目标"><a href="#寻找下一个目标" class="headerlink" title="寻找下一个目标"></a>寻找下一个目标</h2><p>在RTOS不给钱以后, 我只能再找找Azure的其它产品是否存在安全问题. 先后查看了以下产品:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Azure Data Factory</span><br><span class="line">Azure Stack Development Kit</span><br><span class="line">Azure Stack Hub</span><br><span class="line">Azure Communication Services</span><br><span class="line">Azure migrate</span><br><span class="line">Azure Storage Explorer</span><br><span class="line">Azure lustre</span><br><span class="line">Spatial Anchors/Remote Rendering</span><br><span class="line">Azure Object Anchors </span><br><span class="line">Azure Database Migration Service</span><br><span class="line">Azure Monitor</span><br><span class="line">Azure Update Manager</span><br><span class="line">microsoft purview</span><br><span class="line">Azure Arc</span><br><span class="line">Service Fabric</span><br></pre></td></tr></table></figure>

<p>上述产品并没有深入, 我不擅长, 所以就没有深入. 中间提交了azure iot-plug-and-play-bridge, Azure Kinect SDK Depth Engine 的漏洞, 最后不在奖励范围内. 于是我继续寻找新目标.</p>
<p>在一个个翻找<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/azure/?product=popular">azure的产品及说明文档</a>, 寻找目标时, Github上的开源组件<a target="_blank" rel="noopener" href="https://github.com/Azure/azure-uamqp-c">azure-uamqp-c</a>吸引了我的注意力. 它是一个消息传输协议, 并且在多个服务中看到它的存在. 而且还开源. 所以我开始寻找它上面的问题.</p>
<h2 id="一鱼三吃"><a href="#一鱼三吃" class="headerlink" title="一鱼三吃"></a>一鱼三吃</h2><p>在花了几天时间分析amqp后, 我找到了一个越界写入问题.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0xB0</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (internal_decoder_data-&gt;bytes_decoded &lt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.length += buffer[<span class="number">0</span>] &lt;&lt; ((<span class="number">3</span> - internal_decoder_data-&gt;bytes_decoded) * <span class="number">8</span>);</span><br><span class="line">        internal_decoder_data-&gt;bytes_decoded++;</span><br><span class="line">        buffer++;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (internal_decoder_data-&gt;bytes_decoded == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.bytes = <span class="literal">NULL</span>;</span><br><span class="line">                internal_decoder_data-&gt;on_value_decoded(internal_decoder_data-&gt;on_value_decoded_context, internal_decoder_data-&gt;decode_to_value);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.bytes = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>((<span class="type">size_t</span>)internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.length + <span class="number">1</span>); <span class="comment">// 整数溢出</span></span><br><span class="line">                <span class="keyword">if</span> (internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.bytes == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    result = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> to_copy = internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.length - (internal_decoder_data-&gt;bytes_decoded - <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (to_copy &gt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            to_copy = size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (<span class="type">void</span>)<span class="built_in">memcpy</span>((<span class="type">unsigned</span> <span class="type">char</span>*)(internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.bytes) + (internal_decoder_data-&gt;bytes_decoded - <span class="number">4</span>), buffer, to_copy);</span><br><span class="line">        buffer += to_copy;</span><br><span class="line">        size -= to_copy;</span><br><span class="line">        internal_decoder_data-&gt;bytes_decoded += to_copy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (internal_decoder_data-&gt;bytes_decoded == (<span class="type">size_t</span>)internal_decoder_data-&gt;decode_to_value-&gt;value.binary_value.length + <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            internal_decoder_data-&gt;decoder_state = DECODER_STATE_CONSTRUCTOR;</span><br><span class="line">            internal_decoder_data-&gt;on_value_decoded(internal_decoder_data-&gt;on_value_decoded_context, internal_decoder_data-&gt;decode_to_value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个比较简单, 就是在代码注释位置, 32bit的程序存在整数溢出, 导致申请的内存size为0, 后续就溢出写入了.</p>
<p>我将该问题提交微软以后, 微软认可了这个目标, 我在等待官方出了补丁后, 又提交了相同的问题, 在相同的函数内, 不同的分支位置. 一般来说, 相同函数内出现的不同问题, 微软往往会合并他们, 所以我也没必要提交另一个分支的漏洞(RTOS 就被合并了). 然而这次, 修复者偷懒, 没有检查其它位置是否存在相同问题, 草草地修复了漏洞, 于是我可以在补丁出了后, 重新提交遗漏的位置. 这是一鱼两吃.</p>
<p>显然, 故事还没有结束. 我在搜索amqp函数的过程中, 偶然发现, 有其它的项目(Azure-sdk-for-cpp, azure-uamqp-python), 也包含了azure-uamqp-c的代码, 但是上次我提交的漏洞并没有被同步到这两个项目中.  于是我又用那个项目提交了相同的bug. 最后微软也认了, 修补了两个项目中的bug. 至此, 一鱼三吃的故事落下帷幕.</p>
<h2 id="double-free-again"><a href="#double-free-again" class="headerlink" title="double free again"></a>double free again</h2><p>在snmp的double free启发我以后, 我在amqp, azure-c-shared-utility, azure-iot-sdk-c, azure iot device update 项目中应用以下规则, 我得以用最简单的方法找出了11个uaf的问题. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`(delete|destroy|free|release)\w*\([\w\(\*]`, *.h,*.c,*.cpp. 排除samples, tests</span><br><span class="line">筛选原则:</span><br><span class="line">    1. 释放后未置零, 本地变量判断是否在当前函数循环内, 传入参数判断上层函数是否在循环内</span><br><span class="line">    2. 释放的变量是否存储到其它结构体里 (这个可能存在漏网之鱼)</span><br><span class="line">    3. 同一个函数存在多次释放(比如失败后释放了一次)</span><br></pre></td></tr></table></figure>

<p>在2023年末微软新加了一条规则:</p>
<ul>
<li>December 20, 2023: Confirmed out of scope - vulnerabilities in OMI or open-source components.</li>
</ul>
<p>彼时还没有完全不认这些组件的问题, 但是后面就完全不认了. 在2024年8月, 微软再次强调了它:</p>
<ul>
<li>August 5, 2024: Clarified open-source out of scope exclusion.</li>
</ul>
<p>以上提到的漏洞有不少是在2024年提交的, 所以有一部分被赖掉了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>有好目标就奋力挖, 别停下.</li>
<li>用技巧挖洞, 又快又省心</li>
<li>试一试, 反正不亏.</li>
</ol>
<p>至此, 由于微软不再认可开源软件的安全漏洞, 我的 Azure 挖掘之路就告一段落了.<br>如果你仔细翻找<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/azure/?product=popular">azure的产品及说明文档</a>, 或许你们也可以在in scope范围内, 开辟自己的黄金通道.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2025/02/02/life-record/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '28b1a73c3ed656a9a85d',     
    clientSecret: '59837bb4cbe7b2f12df366fdbcb37fa4ba084d44',     
    id: 'Tue Feb 18 2025 10:47:27 GMT+0800',    
    repo: 'blog-comment',     
    owner: '474172261',     
    admin: '474172261',     
})   
gitalk.render('gitalk-container')</script><div class="copyright"><p>© 2015 - 2025 <a href="http://474172261.github.io">VictorV</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>