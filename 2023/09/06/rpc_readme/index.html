<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Windows RPC 介绍 · VictorV的小博客</title><meta name="description" content="Windows RPC 介绍 - VictorV"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://474172261.github.io/atom.xml" title="VictorV的小博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="VictorV的小博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/vv474172261" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/474172261" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Windows RPC 介绍</h1><div class="post-info">2023年9月6日</div><div class="post-content"><p>windows的rpc是一个很重要的接口, 以前我对它一直不算了解, 今天以一个安全研究的角度去介绍一下它. </p>
<span id="more"></span>

<h2 id="注册rpc服务"><a href="#注册rpc服务" class="headerlink" title="注册rpc服务"></a>注册rpc服务</h2><p>server 通过 RpcServerUseProtseqEp 注册服务, 可以有的类型有: ncalrpc (ALPC), ncacn_np (named pipe) or ncacn_ip_tcp (TCP socket) <a target="_blank" rel="noopener" href="https://www.tiraniddo.dev/2021/08/how-to-secure-windows-rpc-server-and.html" title="ow to secure a Windows RPC Server, and how not to.">参考</a><br>pipe类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RpcServerUseProtseqEp(</span><br><span class="line">    L&quot;ncacn_np&quot;,</span><br><span class="line">    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,</span><br><span class="line">    L&quot;\\pipe\\DEMO&quot;,</span><br><span class="line">    nullptr);</span><br></pre></td></tr></table></figure>
<p>socket类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">status = RpcServerUseProtseqEp(</span><br><span class="line">   reinterpret_cast&lt;unsigned char*&gt;(&quot;ncacn_ip_tcp&quot;), // Use TCP/IP protocol.</span><br><span class="line">   RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // Backlog queue length for TCP/IP.</span><br><span class="line">   reinterpret_cast&lt;unsigned char*&gt;(&quot;4747&quot;),         // TCP/IP port to use.</span><br><span class="line">   NULL);                          // No security.</span><br></pre></td></tr></table></figure>
<p>alpc类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RpcServerUseProtseqEpA(&quot;ncalrpc&quot;, 10, &quot;spoolss&quot;, SecurityDescriptor);</span><br></pre></td></tr></table></figure>

<p>之后是注册rpc函数接口:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif">RpcServerRegisterIf</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif2">RpcServerRegisterIf2</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterifex">RpcServerRegisterIfEx</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif3">RpcServerRegisterIf3</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupcreatew">RpcServerInterfaceGroupCreate</a></li>
</ul>
<p>以后面示例代码<code>Example1Server.cpp</code>为例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">status = RpcServerRegisterIf2(</span><br><span class="line">   Example1_v1_0_s_ifspec, <span class="comment">// Interface to register.</span></span><br><span class="line">   <span class="literal">NULL</span>, <span class="comment">// Use the MIDL generated entry-point vector.</span></span><br><span class="line">   <span class="literal">NULL</span>, <span class="comment">// Use the MIDL generated entry-point vector.</span></span><br><span class="line">   RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH, <span class="comment">// Forces use of security callback.</span></span><br><span class="line">   RPC_C_LISTEN_MAX_CALLS_DEFAULT, <span class="comment">// Use default number of concurrent calls.</span></span><br><span class="line">   (<span class="type">unsigned</span>)<span class="number">-1</span>, <span class="comment">// Infinite max size of incoming data blocks.</span></span><br><span class="line">   SecurityCallback); <span class="comment">// Naive security callback.</span></span><br></pre></td></tr></table></figure>
<p>第四个参数flag, 值如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define RPC_IF_AUTOLISTEN                   0x0001</span><br><span class="line">#define RPC_IF_OLE                          0x0002</span><br><span class="line">#define RPC_IF_ALLOW_UNKNOWN_AUTHORITY      0x0004</span><br><span class="line">#define RPC_IF_ALLOW_SECURE_ONLY            0x0008</span><br><span class="line">#define RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH 0x0010</span><br><span class="line">#define RPC_IF_ALLOW_LOCAL_ONLY             0x0020</span><br><span class="line">#define RPC_IF_SEC_NO_CACHE                 0x0040</span><br><span class="line">#if (NTDDI_VERSION &gt;= NTDDI_VISTA)</span><br><span class="line">#define RPC_IF_SEC_CACHE_PER_PROC           0x0080</span><br><span class="line">#define RPC_IF_ASYNC_CALLBACK               0x0100</span><br></pre></td></tr></table></figure>

<p>有<code>RPC_IF_ALLOW_SECURE_ONLY</code>代表接口需要认证.</p>
<p>在<a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/4837/Introduction-to-RPC-Part-1#Implicitandexplicithandles17" title="Introduce RPC">示例项目</a>里, 它会自动生成<code>Example1_s.c</code>文件, 里面有<code>Example1_v1_0_s_ifspec</code>的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">RPC_IF_HANDLE Example1_v1_0_s_ifspec = (RPC_IF_HANDLE)&amp; Example1___RpcServerInterface;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> RPC_SERVER_INTERFACE Example1___RpcServerInterface =</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(RPC_SERVER_INTERFACE),</span><br><span class="line">    &#123;&#123;<span class="number">0x00000001</span>,<span class="number">0xEAF3</span>,<span class="number">0x4A7A</span>,&#123;<span class="number">0xA0</span>,<span class="number">0xF2</span>,<span class="number">0xBC</span>,<span class="number">0xE4</span>,<span class="number">0xC3</span>,<span class="number">0x0D</span>,<span class="number">0xA7</span>,<span class="number">0x7E</span>&#125;&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0x8A885D04</span>,<span class="number">0x1CEB</span>,<span class="number">0x11C9</span>,&#123;<span class="number">0x9F</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x2B</span>,<span class="number">0x10</span>,<span class="number">0x48</span>,<span class="number">0x60</span>&#125;&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">    (RPC_DISPATCH_TABLE*)&amp;Example1_v1_0_DispatchTable,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    &amp;Example1_ServerInfo,</span><br><span class="line">    <span class="number">0x06000000</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> RPC_DISPATCH_FUNCTION Example1_table[] =</span><br><span class="line">    &#123;</span><br><span class="line">    NdrServerCall2,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> RPC_DISPATCH_TABLE Example1_v1_0_DispatchTable = </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="comment">// 指定了有几个回调函数.</span></span><br><span class="line">    (RPC_DISPATCH_FUNCTION*)Example1_table</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> SERVER_ROUTINE Example1_ServerRoutineTable[] = </span><br><span class="line">    &#123;</span><br><span class="line">    (SERVER_ROUTINE)Output<span class="comment">// 导出函数</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MIDL_SERVER_INFO Example1_ServerInfo = </span><br><span class="line">    &#123;</span><br><span class="line">    &amp;Example1_StubDesc,</span><br><span class="line">    Example1_ServerRoutineTable,<span class="comment">// 导出函数表</span></span><br><span class="line">    Example1__MIDL_ProcFormatString.Format,</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">short</span> *) Example1_FormatStringOffsetTable,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (RPC_SYNTAX_IDENTIFIER*)&amp;_NDR64_RpcTransferSyntax_1_0,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    (MIDL_SYNTAX_INFO*)Example1_SyntaxInfo</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>在IDA中看<code>Example1___RpcServerInterface</code>:</p>
<p><img src="/images/rpc_readme/1694054196198.png" alt="1694054196198"></p>
<p><strong>其中+4位置是rpc服务对应的UUID.</strong></p>
<p>再看<code>[60h]</code>位置的<code>Example1_ServerInfo</code>:</p>
<p><img src="/images/rpc_readme/1694054233133.png" alt="1694054233133"></p>
<p>再看<code>[8h]</code>位置的<code>SERVER_ROUTINE</code>表:</p>
<p><img src="/images/rpc_readme/1694054247738.png" alt="1694054247738"></p>
<h2 id="client调用"><a href="#client调用" class="headerlink" title="client调用"></a>client调用</h2><p>client要调用服务, 必须通过<code>RpcStringBindingCompose</code>函数绑定, 再通过<code>RpcBindingFromStringBinding</code>获得<code>RPC_BINDING_HANDLE</code>, 下面是示例代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">status = RpcStringBindingCompose(</span><br><span class="line">   NULL, // UUID to bind to.</span><br><span class="line">   reinterpret_cast&lt;unsigned char*&gt;(&quot;ncacn_ip_tcp&quot;), // Use TCP/IP</span><br><span class="line">                                                     // protocol.</span><br><span class="line">   reinterpret_cast&lt;unsigned char*&gt;(&quot;localhost&quot;), // TCP/IP network</span><br><span class="line">                                                  // address to use.</span><br><span class="line">   reinterpret_cast&lt;unsigned char*&gt;(&quot;4747&quot;), // TCP/IP port to use.</span><br><span class="line">   NULL, // Protocol dependent network options to use.</span><br><span class="line">   &amp;szStringBinding); // String binding output.</span><br><span class="line"></span><br><span class="line">status = RpcBindingFromStringBinding(</span><br><span class="line">   szStringBinding, // The string binding to validate.</span><br><span class="line">   &amp;hExample1Binding); // Put the result in the implicit binding</span><br><span class="line">                       // handle defined in the IDL file.</span><br></pre></td></tr></table></figure>

<p>bind后, 直接调用接口代码即可<code>Output(&quot;Hello Implicit RPC World!&quot;);</code>, 实际上, 它真实的调用是如下:</p>
<p><img src="/images/rpc_readme/1694054894682.png" alt="1694054894682"></p>
<p>通过调用<code>NdrClientCall3</code>函数来实现调用. 第二个参数就是目标server的函数编号, 此处就是第<code>0</code>号函数(即<code>Example1_ServerRoutineTable[0]</code>), 从第四个参数开始, 就是目标函数所需要的参数.</p>
<p>观察一下它的 <code>Example1_ProxyInfo</code></p>
<p><img src="/images/rpc_readme/1694055232546.png" alt="1694055232546"></p>
<p><code>Example1_StubDesc</code>:</p>
<p><img src="/images/rpc_readme/1694055253629.png" alt="1694055253629"></p>
<p>从这个结构体可以看到, +18h位置是<code>&amp;hExample1Binding</code>, 指向<code>RPC_BINDING_HANDLE</code>.</p>
<p>再看<code>Example1___RpcClientInterface</code>对象(<code>_RPC_CLIENT_INTERFACE</code>结构体), +4位置是server对应的uuid</p>
<p><img src="/images/rpc_readme/1694083472060.png" alt="1694083472060"></p>
<p>下面从调试角度看看它的关系:</p>
<p><img src="/images/rpc_readme/1694056212795.png" alt="1694056212795"></p>
<p>继续handle对应的结构体:</p>
<p><img src="/images/rpc_readme/1694056354014.png" alt="1694056354014"></p>
<p>如图, 在**[f0h]**偏移位置的地址, 指向的结构体存在三个指针, 这三个指针分别是<code>RpcStringBindingCompose</code>的参数.</p>
<h2 id="在NdrClientCall3找rpc接口"><a href="#在NdrClientCall3找rpc接口" class="headerlink" title="在NdrClientCall3找rpc接口"></a>在<code>NdrClientCall3</code>找rpc接口</h2><p>一个方法就是通过上述<code>poi(poi(poi(poi(@rcx)+18))+f0)</code>偏移去找字符串</p>
<p>某些情况下, 可能<code>RPC_BINDING_HANDLE</code>指针不存在(即poi(poi(@rcx)+18)为空), 这种情况下, 一般第四个参数(即函数调用的第一个参数), 是一个和binding_handle 有关的结构体. 在同一个dll里, 通过查找它的引用, 大概率找得到声明位置. </p>
<p>以下以sspi接口中<code>sspicli.dll!SspipProcessSecurityContext</code>调用的rpc来示例如何寻找:</p>
<p><strong>方法1: 通过逆向代码查找</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  LODWORD(v19.Pointer) = IsOkayToExec(&amp;v58);</span><br><span class="line">  <span class="keyword">if</span> ( SLODWORD(v19.Simple) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v79 = v58[<span class="number">3</span>];</span><br><span class="line">     ......</span><br><span class="line">	v19.Pointer = NdrClientCall3((MIDL_STUBLESS_PROXY_INFO *)&amp;sspirpc_ProxyInfo, <span class="number">6u</span>, <span class="number">0</span>i64, v79, &amp;v90, v61, v59).Pointer;<span class="comment">// 1. 关注第四个参数, 来自行1的v58</span></span><br><span class="line">      </span><br><span class="line">NTSTATUS __fastcall <span class="title function_">IsOkayToExec</span><span class="params">(_QWORD *a1)</span><span class="comment">// 2. 深入函数实现</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (DllState &amp; <span class="number">0x40000000</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !SecDllClient )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1073741502</span>;</span><br><span class="line">      *a1 = SecDllClient;<span class="comment">// 3. 找到赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>通过查找<code>SecDllClient</code>的引用, 来到函数<code>InitState</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">InitState</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    RpcConnection = CreateRpcConnection(<span class="number">0</span>, <span class="number">2</span>, (<span class="type">unsigned</span> <span class="type">int</span>)&amp;v4, (<span class="type">unsigned</span> <span class="type">int</span>)&amp;SecLsaPackageCount, (__int64)&amp;v3);</span><br><span class="line">    ......</span><br><span class="line">  SecDllClient = LocalAlloc(<span class="number">0x40</span>u, <span class="number">0x30</span>ui64);</span><br><span class="line">  <span class="keyword">if</span> ( SecDllClient )</span><br><span class="line">  &#123;</span><br><span class="line">    *((_QWORD *)SecDllClient + <span class="number">3</span>) = v4;<span class="comment">// 4. +8位置赋值了v4      </span></span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">CreateRpcConnection</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3, __int64 a4, __int64 a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  result = SecpGetRpcBinding(&amp;Binding);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)result &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v14.Simple = <span class="number">0</span>i64;</span><br><span class="line">    v12 = a2;</span><br><span class="line">    v10.Pointer = NdrClientCall3((MIDL_STUBLESS_PROXY_INFO *)&amp;sspirpc_ProxyInfo, <span class="number">0</span>, <span class="number">0</span>i64, Binding, a1, v12, a5, a4, a3).Pointer;<span class="comment">// 5. v4即a3, a3来自于rpc调用的赋值. 关注到第四个参数binding</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">SecpGetRpcBinding</span><span class="params">(RPC_BINDING_HANDLE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  Binding = <span class="number">0</span>i64;</span><br><span class="line">  v2 = RpcStringBindingComposeW(</span><br><span class="line">         <span class="number">0</span>i64,</span><br><span class="line">         (RPC_WSTR)<span class="string">L&quot;ncalrpc&quot;</span>,</span><br><span class="line">         <span class="number">0</span>i64,</span><br><span class="line">         (RPC_WSTR)<span class="string">L&quot;lsasspirpc&quot;</span>,</span><br><span class="line">         word_180030B10,</span><br><span class="line">         &amp;StringBinding);</span><br><span class="line">  v2 = RpcBindingFromStringBindingW(StringBinding, &amp;Binding);<span class="comment">// 6. 可以看到, binding就是我们要找的rpc_binding_handle</span></span><br></pre></td></tr></table></figure>

<p>因为名字有isass, 估计是进程<code>isass.exe</code>, 通过<a target="_blank" rel="noopener" href="https://www.rpcview.org/">rpcview</a>查看:</p>
<p><img src="/images/rpc_readme/1694059325724.png" alt="1694059325724"></p>
<p>rpcview不会自动识别来自哪个dll, 因此需要我们猜一下.</p>
<p>因为是sspi组件, 所以查看左下方所有的dll, 猜测应该是sspisrv.dll对应的服务是目标<code>lsasspirpc</code>, 右下方就是rpc的调用表.</p>
<p>如果想有符号, 通过下列方式添加:</p>
<p><img src="/images/rpc_readme/1694059416499.png" alt="1694059416499"></p>
<p><img src="/images/rpc_readme/1694059427500.png" alt="1694059427500"></p>
<p>类似于windbg. 添加后重启rpcview. </p>
<blockquote>
<p>它不会自动下载符号, 需要把符号先下载到对应目录才行, 下面是下载方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd&gt; cd &quot;C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\&quot;</span><br><span class="line">cmd&gt; .\symchk /s srv*c:\SYMBOLS*https://msdl.microsoft.com/download/symbols C:\Windows\System32\*.dll</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在sspisvc.dll里, 我们查找<code>RpcServerRegisterIf3</code>引用, 找到:</p>
<p><img src="/images/rpc_readme/1694059702812.png" alt="1694059702812"></p>
<p>跟踪<code>dword_180006380</code>:</p>
<p><img src="/images/rpc_readme/1694059793138.png" alt="1694059793138"></p>
<p>查看<code>[60h]</code>:</p>
<p><img src="/images/rpc_readme/1694060073435.png" alt="1694060073435"></p>
<p>查看<code>[8h]</code>:</p>
<p><img src="/images/rpc_readme/1694060911071.png" alt="1694060911071"></p>
<p>自此我们找到了它的调用接口.</p>
<p>一般rpc server的调用栈回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SspiSrv!SspirProcessSecurityContext</span><br><span class="line">RPCRT4!Invoke+0x73</span><br><span class="line">RPCRT4!Ndr64StubWorker+0xb98</span><br><span class="line">RPCRT4!NdrServerCallAll+0x3c</span><br><span class="line">RPCRT4!DispatchToStubInCNoAvrf+0x17</span><br><span class="line">RPCRT4!RPC_INTERFACE::DispatchToStubWorker+0x1a8</span><br><span class="line">RPCRT4!RPC_INTERFACE::DispatchToStub+0xf1</span><br><span class="line">RPCRT4!LRPC_SCALL::DispatchRequest+0x14d</span><br><span class="line">RPCRT4!LRPC_SCALL::HandleRequest+0xd5a</span><br><span class="line">RPCRT4!LRPC_SASSOCIATION::HandleRequest+0x2c3</span><br><span class="line">RPCRT4!LRPC_ADDRESS::HandleRequest+0x183</span><br><span class="line">RPCRT4!LRPC_ADDRESS::ProcessIO+0x939</span><br><span class="line">RPCRT4!LrpcIoComplete+0xfe</span><br><span class="line">ntdll!TppAlpcpExecuteCallback+0x20c</span><br><span class="line">ntdll!TppWorkerThread+0x4b3</span><br><span class="line">KERNEL32!BaseThreadInitThunk+0x17</span><br><span class="line">ntdll!RtlUserThreadStart+0x20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>方法2: 通过调试找到uuid</strong></p>
<p>在调用<code>NdrClientCall3</code>断下, 依次查看结构体:</p>
<p><img src="/images/rpc_readme/1694084123706.png" alt="1694084123706"></p>
<p>和rpcview一致.</p>
<h2 id="com接口的rpc-NdrpClientCall3"><a href="#com接口的rpc-NdrpClientCall3" class="headerlink" title="com接口的rpc NdrpClientCall3"></a>com接口的rpc NdrpClientCall3</h2><p>com接口一般在进程内调用rpc时就用的 <code>RPCRT4!NdrpClientCall3</code>接口. 声明如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLIENT_CALL_RETURN RPC_ENTRY</span><br><span class="line">NdrpClientCall3</span><br><span class="line">(</span><br><span class="line">void * pThis, // rcx</span><br><span class="line">MIDL_STUBLESS_PROXY_INFO *pProxyInfo, // rdx</span><br><span class="line">ulong nProcNum, // r8</span><br><span class="line">void *pReturnValue, // r9</span><br><span class="line">NDR_PROC_CONTEXT *pContext, // poi(@rsp+0x28)</span><br><span class="line">uchar *StartofStack // poi(@rsp+0x30)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第二个参数就是<code>MIDL_STUBLESS_PROXY_INFO </code>结构体指针, 第三个是函数序号. 如果确认是进程内的调用, 可以直接在当前线程的<code>RPCRT4!Invoke</code>下断点, 直接找到相关处理函数.</p>
<p>示例堆栈:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">07 00000053`8d2fd8e0 00007ffe`ef6d7de3     eapahost!EapHost::HostAuthenticatorApis::EapHostAuthenticatorReceivePacket+0xde // 实际调用的函数</span><br><span class="line"></span><br><span class="line">08 00000053`8d2fd960 00007ffe`ef73bc6d     RPCRT4!Invoke+0x73</span><br><span class="line">09 00000053`8d2fd9d0 00007ffe`ef6668b9     RPCRT4!Ndr64StubWorker+0xbfd</span><br><span class="line">0a 00000053`8d2fe0a0 00007ffe`ef802209     RPCRT4!NdrStubCall3+0xc9</span><br><span class="line">0b 00000053`8d2fe100 00007ffe`ef66a92b     combase!CStdStubBuffer_Invoke+0x59 [d:\rs1\onecore\com\combase\ndr\ndrole\stub.cxx @ 1527] </span><br><span class="line">0c 00000053`8d2fe140 00007ffe`ef84de3c     RPCRT4!CStdStubBuffer_Invoke+0x3b</span><br><span class="line">0d (Inline Function) --------`--------     combase!InvokeStubWithExceptionPolicyAndTracing::__l6::&lt;lambda_76d9e92c799d246a4afbe64a2bf5673d&gt;::operator()+0x24 [d:\rs1\onecore\com\combase\dcomrem\channelb.cxx @ 1824] </span><br><span class="line">0e 00000053`8d2fe170 00007ffe`ef84e482     combase!ObjectMethodExceptionHandlingAction&lt;&lt;lambda_76d9e92c799d246a4afbe64a2bf5673d&gt; &gt;+0x4c [d:\rs1\onecore\com\combase\dcomrem\excepn.hxx @ 91] </span><br><span class="line">0f (Inline Function) --------`--------     combase!InvokeStubWithExceptionPolicyAndTracing+0x8d [d:\rs1\onecore\com\combase\dcomrem\channelb.cxx @ 1822] </span><br><span class="line">10 00000053`8d2fe1d0 00007ffe`ef81fab1     combase!DefaultStubInvoke+0x222 [d:\rs1\onecore\com\combase\dcomrem\channelb.cxx @ 1891] </span><br><span class="line">11 00000053`8d2fe3f0 00007ffe`ef8054c0     combase!CCtxChnl::SendReceive+0x2b1 [d:\rs1\onecore\com\combase\dcomrem\crossctx.cxx @ 4138] </span><br><span class="line">12 00000053`8d2fe660 00007ffe`ef737aed     combase!NdrExtpProxySendReceive+0x1c0 [d:\rs1\onecore\com\combase\ndr\ndrole\proxy.cxx @ 1965] </span><br><span class="line">13 00000053`8d2fe6d0 00007ffe`ef8014f4     RPCRT4!NdrpClientCall3+0x46d</span><br><span class="line">14 00000053`8d2feae0 00007ffe`ef90cbb2     combase!ObjectStublessClient+0x144 [d:\rs1\onecore\com\combase\ndr\ndrole\amd64\stblsclt.cxx @ 371] </span><br><span class="line">15 00000053`8d2fee70 00007ffe`e27a4808     combase!ObjectStubless+0x42 [d:\rs1\onecore\com\combase\ndr\ndrole\amd64\stubless.asm @ 176] </span><br><span class="line"></span><br><span class="line">eapahost!ObjectStublessClient6(直接调用的 combase!ObjectStublessClient6)// 进入com接口调用</span><br><span class="line"></span><br><span class="line">16 00000053`8d2feec0 00007ffe`e27a25d9     iassam!EAPSession::processEAPPacket+0x64</span><br></pre></td></tr></table></figure>



<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>来自 <a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/4837/Introduction-to-RPC-Part-1#Implicitandexplicithandles17" title="Introduce RPC">示例项目</a><br>下面提到的”Example1.h”是自动生成的.</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File Example1Server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Example1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Server function.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Output</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* szOutput)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; szOutput &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Naive security callback.</span></span><br><span class="line">RPC_STATUS CALLBACK <span class="title function_">SecurityCallback</span><span class="params">(RPC_IF_HANDLE <span class="comment">/*hInterface*/</span>, <span class="type">void</span>* <span class="comment">/*pBindingHandle*/</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> RPC_S_OK; <span class="comment">// Always allow anyone.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   RPC_STATUS status;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Uses the protocol combined with the endpoint for receiving</span></span><br><span class="line">   <span class="comment">// remote procedure calls.</span></span><br><span class="line">   status = RpcServerUseProtseqEp(</span><br><span class="line">      reinterpret_cast&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(<span class="string">&quot;ncacn_ip_tcp&quot;</span>), <span class="comment">// Use TCP/IP protocol.</span></span><br><span class="line">      RPC_C_PROTSEQ_MAX_REQS_DEFAULT, <span class="comment">// Backlog queue length for TCP/IP.</span></span><br><span class="line">      reinterpret_cast&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(<span class="string">&quot;4747&quot;</span>),         <span class="comment">// TCP/IP port to use.</span></span><br><span class="line">      <span class="literal">NULL</span>);                          <span class="comment">// No security.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (status)</span><br><span class="line">      <span class="built_in">exit</span>(status);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Registers the Example1 interface.</span></span><br><span class="line">   status = RpcServerRegisterIf2(</span><br><span class="line">      Example1_v1_0_s_ifspec,              <span class="comment">// Interface to register.</span></span><br><span class="line">      <span class="literal">NULL</span>,                                <span class="comment">// Use the MIDL generated entry-point vector.</span></span><br><span class="line">      <span class="literal">NULL</span>,                                <span class="comment">// Use the MIDL generated entry-point vector.</span></span><br><span class="line">      RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH, <span class="comment">// Forces use of security callback.</span></span><br><span class="line">      RPC_C_LISTEN_MAX_CALLS_DEFAULT,      <span class="comment">// Use default number of concurrent calls.</span></span><br><span class="line">      (<span class="type">unsigned</span>)<span class="number">-1</span>,                        <span class="comment">// Infinite max size of incoming data blocks.</span></span><br><span class="line">      SecurityCallback);                   <span class="comment">// Naive security callback.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (status)</span><br><span class="line">      <span class="built_in">exit</span>(status);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Start to listen for remote procedure</span></span><br><span class="line">   <span class="comment">// calls for all registered interfaces.</span></span><br><span class="line">   <span class="comment">// This call will not return until</span></span><br><span class="line">   <span class="comment">// RpcMgmtStopServerListening is called.</span></span><br><span class="line">   status = RpcServerListen(</span><br><span class="line">     <span class="number">1</span>,                                   <span class="comment">// Recommended minimum number of threads.</span></span><br><span class="line">     RPC_C_LISTEN_MAX_CALLS_DEFAULT,      <span class="comment">// Recommended maximum number of threads.</span></span><br><span class="line">     FALSE);                              <span class="comment">// Start listening now.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (status)</span><br><span class="line">      <span class="built_in">exit</span>(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Memory allocation function for RPC.</span></span><br><span class="line"><span class="comment">// The runtime uses these two functions for allocating/deallocating</span></span><br><span class="line"><span class="comment">// enough memory to pass the string to the server.</span></span><br><span class="line"><span class="type">void</span>* __RPC_USER <span class="title function_">midl_user_allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Memory deallocation function for RPC.</span></span><br><span class="line"><span class="type">void</span> __RPC_USER <span class="title function_">midl_user_free</span><span class="params">(<span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>idl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// File Example1.idl</span><br><span class="line">[</span><br><span class="line">   // A unique identifier that distinguishes this interface from other interfaces.</span><br><span class="line">   uuid(00000001-EAF3-4A7A-A0F2-BCE4C30DA77E),</span><br><span class="line"></span><br><span class="line">   // This is version 1.0 of this interface.</span><br><span class="line">   version(1.0)</span><br><span class="line">]</span><br><span class="line">interface Example1 // The interface is named Example1</span><br><span class="line">&#123;</span><br><span class="line">   // A function that takes a zero-terminated string.</span><br><span class="line">   void Output(</span><br><span class="line">      [in, string] const char* szOutput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// File Example1Client.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;../Example1/Example1.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   RPC_STATUS status;</span><br><span class="line">   unsigned char* szStringBinding = NULL;</span><br><span class="line"></span><br><span class="line">   // Creates a string binding handle.</span><br><span class="line">   // This function is nothing more than a printf.</span><br><span class="line">   // Connection is not done here.</span><br><span class="line">   status = RpcStringBindingCompose(</span><br><span class="line">      NULL, // UUID to bind to.</span><br><span class="line">      reinterpret_cast&lt;unsigned char*&gt;(&quot;ncacn_ip_tcp&quot;), // Use TCP/IP</span><br><span class="line">                                                        // protocol.</span><br><span class="line">      reinterpret_cast&lt;unsigned char*&gt;(&quot;localhost&quot;), // TCP/IP network</span><br><span class="line">                                                     // address to use.</span><br><span class="line">      reinterpret_cast&lt;unsigned char*&gt;(&quot;4747&quot;), // TCP/IP port to use.</span><br><span class="line">      NULL, // Protocol dependent network options to use.</span><br><span class="line">      &amp;szStringBinding); // String binding output.</span><br><span class="line"></span><br><span class="line">   if (status)</span><br><span class="line">      exit(status);</span><br><span class="line"></span><br><span class="line">   // Validates the format of the string binding handle and converts</span><br><span class="line">   // it to a binding handle.</span><br><span class="line">   // Connection is not done here either.</span><br><span class="line">   status = RpcBindingFromStringBinding(</span><br><span class="line">      szStringBinding, // The string binding to validate.</span><br><span class="line">      &amp;hExample1Binding); // Put the result in the implicit binding</span><br><span class="line">                          // handle defined in the IDL file.</span><br><span class="line"></span><br><span class="line">   if (status)</span><br><span class="line">      exit(status);</span><br><span class="line"></span><br><span class="line">   RpcTryExcept</span><br><span class="line">   &#123;</span><br><span class="line">      // Calls the RPC function. The hExample1Binding binding handle</span><br><span class="line">      // is used implicitly.</span><br><span class="line">      // Connection is done here.</span><br><span class="line">      Output(&quot;Hello Implicit RPC World!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   RpcExcept(1)</span><br><span class="line">   &#123;</span><br><span class="line">      std::cerr &lt;&lt; &quot;Runtime reported exception &quot; &lt;&lt; RpcExceptionCode()</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   RpcEndExcept</span><br><span class="line"></span><br><span class="line">   // Free the memory allocated by a string.</span><br><span class="line">   status = RpcStringFree(</span><br><span class="line">      &amp;szStringBinding); // String to be freed.</span><br><span class="line"></span><br><span class="line">   if (status)</span><br><span class="line">      exit(status);</span><br><span class="line"></span><br><span class="line">   // Releases binding handle resources and disconnects from the server.</span><br><span class="line">   status = RpcBindingFree(</span><br><span class="line">      &amp;hExample1Binding); // Frees the implicit binding handle defined in</span><br><span class="line">                          // the IDL file.</span><br><span class="line"></span><br><span class="line">   if (status)</span><br><span class="line">      exit(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Memory allocation function for RPC.</span><br><span class="line">// The runtime uses these two functions for allocating/deallocating</span><br><span class="line">// enough memory to pass the string to the server.</span><br><span class="line">void* __RPC_USER midl_user_allocate(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    return malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Memory deallocation function for RPC.</span><br><span class="line">void __RPC_USER midl_user_free(void* p)</span><br><span class="line">&#123;</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.tiraniddo.dev/2021/08/how-to-secure-windows-rpc-server-and.html">https://www.tiraniddo.dev/2021/08/how-to-secure-windows-rpc-server-and.html</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/4837/Introduction-to-RPC-Part-1#Implicitandexplicithandles17">https://www.codeproject.com/Articles/4837/Introduction-to-RPC-Part-1#Implicitandexplicithandles17</a></p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢 <a target="_blank" rel="noopener" href="https://twitter.com/KeyZ3r0">k0shl</a>, <a target="_blank" rel="noopener" href="https://twitter.com/XiaoWei___">@XiaoWei___</a> 两位大佬帮我理解这个rpc.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2023/09/13/ics_CVE-2023-38148-readme/" class="prev">上一篇</a><a href="/2023/03/24/compiler_error/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '28b1a73c3ed656a9a85d',     
    clientSecret: '59837bb4cbe7b2f12df366fdbcb37fa4ba084d44',     
    id: 'Wed Sep 06 2023 18:11:27 GMT+0800',    
    repo: 'blog-comment',     
    owner: '474172261',     
    admin: '474172261',     
})   
gitalk.render('gitalk-container')</script><div class="copyright"><p>© 2015 - 2024 <a href="http://474172261.github.io">VictorV</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>