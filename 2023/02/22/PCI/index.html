<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> PCI 配置空间介绍 · VictorV的小博客</title><meta name="description" content="PCI 配置空间介绍 - VictorV"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://474172261.github.io/atom.xml" title="VictorV的小博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="VictorV的小博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/vv474172261" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/474172261" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">PCI 配置空间介绍</h1><div class="post-info">2023年2月22日</div><div class="post-content"><p>经常和虚拟化打交道, 一定会涉及到虚拟设备的初始化, 这就需要对硬件的初始化操作有一定的了解. 初始化硬件设备, 主要就是激活IO port 和IO memory的功能, 对于一些PCIe设备, 还可能需要激活一些capabilities. 本文的内容不是有条理的介绍, 更偏向于资料的整理. 希望可以帮助到大家.</p>
<span id="more"></span>

<h1 id="PCI"><a href="#PCI" class="headerlink" title="PCI"></a>PCI</h1><p>PCI配置空间和内存空间是分离的，那么如何访问这段空间呢？我们首先要对所有的PCI设备进行编码以避免冲突，通常我们是以三段编码来区分PCI设备，即Bus Number, Device Number和Function Number,以后我们简称他们为BDF(<a target="_blank" rel="noopener" href="https://gist.github.com/cuteribs/0a4d85f745506c801d46bea22b554f7d">已知大部分VID表</a> )。为了保证其唯一性，Vendor ID应当向PCI特别兴趣小组(PCI SIG)申请而得到。</p>
<p>为了为PCI设备分配CPU-relative space，计算机系统需要知道其所申请的地址空间的类型、基址等，这些信息记录在设备的BAR中，每个PCI配置空间拥有6个BAR，因此每个PCI设备最多能映射6段地址空间(实际很多设备用不了这么多)。PCI配置空间的初始值是由厂商预设在设备中的，于是设备需要哪些地址空间都是其自己定的，可能造成不同的PCI设备所映射的地址空间冲突，因此在PCI设备枚举(也叫总线枚举，由BIOS或者OS在启动时完成)的过程中，会重新为其分配地址空间，然后写入PCI配置空间中。</p>
<p>通过memory space访问设备I&#x2F;O的方式称为memory mapped I&#x2F;O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I&#x2F;O。</p>
<p>通过I&#x2F;O space访问设备I&#x2F;O的方式称为port I&#x2F;O，或者port mapped I&#x2F;O，这种情况下CPU需要使用专门的I&#x2F;O指令如IN&#x2F;OUT访问I&#x2F;O端口。</p>
<p>常见的MMIO例子有，VGA card将framebuffer映射到memory space，NIC将自己的片上缓冲映射到memory  space，实际上，最典型的MMIO应该是DRAM，它将自己的存储空间映射到memory space，是占用CPU地址空间最多的“设备”。</p>
<p>一个典型的PCI架构如下:</p>
<p><img src="/images/PCI/v2-8019075041788ae2cc2810cb80be24aa_hd.jpg" alt="img"></p>
<h2 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h2><p>PCI是并行总线, 虽然表面上看, 并行总线会比串行总线一次性串数的数据更多, 但是随着频率的提高, 线路干扰越加严重, 而且并行传输对线路的一致性要求非常高, 设计更加麻烦, 而串行总线通过提高频率, 可以有效提高传输速度和传输质量, 因此PCIe采用了串行差分信号传输.</p>
<p><img src="/images/PCI/v2-710e375e3faea0c7103ebf4e3f82b957_hd.png" alt="img"></p>
<h2 id="Intel-pci-寄存器格式"><a href="#Intel-pci-寄存器格式" class="headerlink" title="Intel pci 寄存器格式"></a>Intel pci 寄存器格式</h2><p>有了BDF我们既可以唯一确定某一PCI设备。不同的芯片厂商访问配置空间的方法略有不同，我们以Intel的芯片组为例，其使用IO空间的CF8h&#x2F;CFCh地址来访问PCI设备的配置寄存器 (参考<a target="_blank" rel="noopener" href="http://www.csit-sun.pub.ro/~cpop/Documentatie_SMP/Intel_Microprocessor_Systems/Intel_ProcessorNew/Intel%20White%20Paper/Accessing%20PCI%20Express%20Configuration%20Registers%20Using%20Intel%20Chipsets.pdf">Accessing PCI Express* Configuration Registers Using Intel® Chipsets</a>).</p>
<p><img src="/images/PCI/1565576320008.png" alt="1565576320008"></p>
<p>当我们需要获取&#x2F;修改特定设备值时:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)|(bus number&lt;&lt;<span class="number">16</span>)|(dev number&lt;&lt;<span class="number">11</span>)|(func number&lt;&lt;<span class="number">8</span>)|reg_number, <span class="number">0xcf8</span>)**;</span><br><span class="line">read(<span class="number">0xcfc</span>);<span class="comment">// or write(value, 0xcfc);</span></span><br></pre></td></tr></table></figure>



<p>关于如何配置PCI空间, 可以参考<a target="_blank" rel="noopener" href="http://developer.amd.com/wordpress/media/2012/10/pci%20-%20pci%20express%20configuration%20space%20access.pdf">此链接</a>.</p>
<h2 id="PCI配置空间"><a href="#PCI配置空间" class="headerlink" title="PCI配置空间"></a>PCI配置空间</h2><p>PCI设备都有一个256字节的配置空间, 前0x40 bytes有固定的格式规范, header type 为 0 的结构如下:</p>
<p><img src="/images/PCI/1646295878003.png" alt="1646295878003"></p>
<p>其中<strong>Device ID</strong>和<strong>Vendor ID</strong>是区分不同设备的关键，OS和UEFI在很多时候就是通过匹配他们来找到不同的设备驱动（Class Code有时也起一定作用）。<a target="_blank" rel="noopener" href="https://01.org/sites/default/files/documentation/ivb_ihd_os_vol3_part2_0.pdf">更多参考</a> 或者 <a target="_blank" rel="noopener" href="http://fpga-faq.narod.ru/PCI_Rev_30.pdf">PCI Local Bus Specification 第六章</a>.</p>
<p>command 细节说明:</p>
<p><img src="/images/PCI/1565606247983.png" alt="1565606247983"></p>
<p><img src="/images/PCI/1565606329690.png" alt="1565606329690"></p>
<p><strong>与PCIE配置差异</strong></p>
<p><img src="/images/PCI/1566375425047.png" alt="1566375425047"></p>
<table>
<thead>
<tr>
<th>Type 0</th>
<th>Base Address Registers (0x10:0x24)</th>
<th>All Bits</th>
<th>PCIe Endpoint devices must set the BAR’s prefetchable bit while the  range does not contain memory with read side-effects or where the  memory does not tolerate write merging. 64-Bit Addressing MUST be  supported by non legacy Endpoint devices. The minimum memory address  range requested by a BAR 128-bytes.</th>
</tr>
</thead>
<tbody><tr>
<td>Type 0</td>
<td>Min_Gnt&#x2F;Max_Lat Registers (0x3E:0x3F)</td>
<td>All Bits</td>
<td>Does not apply to PCIe. Hardwired to 0.</td>
</tr>
</tbody></table>
<p><img src="/images/PCI/1566375381038.png" alt="1566375381038"></p>
<p><a target="_blank" rel="noopener" href="https://wiki.osdev.org/PCI_Express#Enhanced_Configuration_Mechanism">Enhanced Configuration Mechanism</a></p>
<h2 id="PCIe配置空间"><a href="#PCIe配置空间" class="headerlink" title="PCIe配置空间"></a>PCIe配置空间</h2><p>PCIe规范为每个PCIe设备添加了更多的配置寄存器，空间为4K，尽管CFG_ADDR和CFG_DATA寄存器方法仍然能够访问lower 255 bytes，但是必须提供另外一种方法来访问剩下的（255B~4K）range寄存器。Intel的解决方案是使用了预留256MB内存地址空间，对这段内存的任何访问都会发起PCIe配置cycle。</p>
<p>由于4K的配置空间是directly mapped to memory的，那么PCIe规范必须保证所有的PCIe设备的配置空间占用不同的内存地址，按照PCIe规范，支持最多256个bus，每个Bus支持最多32个PCIe devices，每个device支持最多8个function,也就是说：占用内存的最大值为：256 * 32 * 8 * 4K &#x3D; 256MB。被PCIe配置空间占用的256M内存空间会屏蔽掉DRAM使用该段内存区，这些地址都由CPU出厂时已经固化好了。<a target="_blank" rel="noopener" href="http://www.ssdfans.com/blog/2017/08/03/%E8%80%81%E7%94%B7%E5%AD%A9%E8%AF%BBpcie%E4%B9%8B%E5%85%AD%EF%BC%9A%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/">老男孩读PCIe之六：配置和地址空间</a>,  <a target="_blank" rel="noopener" href="https://www.ssdfans.com/blog/2018/10/25/%E4%BB%8Ecpu%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3pcie/">从cpu角度理解pcie</a>.</p>
<p><img src="/images/PCI/082916_1254_PCIe5.png" alt="img"></p>
<p>下图是ARM Cortex-A9 datasheet内存地址分配局部图:</p>
<p><img src="/images/PCI/3-1-1024x365.jpg" alt="img"></p>
<p>下图是Ubuntu Guest的cat &#x2F;proc&#x2F;iomem的截图:</p>
<p><img src="/images/PCI/1566289828132.png" alt="1566289828132"></p>
<p>图中的MMConfig(也叫 MMCFG) 就是PCIe的配置空间的映射地址. 因为只有0x80个bus, 所以size为 0x1000 * 8 * 32 * 128 &#x3D; 0x800,000. </p>
<blockquote>
<p>0000:00:0f.0 的意义是:segment number: bus number : device number: function number</p>
</blockquote>
<p>下图是windows的RWeverything工具读取的内容:</p>
<p><img src="/images/PCI/1566444712446.png" alt="1566444712446"></p>
<p>关于如何获取该地址, 参见后续ACPI章节.</p>
<blockquote>
<p>windows 获取ACPI的MCFG也可以通过FirmwareTablesView 工具读取MCFG表, 获取0x2C位置的地址, 即为segment0对应的baseAddr.</p>
</blockquote>
<p>访问PCIe设备配置空间时候需要手动计算访问PCIe配置空间的地址。计算发放如下:</p>
<p>SIZE_PER_FUNC &#x3D; 4K &#x3D; 1000h (fn&lt;&lt;12)</p>
<p>SIZE_PER_DEVICE &#x3D; 4K * 8 &#x3D; 8000h (dev&lt;&lt;15)</p>
<p>SIZE_PER_BUS &#x3D; 4K * 8 * 32 &#x3D; 100000h (bus&lt;&lt;20)</p>
<p>访问总线号为busNo，设备号为DevNo，功能号为funcNo的offset寄存器的计算公式是：</p>
<p>Memory Address &#x3D; BaseAddr+ busNo * SIZE_PER_BUS+ devNo * SIZE_PER_DEVICE+ funcNo * SIZE_PER_FUNC+ offset</p>
<p>PCIe在存储域地址空间分为三部分，PCIe控制器本身的寄存器、PCIe设备的配置空间、PCIe设备空间。寄存器和配置空间由处理器本身决定存储地址范围，ARM Cortex-A9 处理器地址范围如下图所示，配置空间地址、寄存器地址及内存地址都已经确定。PCIe设备空间需要编程人员去配置Outbound和Inbound寄存器组，确定映射关系。</p>
<p><img src="/images/PCI/1-1024x472.jpg" alt="img"></p>
<p><strong>Outbound</strong>在PCIe控制器中扮演的角色是将存储地址翻译到PCIe域的PCIe地址，Inbound是将PCIe地址翻译成存储地址，下图是一个完整的RC和EP模型地址翻译模型，图中的地址数字仅仅代表一种形态，具体地址应该是什么在后文中讲解。当cpu需要访问EP的内存空间时，首先应该将存储地址转换成PCIe地址，在根据TLP到达指定的EP，进而将PCIe地址转换成EP端的存储地址。<a target="_blank" rel="noopener" href="https://www.ssdfans.com/blog/2018/11/01/%e4%bb%8ecpu%e8%a7%92%e5%ba%a6%e7%90%86%e8%a7%a3pcie%e7%bb%ad%e9%9b%86/">参考</a></p>
<p><img src="/images/PCI/2.jpg" alt="img"></p>
<h2 id="RC-Root-Complex"><a href="#RC-Root-Complex" class="headerlink" title="RC(Root Complex)"></a>RC(Root Complex)</h2><p>CPU只能直接访问Host内存（Memory）空间（或者IO空间，我们不考虑），不对PCIe等外设直接操作。RC可以为CPU分忧。</p>
<p>CPU如果想访问某个设备的空间，由于它不能（或者不屑）亲自跟那些PCIe外设打交道，因此叫太监RC去办。比如，如果CPU想读PCIe外设的数据，先叫RC通过TLP把数据从PCIe外设读到Host内存，然后CPU从Host内存读数据；如果CPU要往外设写数据，则先把数据在内存中准备好，然后叫RC通过TLP写入到PCIe设备。 以下是图形示例:</p>
<p><img src="/images/PCI/082916_1254_PCIe4.png" alt="img"></p>
<p>上图例子中，最左边虚线的表示CPU要读Endpoint A的数据，RC则通过TLP（经历Switch）数据交互获得数据，并把它写入到系统内存中，然后CPU从内存中读取数据（紫色箭头所示），从而CPU间接完成对PCIe设备数据的读取。 </p>
<p>具体实现就是上电的时候，系统把PCIe设备开放的空间（系统软件可见）映射到内存空间，CPU要访问该PCIe设备空间，只需访问对应的内存空间。RC检查该内存地址，如果发现该内存空间地址是某个PCIe设备空间的映射，就会触发其产生TLP，去访问对应的PCIe设备，读取或者写入PCIe设备。 </p>
<h2 id="BAR-base-address-register"><a href="#BAR-base-address-register" class="headerlink" title="BAR(base address register)"></a>BAR(base address register)</h2><p>Bar内存空间的细节:</p>
<p><img src="/images/PCI/1664417949426.png" alt="1664417949426"></p>
<p>计算bar空间大小方式如下:</p>
<ol>
<li>向bar 写入全1</li>
<li>读回寄存器里面的值，然后clear 上图中特殊编码的值，(IO 中bit0，bit1， memory中bit0-3)</li>
<li>取反+1, 得到空间大小.</li>
</ol>
<p><strong>映射地址空间</strong></p>
<p>使用I&#x2F;O内存首先要申请,然后才能映射,使用I&#x2F;O端口首先要申请,对I&#x2F;O端口的请求是让内核知道你要访问该端口,内核并让你独占该端口. 申请I&#x2F;O端口的函数是<strong>request_region</strong>, 申请I&#x2F;O内存的函数是<strong>request_mem_region</strong>。request_mem_region函数并没有做实际性的映射工作，只是告诉内核要使用一块内存地址，声明占有，也方便内核管理这些资源。重要的还是ioremap函数，ioremap主要是检查传入地址的合法性，建立页表（包括访问权限），完成物理地址到虚拟地址的转换。</p>
<p>可以通过<code>cat /proc/ioports</code> 和<code>cat /proc/iomem</code> 来查看系统已有的映射情况.</p>
<p><strong>workstation更换memory 地址</strong></p>
<ol>
<li>write 新地址到bar</li>
<li>重新激活command的第2个比特. 这样映射就会生效</li>
</ol>
<h2 id="PCI-to-PCI-bridge"><a href="#PCI-to-PCI-bridge" class="headerlink" title="PCI to PCI bridge"></a>PCI to PCI bridge</h2><p>它的配置空间如下:</p>
<p><img src="/images/PCI/v2-46ff2b447a3b736fd540fb27b7acf4a8_hd.jpg" alt="img"></p>
<p>其中的三组绿色的BUS Number和多组黄色的BASE&#x2F;Limit对，它决定了桥和桥下面的PCI设备子树相应&#x2F;被分配的Bus和各种资源大小和位置。这些值都是由PCI枚举程序来设置的。</p>
<h2 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h2><p>PCI-X和PCIe总线规范要求其设备必须支持Capabilities结构。在PCI总线的基本配置空间中，包含一个Capabilities Pointer寄存器，该寄存器存放Capabilities结构链表的头指针。在一个PCIe设备中，可能含有多个Capability结构，这些寄存器组成一个链表，其结构如图：</p>
<p><img src="/images/PCI/v2-6a9c100cb7a43758a47436a0115841cc_hd.jpg" alt="img"></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>HDAudio的配置空间说明如下:</p>
<p><img src="/images/PCI/1566371700027.png" alt="1566371700027"></p>
<p>以下是Workstation模拟的HDAudio的配置空间:</p>
<p><img src="/images/PCI/1566283096392.png" alt="1566283096392"></p>
<blockquote>
<p>似乎capability pointer指向的偏移处都是PCI power management功能的. XHCI就是这样.</p>
</blockquote>
<h2 id="VMware-workstation"><a href="#VMware-workstation" class="headerlink" title="VMware workstation"></a>VMware workstation</h2><p><img src="/images/PCI/1565689994200.png" alt="1565689994200"></p>
<h1 id="遍历PCI设备"><a href="#遍历PCI设备" class="headerlink" title="遍历PCI设备"></a>遍历PCI设备</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">retrieveAddress</span><span class="params">(u32 vid, u32 did, u32 *bar0, u32 *bar2)</span> &#123;</span><br><span class="line"></span><br><span class="line">	u32 bus, dev, func;</span><br><span class="line">	u32 dwAddr, dwData;</span><br><span class="line">	<span class="comment">//u16 VID, DID, SVID, SDID;</span></span><br><span class="line">	<span class="comment">//u32 addr = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (bus = <span class="number">0</span>; bus &lt;= <span class="number">255</span>; bus++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (dev = <span class="number">0</span>; dev &lt; <span class="number">32</span>; dev++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (func = <span class="number">0</span>; func &lt; <span class="number">8</span>; func++)</span><br><span class="line">			&#123;</span><br><span class="line">				dwAddr = <span class="number">0x80000000</span> + (bus &lt;&lt; <span class="number">16</span>) + (dev &lt;&lt; <span class="number">11</span>) + (func &lt;&lt; <span class="number">8</span>);</span><br><span class="line">				<span class="comment">/* read vendor id */</span></span><br><span class="line">				outl(dwAddr, PCI_CONFIG_ADDRESS);</span><br><span class="line">				dwData = inl(PCI_CONFIG_DATA);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ((((dwData &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) == did) &amp;&amp;<span class="comment">// vendor id</span></span><br><span class="line">					((dwData &amp; <span class="number">0xffff</span>) == vid)) &#123;<span class="comment">// dev id</span></span><br><span class="line">					outl(dwAddr | <span class="number">0x10</span>, PCI_CONFIG_ADDRESS);<span class="comment">// bar0</span></span><br><span class="line">					*bar0 = inl(PCI_CONFIG_DATA);</span><br><span class="line">					<span class="keyword">if</span> (*bar0 &amp; <span class="number">1</span>) &#123;</span><br><span class="line">						*bar0 ^= <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//outl(dwAddr | 0x18, PCI_CONFIG_ADDRESS);// bar2</span></span><br><span class="line">					<span class="comment">//*bar2 = inl(PCI_CONFIG_DATA);</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">///*  read sub-vendor id*/</span></span><br><span class="line">				<span class="comment">//outl(dwAddr | 0x10, PCI_CONFIG_ADDRESS);</span></span><br><span class="line">				<span class="comment">//addr = inl(PCI_CONFIG_DATA);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="comment">//if (dwData != 0xffffffff)</span></span><br><span class="line">				<span class="comment">//&#123;</span></span><br><span class="line">				<span class="comment">//	count++;</span></span><br><span class="line">				<span class="comment">//	VID = dwData &amp; 0xffff;</span></span><br><span class="line">				<span class="comment">//	DID = (dwData &gt;&gt; 16) &amp; 0xffff;</span></span><br><span class="line">				<span class="comment">//	SVID = dwData1 &amp; 0xffff;</span></span><br><span class="line">				<span class="comment">//	SDID = (dwData1 &gt;&gt; 16) &amp; 0xffff;</span></span><br><span class="line">				<span class="comment">//	printk(&quot;%02X\t%02X\t%02X\t%04X\t%04X\t%04X\t%04X\t\n&quot;,</span></span><br><span class="line">				<span class="comment">//		bus, dev, func, VID, DID, SVID, SDID);</span></span><br><span class="line">				<span class="comment">//&#125;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Linux设备的初始化流程"><a href="#Linux设备的初始化流程" class="headerlink" title="Linux设备的初始化流程"></a>Linux设备的初始化流程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">	pci_enable_device(<span class="keyword">struct</span> pci_dev *dev)</span><br><span class="line">		pci_enable_device_flags(<span class="keyword">struct</span> pci_dev *dev, <span class="type">unsigned</span> <span class="type">long</span> IORESOURCE_MEM|IORESOURCE_IO)&#123;</span><br><span class="line">			read bars from PCI;</span><br><span class="line">			do_pci_enable_device(dev, bars);</span><br><span class="line">				<span class="comment">// power on</span></span><br><span class="line">				pci_set_power_state(enable)&#123;<span class="comment">// 可能pcie才需要这个</span></span><br><span class="line">                     pci_set_full_power_state(dev)&#123;</span><br><span class="line">                         pci_power_up(dev)&#123;</span><br><span class="line">                             pci_write_config_word(dev, dev-&gt;pm_cap + PCI_PM_CTRL, <span class="number">0</span>);<span class="comment">//PCI_PM_CTRL=4</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">				    <span class="comment">//*(pcie+pcie-&gt;cap_pointer +4) = PCI_D0;//PCI_D0 = 0</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// enable IO bar</span></span><br><span class="line">				pcibios_enable_device(<span class="keyword">struct</span> pci_dev *dev, <span class="type">int</span> bars)</span><br><span class="line">					pci_enable_resources(dev, bars);&#123;</span><br><span class="line">						<span class="comment">// if bar is 6, means ROM resource</span></span><br><span class="line">						r = &amp;dev-&gt;resource[i];</span><br><span class="line">						<span class="keyword">if</span> (r-&gt;flags &amp; IORESOURCE_IO)</span><br><span class="line">							cmd |= PCI_COMMAND_IO;</span><br><span class="line">						<span class="keyword">if</span> (r-&gt;flags &amp; IORESOURCE_MEM)</span><br><span class="line">							cmd |= PCI_COMMAND_MEMORY;</span><br><span class="line">						pci_write_config_word(dev, PCI_COMMAND, cmd);</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="comment">// check interrupt and enable</span></span><br><span class="line">				<span class="keyword">if</span> (dev-&gt;msi_enabled || dev-&gt;msix_enabled)</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				pci_write_config_word(dev, PCI_COMMAND,</span><br><span class="line">					      cmd &amp; ~PCI_COMMAND_INTX_DISABLE);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 配置pci bar空间</span></span><br><span class="line">	pci_request_regions(pci, <span class="string">&quot;ICH HD audio&quot;</span>);</span><br><span class="line">		pci_request_selected_regions(pdev, ((<span class="number">1</span> &lt;&lt; <span class="number">6</span>) - <span class="number">1</span>), res_name);&#123;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">				__pci_request_region(pdev, i, res_name, excl))&#123;</span><br><span class="line">					<span class="keyword">if</span> (pci_resource_flags(pdev, bar) &amp; IORESOURCE_IO)&#123;</span><br><span class="line">						request_region(pci_resource_start(pdev, bar),pci_resource_len(pdev, bar), res_name)<span class="comment">// 不做啥, 只是告诉内核要用这个内存</span></span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						__request_mem_region(pci_resource_start(pdev, bar),pci_resource_len(pdev, bar), res_name,exclusive)<span class="comment">//不做啥, 只是告诉内核要用这个内存</span></span><br><span class="line">					&#125;</span><br><span class="line">					dr = find_pci_dr(pdev);</span><br><span class="line">					<span class="keyword">if</span> (dr)</span><br><span class="line">						dr-&gt;region_mask |= <span class="number">1</span> &lt;&lt; bar;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// ioremap</span></span><br><span class="line">	addr = pci_resource_start(pci, <span class="number">0</span>);<span class="comment">// get bar0</span></span><br><span class="line">	ioremap(addr, pci_resource_len(pdev, <span class="number">0</span>));</span><br><span class="line">	pci_set_master(pci);</span><br><span class="line">		__pci_set_master(<span class="keyword">struct</span> pci_dev *dev, <span class="type">bool</span> enable)&#123;</span><br><span class="line">            pci_read_config_word(dev, PCI_COMMAND, &amp;old_cmd);</span><br><span class="line">			cmd = old_cmd | PCI_COMMAND_MASTER;</span><br><span class="line">			pci_write_config_word(dev, PCI_COMMAND, cmd);</span><br><span class="line">        &#125;</span><br><span class="line">		pcibios_set_master(dev);&#123;</span><br><span class="line">            <span class="keyword">if</span> (pci_is_pcie(dev))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            pci_read_config_byte(dev, PCI_LATENCY_TIMER, &amp;lat);</span><br><span class="line">            <span class="keyword">if</span> (lat &lt; <span class="number">16</span>)</span><br><span class="line">                lat = (<span class="number">64</span> &lt;= pcibios_max_latency) ? <span class="number">64</span> : pcibios_max_latency;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lat &gt; pcibios_max_latency)</span><br><span class="line">                lat = pcibios_max_latency;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_pm_init</span><span class="params">(<span class="keyword">struct</span> pci_dev *dev)</span>&#123;</span><br><span class="line">    pm = pci_find_capability(dev, PCI_CAP_ID_PM)&#123;</span><br><span class="line">        pos = __pci_bus_find_cap_start(dev-&gt;bus, dev-&gt;devfn, dev-&gt;hdr_type)&#123;</span><br><span class="line">            pci_bus_read_config_word(bus, devfn, PCI_STATUS, &amp;status);</span><br><span class="line">            <span class="keyword">if</span> (!(status &amp; PCI_STATUS_CAP_LIST))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (hdr_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> PCI_HEADER_TYPE_NORMAL:</span><br><span class="line">            <span class="keyword">case</span> PCI_HEADER_TYPE_BRIDGE:</span><br><span class="line">                <span class="keyword">return</span> PCI_CAPABILITY_LIST;</span><br><span class="line">            <span class="keyword">case</span> PCI_HEADER_TYPE_CARDBUS:</span><br><span class="line">                <span class="keyword">return</span> PCI_CB_CAPABILITY_LIST;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos)</span><br><span class="line">            pos = __pci_find_next_cap(dev-&gt;bus, dev-&gt;devfn, pos, cap)&#123;</span><br><span class="line">                <span class="type">int</span> ttl = PCI_FIND_CAP_TTL;</span><br><span class="line">                <span class="keyword">return</span> __pci_find_next_cap_ttl(bus, devfn, pos, cap, &amp;ttl)&#123;</span><br><span class="line">                    pci_bus_read_config_byte(bus, devfn, pos, &amp;pos);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> ((*ttl)--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pos &lt; <span class="number">0x40</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        pos &amp;= ~<span class="number">3</span>;</span><br><span class="line">                        pci_bus_read_config_word(bus, devfn, pos, &amp;ent);</span><br><span class="line"></span><br><span class="line">                        id = ent &amp; <span class="number">0xff</span>;</span><br><span class="line">                        <span class="keyword">if</span> (id == <span class="number">0xff</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span> (id == cap)</span><br><span class="line">                            <span class="keyword">return</span> pos;</span><br><span class="line">                        pos = (ent &gt;&gt; <span class="number">8</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><h3 id="PCI-Address-Domain"><a href="#PCI-Address-Domain" class="headerlink" title="PCI Address Domain"></a>PCI Address Domain</h3><p>The PCI address domain consists of three distinct address spaces: configuration, memory, and I&#x2F;O space. </p>
<h3 id="PCI-Configuration-Address-Space"><a href="#PCI-Configuration-Address-Space" class="headerlink" title="PCI Configuration Address Space"></a>PCI Configuration Address Space</h3><p>Configuration space is defined geographically; in other words, the  location of a peripheral device is determined by its physical location  within an interconnected tree of PCI bus bridges. A device is located by  its <strong>bus number</strong> and <strong>device</strong> (<strong>slot</strong>) <strong>number</strong>.  Each peripheral device contains a set of well-defined configuration  registers in its PCI configuration space. The registers are used not  only to identify devices but also to supply device configuration  information to the configuration framework. For example, base address  registers in the device configuration space must be mapped before a  device can respond to data access.  </p>
<p>The method for generating configuration cycles is host dependent. In  IA machines, special I&#x2F;O ports are used. On other platforms, the PCI  configuration space can be memory-mapped to certain address locations  corresponding to the PCI host bridge in the host address domain. When a  device configuration register is accessed by the processor, the request  is routed to the PCI host bridge. The bridge then translates the access  into proper configuration cycles on the bus. </p>
<h3 id="PCI-Configuration-Base-Address-Registers"><a href="#PCI-Configuration-Base-Address-Registers" class="headerlink" title="PCI Configuration Base Address Registers"></a>PCI Configuration Base Address Registers</h3><p>The PCI configuration space consists of up to six 32-bit base address  registers for each device. These registers provide both size and data  type information. System firmware assigns base addresses in the PCI  address domain to these registers.  </p>
<p>Each addressable region can be either memory or I&#x2F;O space. The value  contained in bit 0 of the base address register identifies the type. A  value of 0 in bit 0 indicates a memory space and a value of 1 indicates  an I&#x2F;O space. <a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19455-01/805-7378/6j6un038j/index.html#hwovr-fig-29">Figure A-4</a> shows two base address registers: one for memory; the other for I&#x2F;O types.</p>
<p>Figure A-4  Base Address Registers for Memory and I&#x2F;O</p>
<p><img src="/images/PCI/hwovr.fig69.epsi.gif" alt="Graphic"></p>
<h3 id="PCI-Memory-Address-Space"><a href="#PCI-Memory-Address-Space" class="headerlink" title="PCI Memory Address Space"></a>PCI Memory Address Space</h3><p>PCI supports both 32-bit and 64-bit addresses for memory space.  System firmware assigns regions of memory space in the PCI address  domain to PCI peripherals. The base address of a region is stored in the  base address register of the device’s PCI configuration space. The size  of each region must be a power of two, and the assigned base address  must be aligned on a boundary equal to the size of the region. Device  addresses in memory space are <strong>memory-mapped</strong> into the host address  domain so that data access to any device can be performed by the  processor’s native load or store instructions.  </p>
<h3 id="PCI-I-x2F-O-Address-Space"><a href="#PCI-I-x2F-O-Address-Space" class="headerlink" title="PCI I&#x2F;O Address Space"></a>PCI I&#x2F;O Address Space</h3><p>PCI supports 32-bit I&#x2F;O space. I&#x2F;O space can be accessed differently  on different platforms. Processors with special I&#x2F;O instructions, like  the Intel processor family, access the I&#x2F;O space with <code>in</code> and <code>out</code>  instructions. Machines without special I&#x2F;O instructions will map to the  address locations corresponding to the PCI host bridge in the host  address domain. When the processor accesses the memory-mapped addresses,  an I&#x2F;O request will be sent to the PCI host bridge. It then translates  the addresses into I&#x2F;O cycles and puts them on the PCI bus.  Memory-mapped I&#x2F;O is performed by the native load&#x2F;store instructions of  the processor.   </p>
<h3 id="PCI-Hardware-Configuration-Files"><a href="#PCI-Hardware-Configuration-Files" class="headerlink" title="PCI Hardware Configuration Files"></a>PCI Hardware Configuration Files</h3><p>Hardware configuration files should be unnecessary for PCI local bus  devices. However, on some occasions drivers for PCI devices need to use  hardware configuration files to augment the driver private information.  See <a target="_blank" rel="noopener" href="https://docs.oracle.com/docs/cd/E19455-01/806-0633/6j9vn6q3i/index.html">driver.conf(4)</a> and <a target="_blank" rel="noopener" href="https://docs.oracle.com/docs/cd/E19455-01/806-0633/6j9vn6q61/index.html">pci(4)</a> for further details. </p>
<h1 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h1><p><strong>pci_mcfg_lookup</strong></p>
<p><img src="/images/PCI/1566376943595.png" alt="1566376943595"></p>
<p><strong>Get bus number in windows</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the BusNumber</span></span><br><span class="line">status = <span class="built_in">WdfDeviceQueryProperty</span>( device,</span><br><span class="line">DevicePropertyBusNumber,</span><br><span class="line"><span class="built_in">sizeof</span>(ULONG),</span><br><span class="line">(PVOID)&amp;busNumber,</span><br><span class="line">&amp;length);</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">NT_SUCCESS</span>(status) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">error_print</span>(<span class="string">&quot;Failed to get PCIe bus number.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> https://lkml.org/lkml/2013/12/5/256 says: the &quot;change to</span></span><br><span class="line"><span class="comment">// definition of the &quot;Bus&quot; field into the recently released ACPI</span></span><br><span class="line"><span class="comment">// Spec 5.0a section 18.3.2.3-5: ... The Bus is encoded in bits 0-7.</span></span><br><span class="line"><span class="comment">// For systems that expose multiple PCI segment groups, the segment</span></span><br><span class="line"><span class="comment">// number is encoded in bits 8-23 and bits 24-31 must be zero.&quot;</span></span><br><span class="line">devContext-&gt;pcie_bus = (<span class="type">uint8_t</span>)busNumber;</span><br><span class="line">devContext-&gt;pcie_segment = (busNumber &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFFFF</span>;</span><br></pre></td></tr></table></figure>

<h2 id="ACPI"><a href="#ACPI" class="headerlink" title="ACPI"></a>ACPI</h2><p>ACPI（Advanced Configuration and Power Interface）Table是BIOS提供给OSPM的硬件配置数据，包括系统硬件的电源管理和配置管理，ACPI Table有很多表，根据存储的位置，可以分为：</p>
<p>1） RSDP位于F段，用于OSPM搜索ACPI Table，RSDP可以定位其他所有ACPI Table</p>
<p>2） FACS位于ACPI NVS内存，用于系统进行S3保存的恢复指针，内存为NV Store</p>
<p>3） 剩下所有ACPI Table都位于ACPI Reclaim内存，进入OS后，内存可以释放</p>
<p><img src="/images/PCI/acpitable.JPG" alt="img"></p>
<p>其中绿色代表在内存F段，蓝色是ACPI Reclaim内存，红色是NV store内存.</p>
<p>整个ACPI表以RSDP（Root System Descriptor Pointer<br>Table）为入口点，每个非叶子节点都会包含指向其他子表的指针，各个表都会有一个表头，在该表头中包含了相应的Signature，用于标识该表，有点类似与该表的ID，除此之外，在表头中还会包含Checksum、Revision、OEM ID等信息。所以查找ACPI表的关键就是在内存中定位到RSDP表。</p>
<p>对于基于Legacy BIOS的系统而言，RSDP表所在的物理地址并不固定，要么位于EBDA（Extended BIOS Data Area, 位于物理地址0x40E）的前1KB范围内；要么位于0x000E0000 到0x000FFFFF的物理地址范围内。Linux kernel在启动的时候，会去这两个物理地址范围，通过遍历物理地址空间的方法寻找RSDP表，即通过寻找RSDP表的Signature（RSD PTR）来定位RSDP的位置，并通过该表的length和checksum来确保找到的表是正确的。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><img src="/images/PCI/1646299430462.png" alt="1646299430462"></p>
<p>The RSDT is the main System Description Table. However there are many  kinds of SDT. All the SDT may be split into two parts. One (the header)  which is <strong>common</strong> to all the SDT an another (data) which is <strong>different</strong> for  each table. </p>
<p>The header structure of the header is: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACPISDTHeader</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> Signature[<span class="number">4</span>];</span><br><span class="line">  <span class="type">uint32_t</span> Length;</span><br><span class="line">  <span class="type">uint8_t</span> Revision;</span><br><span class="line">  <span class="type">uint8_t</span> Checksum;</span><br><span class="line">  <span class="type">char</span> OEMID[<span class="number">6</span>];<span class="comment">//0x10</span></span><br><span class="line">  <span class="type">char</span> OEMTableID[<span class="number">8</span>];</span><br><span class="line">  <span class="type">uint32_t</span> OEMRevision;</span><br><span class="line">  <span class="type">uint32_t</span> CreatorID;<span class="comment">//0x20</span></span><br><span class="line">  <span class="type">uint32_t</span> CreatorRevision;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过暴力搜索内存中的”RSD PTR”字符串, 找到对应的内容. 定位+0x10指向的地址, 得到RSDT表.<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dWrAaawmgvQ">参考视频</a></p>
<p><img src="/images/PCI/1566447934665.png" alt="1566447934665"></p>
<p><img src="/images/PCI/1566448122215.png" alt="1566448122215"></p>
<p><strong>MCFG table:</strong></p>
<p><img src="/images/PCI/1566376865146.png" alt="1566376865146"></p>
<p>其中44(0x2C)位置的 Base Address of enhanced configuration mechanism 就是 segment(有的成为group) 为 0 的<strong>MMConfig</strong> 的地址.</p>
<p><img src="/images/PCI/1566448244626.png" alt="1566448244626"></p>
<h2 id="Get-MMCFG-or-MCFG-in-kernel"><a href="#Get-MMCFG-or-MCFG-in-kernel" class="headerlink" title="Get MMCFG or MCFG in kernel"></a>Get MMCFG or MCFG in kernel</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52136259/how-to-access-pci-express-configuration-space-via-mmio">How to access pci express configuration space via MMIO?</a> , <a target="_blank" rel="noopener" href="http://developer.amd.com/wordpress/media/2012/10/pci%20-%20pci%20express%20configuration%20space%20access.pdf">pci express configuration space access</a> .</p>
<h3 id="windows-用户态"><a href="#windows-用户态" class="headerlink" title="windows 用户态"></a>windows 用户态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">UINT WINAPI <span class="title function_">EnumSystemFirmwareTables</span><span class="params">(</span></span><br><span class="line"><span class="params">     _In_ DWORD FirmwareTableProviderSignature,</span></span><br><span class="line"><span class="params">     _Out_writes_bytes_to_opt_(BufferSize, <span class="keyword">return</span>) PVOID pFirmwareTableEnumBuffer,</span></span><br><span class="line"><span class="params">     _In_ DWORD BufferSize</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">UINT WINAPI <span class="title function_">GetSystemFirmwareTable</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ DWORD FirmwareTableProviderSignature,</span></span><br><span class="line"><span class="params">    _In_ DWORD FirmwareTableID,</span></span><br><span class="line"><span class="params">    _Out_writes_bytes_to_opt_(BufferSize, <span class="keyword">return</span>) PVOID pFirmwareTableBuffer,</span></span><br><span class="line"><span class="params">    _In_ DWORD BufferSize</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">// 第一次先取得 ACPI Tables Enum Buffer Size</span></span><br><span class="line">PBYTE buffer;	</span><br><span class="line">DWORD buffer_size = EnumSystemFirmwareTables(<span class="string">&#x27;ACPI&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (buffer_size == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 產生一塊Buffer去取得 ACPI Tables Enum</span></span><br><span class="line">buffer = new BYTE[buffer_size];</span><br><span class="line"><span class="keyword">if</span> (EnumSystemFirmwareTables(<span class="string">&#x27;ACPI&#x27;</span>, buffer, buffer_size) != buffer_size)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">free</span>(buffer);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">   PBYTE table_uffer;	</span><br><span class="line">   DWORD table_buffer_size;</span><br><span class="line"><span class="comment">// read MCFG table</span></span><br><span class="line">   <span class="keyword">if</span>(GetSystemFirmwareTable(<span class="string">&#x27;ACPI&#x27;</span>, <span class="string">&#x27;GFCM&#x27;</span>, table_uffer, buffer_size))&#123;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sACPITableHeader</span> &#123;</span></span><br><span class="line">         BYTE	Signature[<span class="number">4</span>];</span><br><span class="line">         DWORD	Length;</span><br><span class="line">         BYTE	Revision;</span><br><span class="line">         BYTE	Checksum;</span><br><span class="line">         BYTE	OEMID[<span class="number">6</span>];</span><br><span class="line">         BYTE	OEMTableID[<span class="number">8</span>];</span><br><span class="line">         DWORD	OEMRevision;</span><br><span class="line">         BYTE	CreatorID[<span class="number">4</span>];</span><br><span class="line">         DWORD	CreatorRevision;</span><br><span class="line">     &#125; sACPITableHeader;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 取的 ACPI Table Buffer</span></span><br><span class="line">     <span class="comment">//... </span></span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<h3 id="windows-内核态"><a href="#windows-内核态" class="headerlink" title="windows 内核态"></a>windows 内核态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aux_klib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Aux_Klib.lib&quot;</span>)	</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">kzalloc</span><span class="params">(u32 size, u32 notuse)</span> &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(notuse);</span><br><span class="line">	<span class="type">void</span> *mem = ExAllocatePool(NonPagedPool, size);</span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line">	<span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line">	u32 *pFirmwareTableEnumBuffer = kzalloc(<span class="number">0x4000</span>, <span class="number">0</span>);</span><br><span class="line">	ret = AuxKlibInitialize();</span><br><span class="line">	u32 ret = AuxKlibGetSystemFirmwareTable(</span><br><span class="line">		<span class="string">&#x27;ACPI&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;GFCM&#x27;</span>,<span class="comment">//MCFG</span></span><br><span class="line">		pFirmwareTableEnumBuffer,</span><br><span class="line">		<span class="number">0x4000</span>,</span><br><span class="line">		&amp;len</span><br><span class="line">	);</span><br><span class="line">or </span><br><span class="line">ntStatus = AuxKlibEnumerateSystemFirmwareTables(</span><br><span class="line">   <span class="string">&#x27;ACPI&#x27;</span>,</span><br><span class="line">   <span class="literal">NULL</span>,</span><br><span class="line">   <span class="number">0</span>,</span><br><span class="line">   &amp;sigListSize</span><br><span class="line">   );</span><br><span class="line">buff = kzalloc(sigListSize);</span><br><span class="line">ntStatus = AuxKlibEnumerateSystemFirmwareTables(</span><br><span class="line">   <span class="string">&#x27;ACPI&#x27;</span>,</span><br><span class="line">   buff,</span><br><span class="line">   sigListSize,</span><br><span class="line">   <span class="literal">NULL</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<h2 id="ATU-Address-Translation-Unit"><a href="#ATU-Address-Translation-Unit" class="headerlink" title="ATU(Address Translation Unit)"></a>ATU(Address Translation Unit)</h2><p>TLP中的地址哪里来？ATU转换过来的。这个问题就是这么的简单。ATU是什么？是一个地址转换单元，负责将一段存储器域的地址转换到PCIe总线域地址，除了地址转换外，还能提供访问类型等信息，这些信息都是ATU根据总线上的信号自己做的，数据都打包到TLP中，不用软件参与。软件需要做的是配置ATU，所以如果ATU配置完成，并且能正常工作，那么CPU访问PCIe空间就和访问本地存储器空间方法是一样的，只要读写即可。</p>
<p>这就解释了存储器地址和TLP地址字段的关系了。至此，地址相关的问题就解决了。</p>
<p>ATU配置举例：以kernel 4.4中designware PCIe host驱动为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void dw_pcie_prog_outbound_atu(struct pcie_port *pp, int index,</span><br><span class="line">		int type, u64 cpu_addr, u64 pci_addr, u32 size)</span><br><span class="line">&#123;</span><br><span class="line">    // 使用哪个ATU</span><br><span class="line">	dw_pcie_writel_rc(pp, PCIE_ATU_REGION_OUTBOUND | index,</span><br><span class="line">			  PCIE_ATU_VIEWPORT);</span><br><span class="line">    // source地址（存储器域）的低32位</span><br><span class="line">	dw_pcie_writel_rc(pp, lower_32_bits(cpu_addr), PCIE_ATU_LOWER_BASE);</span><br><span class="line">	dw_pcie_writel_rc(pp, upper_32_bits(cpu_addr), PCIE_ATU_UPPER_BASE);</span><br><span class="line">    // space size</span><br><span class="line">	dw_pcie_writel_rc(pp, lower_32_bits(cpu_addr + size - 1),</span><br><span class="line">			  PCIE_ATU_LIMIT);</span><br><span class="line">    // 目标地址空间（PCIe总线地址）</span><br><span class="line">	dw_pcie_writel_rc(pp, lower_32_bits(pci_addr), PCIE_ATU_LOWER_TARGET);</span><br><span class="line">	dw_pcie_writel_rc(pp, upper_32_bits(pci_addr), PCIE_ATU_UPPER_TARGET);</span><br><span class="line">    // 空间类型（mem or IO）</span><br><span class="line">	dw_pcie_writel_rc(pp, type, PCIE_ATU_CR1);</span><br><span class="line">    // 使能ATU</span><br><span class="line">	dw_pcie_writel_rc(pp, PCIE_ATU_ENABLE, PCIE_ATU_CR2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2023/02/22/windows-debug-setting/" class="prev">上一篇</a><a href="/2023/02/22/qemu-virtual-device-init/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '28b1a73c3ed656a9a85d',     
    clientSecret: '59837bb4cbe7b2f12df366fdbcb37fa4ba084d44',     
    id: 'Wed Feb 22 2023 19:54:44 GMT+0800',    
    repo: 'blog-comment',     
    owner: '474172261',     
    admin: '474172261',     
})   
gitalk.render('gitalk-container')</script><div class="copyright"><p>© 2015 - 2025 <a href="http://474172261.github.io">VictorV</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>