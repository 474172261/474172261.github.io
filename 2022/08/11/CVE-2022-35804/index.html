<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> SMB RCE CVE-2022-35804的介绍 · VictorV的小博客</title><meta name="description" content="SMB RCE CVE-2022-35804的介绍 - VictorV"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://474172261.github.io/atom.xml" title="VictorV的小博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="VictorV的小博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/474172261" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">SMB RCE CVE-2022-35804的介绍</h1><div class="post-info">2022年8月11日</div><div class="post-content"><p>2022年8月更新中出现了SMB的RCE, 微软介绍说对于server端是认证后的, 所以应该不会是历史漏洞重新出现的问题, 毕竟曾经也分析过一阵子SMB, 出现了新鲜漏洞还是需要分析分析的, 以下是一个简单的分析介绍</p>
<span id="more"></span>

<h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>首先官方介绍是压缩相关的bug, 对比<code>srv2.sys</code>和<code>srvnet.sys</code>后,  发现<code>srvnet.sys</code>的<code>SmbCompressionDecompress</code>有改动, 所以大概率是它了.</p>
<p>以下是相关改动:</p>
<p><img src="/images/CVE-2022-35804/1660184030021.png" alt="1660184030021"></p>
<p>从图中看到, 改动其实很小, 就改了最后一个传入参数.</p>
<p>查看MSDN对于该函数的说明:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NT_RTL_COMPRESS_API NTSTATUS <span class="title function_">RtlDecompressBufferEx2</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           USHORT CompressionFormat,</span></span><br><span class="line"><span class="params">  [out]          PUCHAR UncompressedBuffer,</span></span><br><span class="line"><span class="params">  [in]           ULONG  UncompressedBufferSize,</span></span><br><span class="line"><span class="params">  [in]           PUCHAR CompressedBuffer,</span></span><br><span class="line"><span class="params">  [in]           ULONG  CompressedBufferSize,</span></span><br><span class="line"><span class="params">  [in]           ULONG  UncompressedChunkSize,</span></span><br><span class="line"><span class="params">  [out]          PULONG FinalUncompressedSize,</span></span><br><span class="line"><span class="params">  [in, optional] PVOID  WorkSpace</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">[in, optional] WorkSpace</span><br><span class="line"></span><br><span class="line">A pointer to a caller-allocated work space buffer used by the RtlDecompressBufferEx2 function during decompression. Use the RtlGetCompressionWorkSpaceSize function to determine the correct work space buffer size.</span><br></pre></td></tr></table></figure>

<p>所以可以了解到, workspace理应是caller申请的一块内存. </p>
<p>一般来说, 应该是如下的形式调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(NT_SUCCESS(RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM, &amp;CompressBufferWorkSpaceSize, &amp;CompressFragmentWorkSpaceSize)))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(WorkSpace = LocalAlloc(LPTR, CompressBufferWorkSpaceSize))</span><br><span class="line">	&#123;</span><br><span class="line">            status = NT_SUCCESS(RtlDecompressBufferEx2(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM, (PUCHAR) data, size, (PUCHAR) (*compressedData), size, <span class="number">4096</span>, compressedSize, WorkSpace));</span><br><span class="line">		LocalFree(WorkSpace);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用<code>RtlGetCompressionWorkSpaceSize</code>获取需要的workspace的size, 然后申请对应大小的内存, 之后再调用解压缩函数.</p>
<p>接下来, 我们看看<code>P</code>到底是个什么东西.<br>在<code>SmbCompressionInitialize</code>函数内, 它初始化了全局变量<code>P</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CompressionWorkSpaceSize = RtlGetCompressionWorkSpaceSize(</span><br><span class="line">                             <span class="number">2u</span>,</span><br><span class="line">                             &amp;CompressBufferWorkSpaceSize,</span><br><span class="line">                             &amp;CompressFragmentWorkSpaceSize);</span><br><span class="line"><span class="keyword">if</span> ( CompressionWorkSpaceSize &lt; <span class="number">0</span> )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( CompressBufferWorkSpaceSize )</span><br><span class="line">  v1 = CompressBufferWorkSpaceSize;</span><br><span class="line">CompressionWorkSpaceSize = RtlGetCompressionWorkSpaceSize(</span><br><span class="line">                             <span class="number">3u</span>,</span><br><span class="line">                             &amp;CompressBufferWorkSpaceSize,</span><br><span class="line">                             &amp;CompressFragmentWorkSpaceSize);</span><br><span class="line"><span class="keyword">if</span> ( CompressionWorkSpaceSize &lt; <span class="number">0</span> )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_12;</span><br><span class="line"><span class="keyword">if</span> ( CompressBufferWorkSpaceSize &gt; v1 )</span><br><span class="line">  v1 = CompressBufferWorkSpaceSize;</span><br><span class="line">CompressionWorkSpaceSize = RtlGetCompressionWorkSpaceSize(</span><br><span class="line">                             <span class="number">4u</span>,</span><br><span class="line">                             &amp;CompressBufferWorkSpaceSize,</span><br><span class="line">                             &amp;CompressFragmentWorkSpaceSize);</span><br><span class="line"><span class="keyword">if</span> ( CompressionWorkSpaceSize &lt; <span class="number">0</span> )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_12;</span><br><span class="line"><span class="keyword">if</span> ( CompressBufferWorkSpaceSize &gt; v1 )</span><br><span class="line">  v1 = CompressBufferWorkSpaceSize;</span><br><span class="line">P = (PVOID)PplCreateLookasideList(<span class="number">0</span>, <span class="number">0</span>, v1, <span class="number">0x2532534C</span>u, v3, <span class="number">0x2532534C</span>u);</span><br></pre></td></tr></table></figure>

<p>可以看到, 它应该是放入了3种压缩类型所需要的size中最大的那一个, 这样在需要的时候, 申请最大的那个size的workspace就好了.</p>
<p>由于程序员错误的使用, 不小心传入了<code>P</code>, 导致了类型混淆, 从而造成了对<code>P</code>的写入问题.</p>
<h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><p>在windows 10 1909的代码中, <code>SmbCompressionDecompress</code>是这样实现的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( RtlGetCompressionWorkSpaceSize(v13, &amp;CompressBufferWorkSpaceSize, (PULONG)CompressFragmentWorkSpaceSize) &lt; <span class="number">0</span></span><br><span class="line">  || (PoolWithTag = ExAllocatePoolWithTag((POOL_TYPE)<span class="number">512</span>, CompressBufferWorkSpaceSize, <span class="number">0x2532534C</span>u)) != <span class="number">0</span>i64 )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = RtlDecompressBufferEx2(v13, a4, (<span class="type">unsigned</span> <span class="type">int</span>)a5, a2, a3, <span class="number">0</span>, a6, PoolWithTag);</span><br><span class="line">  <span class="keyword">if</span> ( PoolWithTag )</span><br><span class="line">    ExFreePoolWithTag(PoolWithTag, <span class="number">0x2532534C</span>u);</span><br></pre></td></tr></table></figure>

<p>可见没有任何问题, 在windows 10 2004里, 开始变了模样, 但是参数传递是修补后的样子. 之前保存过windows 20211(发布于2020年9月)的<code>srvnet.sys</code>文件, 发现它是传递了<code>P</code>, 所以可以看到, 这个bug应该某个开发版引入的, 一直延续到了windows 11. </p>
<p>有意思的是, 它的变量类型是<code>PVOID</code>, 而<code>P</code>也是<code>PVOID</code>, 所以编译器不会有任何警告. 理论上只要有任何测试触发这个位置, 这块代码都有可能会崩溃, 但是直到如今, 才被爆出来, 也是出人意料的, 可见微软内部的安全审计依然不到位(也许就没有).</p>
<blockquote>
<p>我想微软之所以那么改, 可能是为了提高内存利用效率, 避免频繁的申请内存吧, 没想到搞出这等幺蛾子, 哈哈哈</p>
</blockquote>
<h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>好在, 自从windows 爆出过压缩部分的bug后, 它已经要求server端先验证, 后压缩, 使得bug只能是认证后才能触发. 但是Client端还是会受影响的, 毕竟client主动连的server, 也就不存在认证限制了.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2022/06/17/SELinux/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://474172261.github.io">VictorV</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>