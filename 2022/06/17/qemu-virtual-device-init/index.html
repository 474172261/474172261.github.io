<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> QEMU虚拟化设备简介 · VictorV的小博客</title><meta name="description" content="QEMU虚拟化设备简介 - VictorV"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://474172261.github.io/atom.xml" title="VictorV的小博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="VictorV的小博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/vv474172261" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/474172261" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">QEMU虚拟化设备简介</h1><div class="post-info">2022年6月17日</div><div class="post-content"><p>简单介绍qemu的虚拟化组件的初始化和入口</p>
<span id="more"></span>

<p>虚拟化设备分为两类, 一种是<strong>全虚拟化</strong>, 一种是<strong>半虚拟化</strong>.</p>
<p>一般来说, 全虚拟化设备是指设备相关的实现都在物理机的用户态, 半虚拟化是部分实现在物理机的内核态. 一个常见的半虚拟化标准是virtio设备标准.</p>
<blockquote>
<p>但是不同平台的不同虚拟化软件, 对同一个虚拟化设备的实现存在差异, 所以也不一定是按前面的说法去实现的. </p>
</blockquote>
<h1 id="传统IO设备"><a href="#传统IO设备" class="headerlink" title="传统IO设备"></a>传统IO设备</h1><p>传统的IO设备是全虚拟化设备, 此类设备有IO port及IO memory, 可以通过写IO相关的端口或者内存实现设备交互. </p>
<h1 id="虚拟设备的注册"><a href="#虚拟设备的注册" class="headerlink" title="虚拟设备的注册"></a>虚拟设备的注册</h1><p>qemu的每个虚拟化设备都会调用 type_init() 确认设备的注册操作, 调用 type_register&#x2F;type_register_static 来注册一个虚拟设备, 传入的结构体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">size_t</span> instance_align;</span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以e1000为例的设备注册操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">e1000_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    type_register_static(&amp;e1000_base_info);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(e1000_devices); i++) &#123;</span><br><span class="line">        <span class="type">const</span> E1000Info *info = &amp;e1000_devices[i];</span><br><span class="line">        TypeInfo type_info = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        type_info.name = info-&gt;name;</span><br><span class="line">        type_info.parent = TYPE_E1000_BASE;</span><br><span class="line">        type_info.class_data = (<span class="type">void</span> *)info;</span><br><span class="line">        type_info.class_init = e1000_class_init;</span><br><span class="line"></span><br><span class="line">        type_register(&amp;type_info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TypeImpl *<span class="title function_">type_register_static</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> type_register(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(e1000_register_types)</span><br></pre></td></tr></table></figure>

<p>.name 决定了设备名称, 在qemu中使用 -device 查看所有device的时候可以看到的名字.  </p>
<p>.class_init 指示了设备初始化的函数, 这里我关注e1000_class_init的初始化操作.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">e1000_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">    E1000BaseClass *e = E1000_CLASS(klass);</span><br><span class="line">    <span class="type">const</span> E1000Info *info = data;</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_e1000_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span> = pci_e1000_uninit;</span><br><span class="line">    k-&gt;romfile = <span class="string">&quot;efi-e1000.rom&quot;</span>;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_INTEL;</span><br><span class="line">    k-&gt;device_id = info-&gt;device_id;</span><br><span class="line">    k-&gt;revision = info-&gt;revision;</span><br><span class="line">    e-&gt;phy_id2 = info-&gt;phy_id2;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_NETWORK_ETHERNET;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_NETWORK, dc-&gt;categories);</span><br><span class="line">    dc-&gt;desc = <span class="string">&quot;Intel Gigabit Ethernet&quot;</span>;</span><br><span class="line">    dc-&gt;reset = qdev_e1000_reset;</span><br><span class="line">    dc-&gt;vmsd = &amp;vmstate_e1000;</span><br><span class="line">    device_class_set_props(dc, e1000_properties);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">    DeviceClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*realize)(PCIDevice *dev, Error **errp);</span><br><span class="line">    PCIUnregisterFunc *<span class="built_in">exit</span>;</span><br><span class="line">    PCIConfigReadFunc *config_read;</span><br><span class="line">    PCIConfigWriteFunc *config_write;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> vendor_id;</span><br><span class="line">    <span class="type">uint16_t</span> device_id;</span><br><span class="line">    <span class="type">uint8_t</span> revision;</span><br><span class="line">    <span class="type">uint16_t</span> class_id;</span><br><span class="line">    <span class="type">uint16_t</span> subsystem_vendor_id;       <span class="comment">/* only for header type = 0 */</span></span><br><span class="line">    <span class="type">uint16_t</span> subsystem_id;              <span class="comment">/* only for header type = 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * pci-to-pci bridge or normal device.</span></span><br><span class="line"><span class="comment">     * This doesn&#x27;t mean pci host switch.</span></span><br><span class="line"><span class="comment">     * When card bus bridge is supported, this would be enhanced.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> is_bridge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rom bar */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *romfile;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>k-&gt;realize 就是主要的初始化函数. 在realize中, 一般就会初始化对应的IO空间和绑定处理函数.  </p>
<p>PCIDeviceClass-&gt;config_read和config_write 对应的是设备的PCI 配置空间的读写处理函数. </p>
<blockquote>
<p>如果没有声明, 默认在do_pci_register_device中会赋值 pci_default_read_config&#x2F;pci_default_write_config.</p>
</blockquote>
<h1 id="IO-handler的初始化"><a href="#IO-handler的初始化" class="headerlink" title="IO handler的初始化"></a>IO handler的初始化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_e1000_realize</span><span class="params">(PCIDevice *pci_dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev = DEVICE(pci_dev);</span><br><span class="line">    E1000State *d = E1000(pci_dev);</span><br><span class="line">    <span class="type">uint8_t</span> *pci_conf;</span><br><span class="line">    <span class="type">uint8_t</span> *macaddr;</span><br><span class="line"></span><br><span class="line">    pci_dev-&gt;config_write = e1000_write_config;</span><br><span class="line"></span><br><span class="line">    pci_conf = pci_dev-&gt;config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> RST# value should be 0, PCI spec 6.2.4 */</span></span><br><span class="line">    pci_conf[PCI_CACHE_LINE_SIZE] = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    pci_conf[PCI_INTERRUPT_PIN] = <span class="number">1</span>; <span class="comment">/* interrupt pin A */</span></span><br><span class="line"></span><br><span class="line">    e1000_mmio_setup(d);</span><br><span class="line"></span><br><span class="line">    pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line"></span><br><span class="line">    pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;io);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_mmio_setup</span><span class="params">(E1000State *d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> excluded_regs[] = &#123;</span><br><span class="line">        E1000_MDIC, E1000_ICR, E1000_ICS, E1000_IMS,</span><br><span class="line">        E1000_IMC, E1000_TCTL, E1000_TDT, PNPMMIO_SIZE</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;e1000_mmio_ops, d,</span><br><span class="line">                          <span class="string">&quot;e1000-mmio&quot;</span>, PNPMMIO_SIZE);</span><br><span class="line">    memory_region_add_coalescing(&amp;d-&gt;mmio, <span class="number">0</span>, excluded_regs[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; excluded_regs[i] != PNPMMIO_SIZE; i++)</span><br><span class="line">        memory_region_add_coalescing(&amp;d-&gt;mmio, excluded_regs[i] + <span class="number">4</span>,</span><br><span class="line">                                     excluded_regs[i+<span class="number">1</span>] - excluded_regs[i] - <span class="number">4</span>);</span><br><span class="line">    memory_region_init_io(&amp;d-&gt;io, OBJECT(d), &amp;e1000_io_ops, d, <span class="string">&quot;e1000-io&quot;</span>, IOPORT_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_region_init_io</span><span class="params">(MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                           Object *owner,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> MemoryRegionOps *ops,</span></span><br><span class="line"><span class="params">                           <span class="type">void</span> *opaque,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                           <span class="type">uint64_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    memory_region_init(mr, owner, name, size);</span><br><span class="line">    mr-&gt;ops = ops ? ops : &amp;unassigned_mem_ops;</span><br><span class="line">    mr-&gt;opaque = opaque;</span><br><span class="line">    mr-&gt;terminates = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps e1000_mmio_ops = &#123;</span><br><span class="line">    .read = e1000_mmio_read,</span><br><span class="line">    .write = e1000_mmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">4</span>,</span><br><span class="line">        .max_access_size = <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps e1000_io_ops = &#123;</span><br><span class="line">    .read = e1000_io_read,</span><br><span class="line">    .write = e1000_io_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意, 此处的<code>pci_dev-&gt;config_write = e1000_write_config;</code> 是PCIDevice结构体, realize函数由 pci_qdev_realize 调取, 如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_qdev_realize</span><span class="params">(DeviceState *qdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDevice *pci_dev = (PCIDevice *)qdev;</span><br><span class="line">    PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);</span><br><span class="line">    ...</span><br><span class="line">    pci_dev = do_pci_register_device(pci_dev,</span><br><span class="line">                                     object_get_typename(OBJECT(qdev)),</span><br><span class="line">                                     pci_dev-&gt;devfn, errp);</span><br><span class="line">    <span class="keyword">if</span> (pci_dev == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pc-&gt;realize) &#123;</span><br><span class="line">        pc-&gt;realize(pci_dev, &amp;local_err);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> PCIDevice *<span class="title function_">do_pci_register_device</span><span class="params">(PCIDevice *pci_dev,</span></span><br><span class="line"><span class="params">                                         <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> devfn,</span></span><br><span class="line"><span class="params">                                         Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);</span><br><span class="line">    PCIConfigReadFunc *config_read = pc-&gt;config_read;</span><br><span class="line">    PCIConfigWriteFunc *config_write = pc-&gt;config_write;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!config_read)</span><br><span class="line">        config_read = pci_default_read_config;</span><br><span class="line">    <span class="keyword">if</span> (!config_write)</span><br><span class="line">        config_write = pci_default_write_config;</span><br><span class="line">    pci_dev-&gt;config_read = config_read;</span><br><span class="line">    pci_dev-&gt;config_write = config_write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从顺序可以看到, realize函数在 do_pci_register_device 之后, do_pci_register_device 也会把 PCIDeviceClass-&gt;config_write 赋值给 PCIDevice-&gt;config_write. 所以最终的config_write是什么函数, 以realize为准.</p>
</blockquote>
<p>e1000刚好既有IO port 又有 IO memory. </p>
<p>从代码可以看出, 他们的初始化大同小异. 最开始会调用 memory_region_init 初始化MemoryRegion, 之后将对应的 MemoryRegion 绑定ops. 这里, port 绑定的 e1000_io_ops, memory 绑定的e1000_mmio_ops. </p>
<p>memory_region_init_io 只是memory_region_init 的一个封装.</p>
<p>在初始化好 MemoryRegion 后, 会调用 pci_register_bar 注册它. 如下示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line">pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;io);</span><br></pre></td></tr></table></figure>

<p>第二个参数表面了注册到PCI 配置空间的哪个bar里(参考后续的pci配置空间). 第三个参数指示该 MemoryRegion的类型是port 还是memory. </p>
<p>至于具体的IO port或者memory的值是多少, 取决于Guest的操作系统怎么配置PCI配置空间的.  我们可以通过 <code>lspci -v</code>来查看相关配置:</p>
<p><img src="/images/qemu-virtual-device-init/e1000_pci.png" alt="image-20220303134241878"></p>
<h1 id="特殊的IO-port-handler"><a href="#特殊的IO-port-handler" class="headerlink" title="特殊的IO port handler"></a>特殊的IO port handler</h1><p>除了上述的常规注册MemoryRegionOps操作外, 还有一种注册IO handler的方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">portio_list_init</span><span class="params">(PortioList *piolist,</span></span><br><span class="line"><span class="params">                      Object *owner,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> MemoryRegionPortio *callbacks,</span></span><br><span class="line"><span class="params">                      <span class="type">void</span> *opaque, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (callbacks[n].size) &#123;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    piolist-&gt;ports = callbacks;</span><br><span class="line">    piolist-&gt;nr = <span class="number">0</span>;</span><br><span class="line">    piolist-&gt;regions = g_new0(MemoryRegion *, n);</span><br><span class="line">    piolist-&gt;address_space = <span class="literal">NULL</span>;</span><br><span class="line">    piolist-&gt;opaque = opaque;</span><br><span class="line">    piolist-&gt;owner = owner;</span><br><span class="line">    piolist-&gt;name = name;</span><br><span class="line">    piolist-&gt;flush_coalesced_mmio = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps portio_ops = &#123;</span><br><span class="line">    .read = portio_read,</span><br><span class="line">    .write = portio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    .valid.unaligned = <span class="literal">true</span>,</span><br><span class="line">    .impl.unaligned = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">portio_list_add_1</span><span class="params">(PortioList *piolist,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> MemoryRegionPortio *pio_init,</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> count, <span class="type">unsigned</span> start,</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> off_low, <span class="type">unsigned</span> off_high)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegionPortioList *mrpio;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the sub-list and null-terminate it.  */</span></span><br><span class="line">    mrpio = g_malloc0(<span class="keyword">sizeof</span>(MemoryRegionPortioList) +</span><br><span class="line">                      <span class="keyword">sizeof</span>(MemoryRegionPortio) * (count + <span class="number">1</span>));</span><br><span class="line">    mrpio-&gt;portio_opaque = piolist-&gt;opaque;</span><br><span class="line">    <span class="built_in">memcpy</span>(mrpio-&gt;ports, pio_init, <span class="keyword">sizeof</span>(MemoryRegionPortio) * count);</span><br><span class="line">    <span class="built_in">memset</span>(mrpio-&gt;ports + count, <span class="number">0</span>, <span class="keyword">sizeof</span>(MemoryRegionPortio));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust the offsets to all be zero-based for the region.  */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        mrpio-&gt;ports[i].offset -= off_low;</span><br><span class="line">        mrpio-&gt;ports[i].base = start + off_low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;mrpio-&gt;mr, piolist-&gt;owner, &amp;portio_ops, mrpio,</span><br><span class="line">                          piolist-&gt;name, off_high - off_low); <span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (piolist-&gt;flush_coalesced_mmio) &#123;</span><br><span class="line">        memory_region_set_flush_coalesced(&amp;mrpio-&gt;mr);</span><br><span class="line">    &#125;</span><br><span class="line">    memory_region_add_subregion(piolist-&gt;address_space,</span><br><span class="line">                                start + off_low, &amp;mrpio-&gt;mr);</span><br><span class="line">    piolist-&gt;regions[piolist-&gt;nr] = &amp;mrpio-&gt;mr;</span><br><span class="line">    ++piolist-&gt;nr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">portio_list_add</span><span class="params">(PortioList *piolist,</span></span><br><span class="line"><span class="params">                     MemoryRegion *address_space,</span></span><br><span class="line"><span class="params">                     <span class="type">uint32_t</span> start)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> MemoryRegionPortio *pio, *pio_start = piolist-&gt;ports;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> off_low, off_high, off_last, count;</span><br><span class="line"></span><br><span class="line">    piolist-&gt;address_space = address_space;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle the first entry specially.  */</span></span><br><span class="line">    off_last = off_low = pio_start-&gt;offset;</span><br><span class="line">    off_high = off_low + pio_start-&gt;len + pio_start-&gt;size - <span class="number">1</span>;</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pio = pio_start + <span class="number">1</span>; pio-&gt;size != <span class="number">0</span>; pio++, count++) &#123;</span><br><span class="line">        <span class="comment">/* All entries must be sorted by offset.  */</span></span><br><span class="line">        assert(pio-&gt;offset &gt;= off_last);</span><br><span class="line">        off_last = pio-&gt;offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we see a hole, break the region.  */</span></span><br><span class="line">        <span class="keyword">if</span> (off_last &gt; off_high) &#123;</span><br><span class="line">            portio_list_add_1(piolist, pio_start, count, start, off_low,</span><br><span class="line">                              off_high);</span><br><span class="line">            <span class="comment">/* ... and start collecting anew.  */</span></span><br><span class="line">            pio_start = pio;</span><br><span class="line">            off_low = off_last;</span><br><span class="line">            off_high = off_low + pio-&gt;len + pio_start-&gt;size - <span class="number">1</span>;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off_last + pio-&gt;len &gt; off_high) &#123;</span><br><span class="line">            off_high = off_last + pio-&gt;len + pio_start-&gt;size - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There will always be an open sub-list.  */</span></span><br><span class="line">    portio_list_add_1(piolist, pio_start, count, start, off_low, off_high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种特殊的io port的handler是在行51注册的 portio_ops 来处理的, 即<code>portio_read</code> 和<code>portio_write</code>.</p>
<p>之后, <code>portio_write</code>函数通过遍历注册的port, 来调用对应的处理函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionPortio *<span class="title function_">find_portio</span><span class="params">(MemoryRegionPortioList *mrpio,</span></span><br><span class="line"><span class="params">                                             <span class="type">uint64_t</span> offset, <span class="type">unsigned</span> size,</span></span><br><span class="line"><span class="params">                                             <span class="type">bool</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> MemoryRegionPortio *mrp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (mrp = mrpio-&gt;ports; mrp-&gt;size; ++mrp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= mrp-&gt;offset &amp;&amp; offset &lt; mrp-&gt;offset + mrp-&gt;len &amp;&amp;</span><br><span class="line">            size == mrp-&gt;size &amp;&amp;</span><br><span class="line">            (write ? (<span class="type">bool</span>)mrp-&gt;write : (<span class="type">bool</span>)mrp-&gt;read)) &#123;</span><br><span class="line">            <span class="keyword">return</span> mrp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">portio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegionPortioList *mrpio = opaque;</span><br><span class="line">    <span class="type">const</span> MemoryRegionPortio *mrp = find_portio(mrpio, addr, size, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    data = ((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; (size * <span class="number">8</span>)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mrp) &#123;</span><br><span class="line">        data = mrp-&gt;read(mrpio-&gt;portio_opaque, mrp-&gt;base + addr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">2</span>) &#123;</span><br><span class="line">        mrp = find_portio(mrpio, addr, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (mrp) &#123;</span><br><span class="line">            data = mrp-&gt;read(mrpio-&gt;portio_opaque, mrp-&gt;base + addr);</span><br><span class="line">            <span class="keyword">if</span> (addr + <span class="number">1</span> &lt; mrp-&gt;offset + mrp-&gt;len) &#123;</span><br><span class="line">                data |= mrp-&gt;read(mrpio-&gt;portio_opaque, mrp-&gt;base + addr + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data |= <span class="number">0xff00</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">portio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> data,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegionPortioList *mrpio = opaque;</span><br><span class="line">    <span class="type">const</span> MemoryRegionPortio *mrp = find_portio(mrpio, addr, size, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mrp) &#123;</span><br><span class="line">        mrp-&gt;write(mrpio-&gt;portio_opaque, mrp-&gt;base + addr, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">2</span>) &#123;</span><br><span class="line">        mrp = find_portio(mrpio, addr, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (mrp) &#123;</span><br><span class="line">            mrp-&gt;write(mrpio-&gt;portio_opaque, mrp-&gt;base + addr, data &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="keyword">if</span> (addr + <span class="number">1</span> &lt; mrp-&gt;offset + mrp-&gt;len) &#123;</span><br><span class="line">                mrp-&gt;write(mrpio-&gt;portio_opaque, mrp-&gt;base + addr + <span class="number">1</span>, data &gt;&gt; <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionPortio vbe_portio_list[] = &#123;</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, .read = vbe_ioport_read_index, .write = vbe_ioport_write_index &#125;,</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> TARGET_I386</span></span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, .read = vbe_ioport_read_data, .write = vbe_ioport_write_data &#125;,</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, .read = vbe_ioport_read_data, .write = vbe_ioport_write_data &#125;,</span><br><span class="line">    PORTIO_END_OF_LIST(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vga_init</span><span class="params">(VGACommonState *s, Object *obj, MemoryRegion *address_space,</span></span><br><span class="line"><span class="params">              MemoryRegion *address_space_io, <span class="type">bool</span> init_vga_ports)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegion *vga_io_memory;</span><br><span class="line">    <span class="type">const</span> MemoryRegionPortio *vga_ports, *vbe_ports;</span><br><span class="line"></span><br><span class="line">    qemu_register_reset(vga_reset, s);</span><br><span class="line"></span><br><span class="line">    s-&gt;bank_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;legacy_address_space = address_space;</span><br><span class="line"></span><br><span class="line">    vga_io_memory = vga_init_io(s, obj, &amp;vga_ports, &amp;vbe_ports);</span><br><span class="line">    memory_region_add_subregion_overlap(address_space,</span><br><span class="line">                                        <span class="number">0x000a0000</span>,</span><br><span class="line">                                        vga_io_memory,</span><br><span class="line">                                        <span class="number">1</span>);</span><br><span class="line">    memory_region_set_coalescing(vga_io_memory);</span><br><span class="line">    <span class="keyword">if</span> (init_vga_ports) &#123;</span><br><span class="line">        portio_list_init(&amp;s-&gt;vga_port_list, obj, vga_ports, s, <span class="string">&quot;vga&quot;</span>);</span><br><span class="line">        portio_list_set_flush_coalesced(&amp;s-&gt;vga_port_list);</span><br><span class="line">        portio_list_add(&amp;s-&gt;vga_port_list, address_space_io, <span class="number">0x3b0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vbe_ports) &#123;</span><br><span class="line">        portio_list_init(&amp;s-&gt;vbe_port_list, obj, vbe_ports, s, <span class="string">&quot;vbe&quot;</span>);</span><br><span class="line">        portio_list_add(&amp;s-&gt;vbe_port_list, address_space_io, <span class="number">0x1ce</span>);<span class="comment">// s-&gt;vbe_portio_list 就是全局变量vbe_portio_list, 0x1ce指示了io port起始值.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终, 当读 0x1ce 端口的时候, 就会调用<code>vbe_ioport_read_index</code>函数.</p>
<blockquote>
<p>其实在vmware workstation里也可以看到类似的影子, 比如访问vmci设备的时候, 也是有个封装的上层处理函数在分发.</p>
</blockquote>
<h1 id="PCI-配置空间"><a href="#PCI-配置空间" class="headerlink" title="PCI 配置空间"></a>PCI 配置空间</h1><p>这里简要介绍下PCI配置空间. 当一个设备加入的时候, 设备管理器要了解这个设备是干什么的, 怎么交互, 就需要读取设备的PCI配置空间. 它结构如下:</p>
<p><img src="/images/qemu-virtual-device-init/PCI_space.png"></p>
<blockquote>
<p> <strong>Vendor ID</strong>：厂商ID。知名的设备厂商的ID。FFFFh是一个非法厂商ID，可它来判断PCI设备是否存在。 </p>
<p> <strong>Device ID</strong>：设备ID。某厂商生产的设备的ID。操作系统就是凭着 Vendor ID和Device ID 找到对应驱动程序的。 </p>
<p> <strong>Class Code</strong>：类代码。共三字节，分别是 类代码、子类代码、编程接口。类代码不仅用于区分设备类型，还是编程接口的规范，这就是为什么会有通用驱动程序。 </p>
<p> <strong>IRQ Line</strong>：IRQ编号。PC机以前是靠两片8259芯片来管理16个硬件中断。现在为了支持对称多处理器，有了APIC（高级可编程中断控制器），它支持管理24个中断。 </p>
<p> <strong>IRQ Pin</strong>：中断引脚。PCI有4个中断引脚，该寄存器表明该设备连接的是哪个引脚。</p>
<p><strong>Bars</strong>: 一个有6个bar,  具体的使用看设备本身的实现. 当虚拟机识别到它的时候, 会向该区域写入值, 指示设备的bar用哪部分端口或内存地址.</p>
</blockquote>
<p>如何访问配置空间呢？可通过访问<strong>0xCF8h、0xCFCh</strong>端口来实现。</p>
<p>下面的代码示例了通过遍历所有的bus&#x2F;dev&#x2F;func组合来搜索特定的vid和did的设备的bars.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_CONFIG_ADDRESS 0xcf8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_CONFIG_DATA 0xcfc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  PCI_BASE_ADDRESS_MEM_MASK  (~0x0fUL)</span></span><br><span class="line"></span><br><span class="line">u32 <span class="title function_">retrieveAddress</span><span class="params">(u32 vid, u32 did, u32 *bars)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 bus, dev, func;</span><br><span class="line">  u32 dwAddr, dwData;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (bus = <span class="number">0</span>; bus &lt;= <span class="number">255</span>; bus++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (dev = <span class="number">0</span>; dev &lt; <span class="number">32</span>; dev++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (func = <span class="number">0</span>; func &lt; <span class="number">8</span>; func++)</span><br><span class="line">      &#123;</span><br><span class="line">        dwAddr = <span class="number">0x80000000</span> + (bus &lt;&lt; <span class="number">16</span>) + (dev &lt;&lt; <span class="number">11</span>) + (func &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        <span class="comment">/* read vendor id */</span></span><br><span class="line">        outl(dwAddr, PCI_CONFIG_ADDRESS);</span><br><span class="line">        dwData = inl(PCI_CONFIG_DATA);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((dwData &amp; <span class="number">0xffff</span>) == vid)&#123;<span class="comment">// vendor id</span></span><br><span class="line">          <span class="keyword">if</span> (((dwData &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) == did) &#123;<span class="comment">// dev id</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">              outl(dwAddr | (<span class="number">0x10</span> + i * <span class="number">4</span>), PCI_CONFIG_ADDRESS);<span class="comment">// bar0</span></span><br><span class="line">              dwData = inl(PCI_CONFIG_DATA);</span><br><span class="line">              <span class="keyword">if</span> (dwData &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                dwData ^= <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                dwData &amp;= PCI_BASE_ADDRESS_MEM_MASK;</span><br><span class="line">              &#125;</span><br><span class="line">              bars[i] = dwData;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dwAddr;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于一些现代PCIe设备, 配置空间更大, 就需要使用mmconfig来获取相应的配置信息.</p>
</blockquote>
<h1 id="半虚拟化设备Virtio"><a href="#半虚拟化设备Virtio" class="headerlink" title="半虚拟化设备Virtio"></a>半虚拟化设备Virtio</h1><p>virtio设备分类两种, 一种是legacy, 一种是modern.</p>
<p>legacy的, 就通过IO port 管理它的配置, modern就通过IO memory 来管理它的配置 </p>
<p>要了解virtio设备, 还需要了解它的IO配置接口.</p>
<p>当一个virtio设备开始加载的时候, 会调用 virtio_pci_device_plugged 去初始化它的PCI&#x2F;PCIe 的 IO 空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_device_plugged</span><span class="params">(DeviceState *d, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span> (modern) &#123;</span><br><span class="line">        virtio_pci_modern_regions_init(proxy, vdev-&gt;name);</span><br><span class="line">        virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;common, &amp;cap);</span><br><span class="line">        virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;isr, &amp;cap);</span><br><span class="line">        virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;device, &amp;cap);</span><br><span class="line">        virtio_pci_modern_mem_region_map(proxy, &amp;proxy-&gt;notify, &amp;notify.cap);</span><br><span class="line">        pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;modern_mem_bar_idx,</span><br><span class="line">                         PCI_BASE_ADDRESS_SPACE_MEMORY |</span><br><span class="line">                         PCI_BASE_ADDRESS_MEM_PREFETCH |</span><br><span class="line">                         PCI_BASE_ADDRESS_MEM_TYPE_64,</span><br><span class="line">                         &amp;proxy-&gt;modern_bar);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        size = VIRTIO_PCI_REGION_SIZE(&amp;proxy-&gt;pci_dev)</span><br><span class="line">            + virtio_bus_get_vdev_config_len(bus);</span><br><span class="line">        size = pow2ceil(size);</span><br><span class="line"></span><br><span class="line">        memory_region_init_io(&amp;proxy-&gt;bar, OBJECT(proxy),</span><br><span class="line">                              &amp;virtio_pci_config_ops,</span><br><span class="line">                              proxy, <span class="string">&quot;virtio-pci&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">        pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;legacy_io_bar_idx,</span><br><span class="line">                         PCI_BASE_ADDRESS_SPACE_IO, &amp;proxy-&gt;bar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps virtio_pci_config_ops = &#123;</span><br><span class="line">    .read = virtio_pci_config_read,</span><br><span class="line">    .write = virtio_pci_config_write,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">1</span>,</span><br><span class="line">        .max_access_size = <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_modern_regions_init</span><span class="params">(VirtIOPCIProxy *proxy,</span></span><br><span class="line"><span class="params">                                           <span class="type">const</span> <span class="type">char</span> *vdev_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps common_ops = &#123;</span><br><span class="line">        .read = virtio_pci_common_read,</span><br><span class="line">        .write = virtio_pci_common_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps isr_ops = &#123;</span><br><span class="line">        .read = virtio_pci_isr_read,</span><br><span class="line">        .write = virtio_pci_isr_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps device_ops = &#123;</span><br><span class="line">        .read = virtio_pci_device_read,</span><br><span class="line">        .write = virtio_pci_device_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps notify_ops = &#123;</span><br><span class="line">        .read = virtio_pci_notify_read,</span><br><span class="line">        .write = virtio_pci_notify_write,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MemoryRegionOps notify_pio_ops = &#123;</span><br><span class="line">        .read = virtio_pci_notify_read,</span><br><span class="line">        .write = virtio_pci_notify_write_pio,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">            .min_access_size = <span class="number">1</span>,</span><br><span class="line">            .max_access_size = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">    &#125;;</span><br><span class="line">    g_autoptr(GString) name = g_string_new(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-common-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;common.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;common_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;common.size);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-isr-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;isr.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;isr_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;isr.size);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-device-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;device.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;device_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;device.size);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-notify-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;notify.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;notify_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;notify.size);</span><br><span class="line"></span><br><span class="line">    g_string_printf(name, <span class="string">&quot;virtio-pci-notify-pio-%s&quot;</span>, vdev_name);</span><br><span class="line">    memory_region_init_io(&amp;proxy-&gt;notify_pio.mr, OBJECT(proxy),</span><br><span class="line">                          &amp;notify_pio_ops,</span><br><span class="line">                          proxy,</span><br><span class="line">                          name-&gt;str,</span><br><span class="line">                          proxy-&gt;notify_pio.size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_modern_mem_region_map</span><span class="params">(VirtIOPCIProxy *proxy,</span></span><br><span class="line"><span class="params">                                             VirtIOPCIRegion *region,</span></span><br><span class="line"><span class="params">                                             <span class="keyword">struct</span> virtio_pci_cap *cap)</span></span><br><span class="line">&#123;</span><br><span class="line">    virtio_pci_modern_region_map(proxy, region, cap,</span><br><span class="line">                                 &amp;proxy-&gt;modern_bar, proxy-&gt;modern_mem_bar_idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_modern_region_map</span><span class="params">(VirtIOPCIProxy *proxy,</span></span><br><span class="line"><span class="params">                                         VirtIOPCIRegion *region,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">struct</span> virtio_pci_cap *cap,</span></span><br><span class="line"><span class="params">                                         MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                                         <span class="type">uint8_t</span> bar)</span></span><br><span class="line">&#123;</span><br><span class="line">    memory_region_add_subregion(mr, region-&gt;offset, &amp;region-&gt;mr);</span><br><span class="line"></span><br><span class="line">    cap-&gt;cfg_type = region-&gt;type;</span><br><span class="line">    cap-&gt;bar = bar;</span><br><span class="line">    cap-&gt;offset = cpu_to_le32(region-&gt;offset);</span><br><span class="line">    cap-&gt;length = cpu_to_le32(region-&gt;size);</span><br><span class="line">    virtio_pci_add_mem_cap(proxy, cap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面可以明显看到, 如果是<strong>modern</strong>类型, 就会调用 virtio_pci_modern_regions_init 注册很多个MemoryRegion, 之后调用 virtio_pci_modern_mem_region_map 重新映射到 proxy-&gt;modern_bar 这个region里, 之后是如下的调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;modern_mem_bar_idx,</span><br><span class="line">                         PCI_BASE_ADDRESS_SPACE_MEMORY |</span><br><span class="line">                         PCI_BASE_ADDRESS_MEM_PREFETCH |</span><br><span class="line">                         PCI_BASE_ADDRESS_MEM_TYPE_64,</span><br><span class="line">                         &amp;proxy-&gt;modern_bar);</span><br></pre></td></tr></table></figure>

<p>把 modern_bar 注册为IO memory.</p>
<p>而如果是<strong>legacy</strong>类型, 只是注册了一个IO port. 如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pci_register_bar(&amp;proxy-&gt;pci_dev, proxy-&gt;legacy_io_bar_idx,</span><br><span class="line">                         PCI_BASE_ADDRESS_SPACE_IO, &amp;proxy-&gt;bar);</span><br></pre></td></tr></table></figure>

<p>通过访问这些IO, 就可以管理virtio设备.</p>
<h1 id="Virtio设备的注册"><a href="#Virtio设备的注册" class="headerlink" title="Virtio设备的注册"></a>Virtio设备的注册</h1><p>在qemu中, virtio设备需要挂载在virtio-pci上. 一般来说, virtio设备的特点在于它大部分的实现都在内核, 用户态只需要配置基础的信息即可. 但是qemu本身也实现了一些相关设备的用户态实现, 比如virtio-net, 当启用vhost的时候, 它用户态基本上不做什么操作, 当未启用vhost时, 它的实现就在用户态的virtio-net.c文件中. </p>
<p>virtio设备主要关注的是它的VirtQueue的注册.</p>
<p>以 virtio-net 未启用vhost的情况举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_device_realize</span><span class="params">(DeviceState *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-&gt;max_queue_pairs; i++) &#123;</span><br><span class="line">        virtio_net_add_queue(n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n-&gt;ctrl_vq = virtio_add_queue(vdev, <span class="number">64</span>, virtio_net_handle_ctrl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_net_add_queue</span><span class="params">(VirtIONet *n, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIODevice *vdev = VIRTIO_DEVICE(n);</span><br><span class="line"></span><br><span class="line">    n-&gt;vqs[index].rx_vq = virtio_add_queue(vdev, n-&gt;net_conf.rx_queue_size,</span><br><span class="line">                                           virtio_net_handle_rx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n-&gt;net_conf.tx &amp;&amp; !<span class="built_in">strcmp</span>(n-&gt;net_conf.tx, <span class="string">&quot;timer&quot;</span>)) &#123;</span><br><span class="line">        n-&gt;vqs[index].tx_vq =</span><br><span class="line">            virtio_add_queue(vdev, n-&gt;net_conf.tx_queue_size,</span><br><span class="line">                             virtio_net_handle_tx_timer);</span><br><span class="line">        n-&gt;vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,</span><br><span class="line">                                              virtio_net_tx_timer,</span><br><span class="line">                                              &amp;n-&gt;vqs[index]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n-&gt;vqs[index].tx_vq =</span><br><span class="line">            virtio_add_queue(vdev, n-&gt;net_conf.tx_queue_size,</span><br><span class="line">                             virtio_net_handle_tx_bh);</span><br><span class="line">        n-&gt;vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &amp;n-&gt;vqs[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n-&gt;vqs[index].tx_waiting = <span class="number">0</span>;</span><br><span class="line">    n-&gt;vqs[index].n = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VirtQueue *<span class="title function_">virtio_add_queue</span><span class="params">(VirtIODevice *vdev, <span class="type">int</span> queue_size,</span></span><br><span class="line"><span class="params">                            VirtIOHandleOutput handle_output)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; VIRTIO_QUEUE_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vdev-&gt;vq[i].vring.num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == VIRTIO_QUEUE_MAX || queue_size &gt; VIRTQUEUE_MAX_SIZE)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    vdev-&gt;vq[i].vring.num = queue_size;</span><br><span class="line">    vdev-&gt;vq[i].vring.num_default = queue_size;</span><br><span class="line">    vdev-&gt;vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN;</span><br><span class="line">    vdev-&gt;vq[i].handle_output = handle_output;</span><br><span class="line">    vdev-&gt;vq[i].handle_aio_output = <span class="literal">NULL</span>;</span><br><span class="line">    vdev-&gt;vq[i].used_elems = g_malloc0(<span class="keyword">sizeof</span>(VirtQueueElement) *</span><br><span class="line">                                       queue_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;vdev-&gt;vq[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注 virtio_add_queue 函数的调用即可. 它用来向virtio-pci注册每个queue对应的处理函数. 比如<code>n-&gt;ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);</code> 就是注册了size为64的VirtQueue, 对ctrl_vq的访问都会触发 virtio_net_handle_ctrl 函数调用.</p>
<h1 id="virtio设备的访问"><a href="#virtio设备的访问" class="headerlink" title="virtio设备的访问"></a>virtio设备的访问</h1><p>以virtio-net设备为例, 假设注册的是legacy类型, 那么通过访问它的port, 就可以调用到virtio-pci的 virtio_pci_config_write-&gt;virtio_ioport_write 函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_ioport_write</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIOPCIProxy *proxy = opaque;</span><br><span class="line">    VirtIODevice *vdev = virtio_bus_get_device(&amp;proxy-&gt;bus);</span><br><span class="line">    hwaddr pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_GUEST_FEATURES:</span><br><span class="line">        <span class="comment">/* Guest does not negotiate properly?  We have to assume nothing. */</span></span><br><span class="line">        <span class="keyword">if</span> (val &amp; (<span class="number">1</span> &lt;&lt; VIRTIO_F_BAD_FEATURE)) &#123;</span><br><span class="line">            val = virtio_bus_get_vdev_bad_features(&amp;proxy-&gt;bus);</span><br><span class="line">        &#125;</span><br><span class="line">        virtio_set_features(vdev, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_QUEUE_SEL:</span><br><span class="line">        <span class="keyword">if</span> (val &lt; VIRTIO_QUEUE_MAX)</span><br><span class="line">            vdev-&gt;queue_sel = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_QUEUE_NOTIFY:</span><br><span class="line">        <span class="keyword">if</span> (val &lt; VIRTIO_QUEUE_MAX) &#123;</span><br><span class="line">            virtio_queue_notify(vdev, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设case是 VIRTIO_PCI_QUEUE_NOTIFY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">virtio_queue_notify</span><span class="params">(VirtIODevice *vdev, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtQueue *vq = &amp;vdev-&gt;vq[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!vq-&gt;vring.desc || vdev-&gt;broken)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_virtio_queue_notify(vdev, vq - vdev-&gt;vq, vq);</span><br><span class="line">    <span class="keyword">if</span> (vq-&gt;host_notifier_enabled) &#123;</span><br><span class="line">        event_notifier_set(&amp;vq-&gt;host_notifier);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vq-&gt;handle_output) &#123;</span><br><span class="line">        vq-&gt;handle_output(vdev, vq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(vdev-&gt;start_on_kick)) &#123;</span><br><span class="line">            virtio_set_started(vdev, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到, 它实际是通过vdev-&gt;vq来获取相关的VirtQueue的, 而上面virtio-net初始化的时候, max_queue_pairs是1, 所以它最终只初始化了3个queue. 按照初始化时调用virtio_add_queue的顺序, vq[0]就是rx_vq, vq[1]是tx_vq, vq[2]是ctrl_vq.  所以如果n是0, 最后调用的<code>vq-&gt;handle_output</code> 就会是 virtio_net_handle_rx 函数.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2022/06/17/qemu-build/" class="prev">上一篇</a><a href="/2022/06/17/dns-overflow-and-memLeak/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Fri Jun 17 2022 19:38:05 GMT+0800',
    owner: '474172261',
    repo: 'blog-comment',
    oauth: {
        client_id: '28b1a73c3ed656a9a85d',
        client_secret: '7ce17c048ed2d7c61117b439fe94026bd380e126',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2015 - 2022 <a href="http://474172261.github.io">VictorV</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>