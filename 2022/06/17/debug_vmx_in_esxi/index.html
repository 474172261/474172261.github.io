<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 在ESXi中调试运行虚拟机的vmx程序(How to debug vmx in ESXi) · VictorV的小博客</title><meta name="description" content="在ESXi中调试运行虚拟机的vmx程序(How to debug vmx in ESXi) - VictorV"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://474172261.github.io/atom.xml" title="VictorV的小博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="VictorV的小博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/474172261" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">在ESXi中调试运行虚拟机的vmx程序(How to debug vmx in ESXi)</h1><div class="post-info">2022年6月17日</div><div class="post-content"><p>ESXi自带一个子linux系统, 虽然能实现一部分功能, 但是目前为止, 依然没有公开的教程说过如何调试vmx进程, 本篇教程将分享我的研究成果, 帮助大家轻松调试虚拟机进程.</p>
<span id="more"></span>

<h2 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h2><p>首先, ESXi 自带一个gdbserver, 所以最简单的方法就是直接跑起程序, 再用gdbserver attach它. (最好用老一点的gdb, 比如gdb 7.8)</p>
<ol>
<li><p>跑起虚拟机, 查看vmx对应的进程id</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@192:~] ps|grep vmx</span><br><span class="line">70639  70639  vmx</span><br><span class="line">70643  70639  vmx-vthread-706</span><br><span class="line">70644  70639  vmx-filtPoll:c7</span><br><span class="line">70645  70639  vmx-mks:c7</span><br><span class="line">70646  70639  vmx-svga:c7</span><br><span class="line">70647  70639  vmx-vcpu-0:c7</span><br></pre></td></tr></table></figure>
</li>
<li><p>gdbserver attach 上去</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@192:~] gdbserver --attach :8808 70639</span><br><span class="line">Attached; pid = 70639</span><br><span class="line">!gdb_connected()</span><br><span class="line">!gdb_connected()</span><br><span class="line">!gdb_connected()</span><br><span class="line">!gdb_connected()</span><br><span class="line"></span><br><span class="line">[root@192:~] gdbserver --attach :8808 70639</span><br><span class="line">Attached; pid = 70639</span><br><span class="line">!gdb_connected()</span><br><span class="line">Listening on port 8808</span><br></pre></td></tr></table></figure>
<p>一定要保证出现<code>Listening on port</code>, 不然 ctrl+c 中断, 再重试就好, 目标进程不受影响.</p>
</li>
<li><p>找一台可以使用gdb的机器, 把ESXi中的vmx文件拷贝到机器中, 然后使用如下命令连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@192 vv]<span class="comment"># gdb -q</span></span><br><span class="line">gdb$ file Desktop/vmx-7.0-15843807.elf </span><br><span class="line">Reading symbols from /home/vv/Desktop/vmx-7.0-15843807.elf...Missing separate debuginfo <span class="keyword">for</span> /home/vv/Desktop/vmx-7.0-15843807.elf</span><br><span class="line">(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gdb$ target remote 192.168.170.240:8808</span><br><span class="line">Remote debugging using 192.168.170.240:8808</span><br><span class="line">=&gt; 0x8ce2771248 &lt;__libc_ifunc_impl_list+3304&gt;:	cmp    rax,0xfffffffffffff000</span><br><span class="line">   0x8ce277124e &lt;__libc_ifunc_impl_list+3310&gt;:	ja     0x8ce2771275 &lt;__libc_ifunc_impl_list+3349&gt;</span><br><span class="line"></span><br><span class="line">gdb$ </span><br></pre></td></tr></table></figure>
<p>这样就可以正常调试了</p>
</li>
</ol>
<h2 id="另一种方法-使用自己编译好的gdb"><a href="#另一种方法-使用自己编译好的gdb" class="headerlink" title="另一种方法-使用自己编译好的gdb"></a>另一种方法-使用自己编译好的gdb</h2><p>如果自带的gdbserver 不太好用, 那也可以自己源码静态编译一个gdb版本拷贝过去, 然后直接用.</p>
<ol>
<li><p>自己源码编译一个gdb, 或者用我编译好的<a href="/otherfile/gdb7_8.xz">gdb7.8 no python</a> 拷贝到esxi上</p>
<blockquote>
<p>如果要自己编译支持带python的gdb, 先下载python源码. 使用<code>./configure --prefix=/home/vv/python; make; make install</code> 编译安装python到&#x2F;home&#x2F;vv&#x2F;python. </p>
<p>然后下载gdb源码, 安装lzma开发组件<code>yum xz-devel texinfo</code>, 使用<code>./configure --prefix=/home/vv/gdb --enable-static --with-python=/home/vv/Desktop/python --with-lzma;make</code> 编译, 成功后<code>make install</code> 安装. 其它操作参考gdb10.2里给出的脚本.</p>
</blockquote>
<p>如果想编译11.0之后的gdb, 需要做一下修改, 修改如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> target_xfer_status</span><br><span class="line"><span class="title function_">linux_nat_target::xfer_partial</span> <span class="params">(<span class="keyword">enum</span> target_object object,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">char</span> *annex, gdb_byte *readbuf,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> gdb_byte *writebuf,</span></span><br><span class="line"><span class="params">				ULONGEST offset, ULONGEST len, ULONGEST *xfered_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (object == TARGET_OBJECT_MEMORY)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">-      <span class="keyword">return</span> linux_proc_xfer_memory_partial (readbuf, writebuf,</span><br><span class="line">-					     offset, len, xfered_len);</span><br><span class="line">+       <span class="class"><span class="keyword">enum</span> <span class="title">target_xfer_status</span> <span class="title">ret</span> =</span> linux_proc_xfer_memory_partial (readbuf, writebuf,</span><br><span class="line">+					     offset, len, xfered_len);</span><br><span class="line">+      <span class="keyword">if</span>(ret == TARGET_XFER_OK)&#123;<span class="keyword">return</span> ret;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inf_ptrace_target::xfer_partial (object, annex, readbuf, writebuf,</span><br><span class="line">					  offset, len, xfered_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在11.0之后的版本读取目标进程内存时, 默认从&#x2F;proc&#x2F;pid&#x2F;mem读取,  而esxi上是没有这个文件的, 所以, 除非修改它的实现, 否则之后的版本不适合在esxi上用.</p>
<p>最好还是用7.8的版本, 否则容易有奇奇怪怪的问题</p>
</blockquote>
</li>
<li><p>运行起虚拟机</p>
</li>
<li><p>运行gdb, 一般会告诉你缺失libtinfo.so.5文件或者libncurses.so.5, 最简单的方法就是创建一个软链接, 把它自带的一个文件软链接成缺失的文件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192:~] <span class="built_in">ln</span> -s /lib64/libncurses.so.5 /lib64/libtinfo.so.5</span><br></pre></td></tr></table></figure>
<p>或者从centos 7 3.10内核的系统中拷贝一个过去放在lib64目录下.</p>
</li>
<li><p>使用gdb调试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb$ file /bin/vmx</span><br><span class="line">gdb$ <span class="built_in">set</span> architecture i386:x86-64:intel</span><br><span class="line">gdb$ attach xxxxx</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以下是编译的带python 2.7 的gdb7.8的分块包(因为github最大支持25M), 可以通过<code>cat gdb78_p.tar.xz.* &gt; gdb10.2.tar.xz</code> 合并他们</p>
<p><a href="/otherfile/gdb78_p.tar.xz.s0">gdb78_p.tar.xz.s0</a> </p>
<p><a href="/otherfile/gdb78_p.tar.xz.s1">gdb78_p.tar.xz.s1</a></p>
<p><a href="/otherfile/gdb78_p.tar.xz.s2">gdb78_p.tar.xz.s2</a>  </p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果发现ctrl+c不好使, 那么就把虚拟机的cpu个数设置为1. 如果还是不好使, 建议重新选个guest安装测试.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2022/06/17/linux-proc/" class="prev">上一篇</a><a href="/2022/06/17/build-blog/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://474172261.github.io">VictorV</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>