<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> linux 内核和用户态通信之 /proc文件系统 · VictorV的小博客</title><meta name="description" content="linux 内核和用户态通信之 /proc文件系统 - VictorV"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://474172261.github.io/atom.xml" title="VictorV的小博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="VictorV的小博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/vv474172261" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/474172261" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">linux 内核和用户态通信之 /proc文件系统</h1><div class="post-info">2022年6月17日</div><div class="post-content"><p>&#x2F;proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux® 内核空间和用户空间之间进行通信。在 &#x2F;proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的.</p>
<span id="more"></span>

<p>&#x2F;proc 文件系统包含了一些目录（用作组织信息的方式）和虚拟文件。虚拟文件可以向用户呈现内核中的一些信息，也可以用作一种从用户空间向内核发送信息的手段。</p>
<h2 id="创建一个-x2F-proc文件"><a href="#创建一个-x2F-proc文件" class="headerlink" title="创建一个&#x2F;proc文件"></a>创建一个&#x2F;proc文件</h2><p>在3.8内核之前,使用create_proc_entry创建一个文件,原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">create_proc_entry</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *name, <span class="type">mode_t</span> mode,</span></span><br><span class="line"><span class="params">                                             <span class="keyword">struct</span> proc_dir_entry *parent )</span>;<span class="comment">//创建一个虚拟文件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;     <span class="comment">// 节点名称</span></span><br><span class="line">  <span class="type">mode_t</span> mode;        <span class="comment">// 权限,与chmod的一样,可以使用八进制表示</span></span><br><span class="line">  <span class="type">uid_t</span> uid;        <span class="comment">// File&#x27;s user id</span></span><br><span class="line">  <span class="type">gid_t</span> gid;        <span class="comment">// File&#x27;s group id</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">proc_iops</span>;</span> <span class="comment">// 索引节点操作函数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span>  <span class="comment">// 文件操作函数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">parent</span>;</span>    <span class="comment">// 父目录,如果是NULL,就代表/proc目录</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">read_proc_t</span> *read_proc;     <span class="comment">// 输出给cat的函数</span></span><br><span class="line">  <span class="type">write_proc_t</span> *write_proc;   <span class="comment">// 读取用户输入的函数</span></span><br><span class="line">  <span class="type">void</span> *data;       <span class="comment">// 指向private 数据</span></span><br><span class="line">  <span class="type">atomic_t</span> count;       <span class="comment">// 使用计数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_proc_entry</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> proc_dir_entry *parent )</span>;<span class="comment">//不仅可以删除节点,还能删除proc_mkdir创建的目录</span></span><br><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> proc_dir_entry *parent)</span>;  <span class="comment">//创建一个虚拟目录</span></span><br></pre></td></tr></table></figure>
<p>parent 参数可以为 NULL（表示 &#x2F;proc 根目录），也可以是很多其他值</p>
<table>
<thead>
<tr>
<th>proc_dir_entry</th>
<th>在文件系统中的位置</th>
</tr>
</thead>
<tbody><tr>
<td>proc_root_fs</td>
<td>&#x2F;proc</td>
</tr>
<tr>
<td>proc_net</td>
<td>&#x2F;proc&#x2F;net</td>
</tr>
<tr>
<td>proc_bus</td>
<td>&#x2F;proc&#x2F;bus</td>
</tr>
<tr>
<td>proc_root_driver</td>
<td>&#x2F;proc&#x2F;driver</td>
</tr>
</tbody></table>
<p>如果我们想创建一个文件为test_modul的虚拟文件,就这样初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create_proc_entry( <span class="string">&quot;test_module&quot;</span>, <span class="number">0644</span>, <span class="literal">NULL</span> );</span><br><span class="line">或者</span><br><span class="line">pt_root = proc_mkdir(<span class="string">&quot;test_menu&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">pt_entry1 = create_proc_entry(USER_ENTRY1, <span class="number">0666</span>, pt_root);</span><br></pre></td></tr></table></figure>

<h2 id="x2F-proc文件交互函数"><a href="#x2F-proc文件交互函数" class="headerlink" title="&#x2F;proc文件交互函数"></a>&#x2F;proc文件交互函数</h2><p><strong>read_proc</strong> 供用户读取的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mod_read</span><span class="params">( <span class="type">char</span> *page,<span class="comment">//数据写入的位置,该page缓冲区在内核</span></span></span><br><span class="line"><span class="params">            <span class="type">char</span> **start,</span></span><br><span class="line"><span class="params">               <span class="type">off_t</span> off,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> count,<span class="comment">//定义写入的最大字节数</span></span></span><br><span class="line"><span class="params">                <span class="type">int</span> *eof, <span class="comment">//当数据写入完后,需要设置为1</span></span></span><br><span class="line"><span class="params">              <span class="type">void</span> *data <span class="comment">//private 数据</span></span></span><br><span class="line"><span class="params">              )</span>;</span><br></pre></td></tr></table></figure>
<p>当需要写入多页数据时(一般一页4Kb),需要用到 start,off.</p>
<p><strong>write_proc</strong> 读取用户的输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mod_write</span><span class="params">( <span class="keyword">struct</span> file *filp, <span class="comment">//指向一个打开的文件结构</span></span></span><br><span class="line"><span class="params">         <span class="type">const</span> <span class="type">char</span> __user *buff, <span class="comment">//用户输入的数据,buff在用户空间,内核要读取需要用到copy_from_user</span></span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> <span class="type">long</span> len, <span class="comment">//长度</span></span></span><br><span class="line"><span class="params">                      <span class="type">void</span> *data </span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>其它需要用到的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个符号链接 */</span></span><br><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_symlink</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                       <span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> <span class="type">char</span> *dest )</span>;</span><br><span class="line"><span class="comment">/* Create a proc_dir_entry with a read_proc_t in one call */</span></span><br><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">create_proc_read_entry</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                                  <span class="type">mode_t</span> mode,</span></span><br><span class="line"><span class="params">                                                  <span class="keyword">struct</span> proc_dir_entry *base,</span></span><br><span class="line"><span class="params">                                                  <span class="type">read_proc_t</span> *read_proc,</span></span><br><span class="line"><span class="params">                                                  <span class="type">void</span> *data )</span>;</span><br><span class="line"><span class="comment">/* 从内核空间复制数据到用户空间 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">( <span class="type">void</span> __user *to,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="type">void</span> *from,</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">long</span> n )</span>;</span><br><span class="line"><span class="comment">/* 从用户空间到内核 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">( <span class="type">void</span> *to,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span> __user *from,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">long</span> n )</span>;</span><br><span class="line"><span class="comment">/* 创建虚拟的连续内存块 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> size )</span>;</span><br><span class="line"><span class="comment">/* 释放vmalloc创建的块 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">( <span class="type">void</span> *addr )</span>;</span><br><span class="line"><span class="comment">/* Export a symbol to the kernel (make it visible to the kernel) */</span></span><br><span class="line">EXPORT_SYMBOL( symbol );</span><br><span class="line"><span class="comment">/* Export all symbols in a file to the kernel (declare before module.h) */</span></span><br><span class="line">EXPORT_SYMTAB</span><br></pre></td></tr></table></figure>

<h2 id="创建内核驱动"><a href="#创建内核驱动" class="headerlink" title="创建内核驱动"></a>创建内核驱动</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Defines the license for this LKM */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_module_init</span><span class="params">( <span class="type">void</span> )</span><span class="comment">//自定义的初始化函数</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;my_module_init called.  Module is now loaded.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_module_cleanup</span><span class="params">( <span class="type">void</span> )</span><span class="comment">//自定义的退出函数</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;my_module_cleanup called.  Module is now unloaded.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init( my_module_init );<span class="comment">//声明初始化函数</span></span><br><span class="line">module_exit( my_module_cleanup );<span class="comment">//声明退出函数</span></span><br></pre></td></tr></table></figure>

<p>从3.10内核开始,create_proc_entry() 函数被替换成proc_create() 函数, 函数区别如下:<br>修改前</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_file</span> =</span> create_proc_entry(<span class="string">&quot;file&quot;</span>,<span class="number">0600</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (proc_file) &#123;</span><br><span class="line">        proc_file-&gt;read_proc = file_read;  </span><br><span class="line">        proc_file-&gt;write_proc = file_write;</span><br><span class="line">        proc_file-&gt;owner = THIS_MODULE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_fops</span>=</span></span><br><span class="line">&#123;</span><br><span class="line">    .read=file_read,</span><br><span class="line">    .write=file_write,</span><br><span class="line">    .owner=THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">proc_file = proc_create(<span class="string">&quot;file&quot;</span>, <span class="number">0600</span>, proc_dir, &amp;proc_fops);</span><br></pre></td></tr></table></figure>

<h2 id="编译安装驱动"><a href="#编译安装驱动" class="headerlink" title="编译安装驱动"></a>编译安装驱动</h2><p>Makefile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += simple-km.o</span><br><span class="line"></span><br><span class="line">all:    </span><br><span class="line">		make -C /lib/modules/`uname -r`/build SUBDIRS=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:  </span><br><span class="line">		make -C /lib/modules/`uname -r`/build SUBDIRS=$(PWD) modules</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开头的是tab, 不是空格, 一定要注意</p>
</blockquote>
<p>执行如下命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ insmod simple-km.ko </span><br><span class="line">$ dmesg | <span class="built_in">tail</span> -5      查看最后5行信息</span><br><span class="line">$ lsmod</span><br><span class="line">$ rmmod simple-km.ko</span><br></pre></td></tr></table></figure>
<h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Fortune Cookie Kernel Module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;VictorV&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COOKIE_LENGTH       PAGE_SIZE</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_entry</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *cookie_pot;  <span class="comment">// 内存缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cookie_index;  <span class="comment">// 指向缓冲区的数据尾部</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> next_fortune;  <span class="comment">// 通过\0分开字符串,此处用来指向下一个需要输出的缓冲字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">fortune_write</span><span class="params">( <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">char</span> __user *buff,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> len, </span></span><br><span class="line"><span class="params">                <span class="type">void</span> *data )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> space_available = (MAX_COOKIE_LENGTH-cookie_index)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; space_available) &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;fortune: cookie pot is full!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user( &amp;cookie_pot[cookie_index], buff, len )) &#123;</span><br><span class="line">  <span class="comment">//从用户空间读取数据到cookie_pot,</span></span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  &#125;</span><br><span class="line">  cookie_index += len;</span><br><span class="line">  cookie_pot[cookie_index<span class="number">-1</span>] = <span class="number">0</span>;<span class="comment">//将最后一位置零</span></span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fortune_read</span><span class="params">( <span class="type">char</span> *page, <span class="type">char</span> **start, <span class="type">off_t</span> off,<span class="type">int</span> count, <span class="type">int</span> *eof, <span class="type">void</span> *data )</span>&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="keyword">if</span> (off &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    *eof = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (next_fortune &gt;= cookie_index) next_fortune = <span class="number">0</span>;<span class="comment">//超过数据个数,就循环读取</span></span><br><span class="line">  len = <span class="built_in">sprintf</span>(page, <span class="string">&quot;%s\n&quot;</span>, &amp;cookie_pot[next_fortune]);<span class="comment">//将一段字符串写入page</span></span><br><span class="line">  next_fortune += len;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_fortune_module</span><span class="params">( <span class="type">void</span> )</span><span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  cookie_pot = (<span class="type">char</span> *)vmalloc( MAX_COOKIE_LENGTH );<span class="comment">//申请一段内核空间</span></span><br><span class="line">  <span class="keyword">if</span> (!cookie_pot) &#123;</span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>( cookie_pot, <span class="number">0</span>, MAX_COOKIE_LENGTH );</span><br><span class="line">    proc_entry = create_proc_entry( <span class="string">&quot;fortune&quot;</span>, <span class="number">0644</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">if</span> (proc_entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      vfree(cookie_pot);</span><br><span class="line">      printk(KERN_INFO <span class="string">&quot;fortune: Couldn&#x27;t create proc entry\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cookie_index = <span class="number">0</span>;</span><br><span class="line">      next_fortune = <span class="number">0</span>;</span><br><span class="line">      proc_entry-&gt;read_proc = fortune_read;<span class="comment">//这里定义输出函数</span></span><br><span class="line">      proc_entry-&gt;write_proc = fortune_write;<span class="comment">//定义输入函数</span></span><br><span class="line">      proc_entry-&gt;owner = THIS_MODULE;</span><br><span class="line">      printk(KERN_INFO <span class="string">&quot;fortune: Module loaded.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_fortune_module</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">  remove_proc_entry(<span class="string">&quot;fortune&quot;</span>, &amp;proc_root);</span><br><span class="line">  vfree(cookie_pot);</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;fortune: Module unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init( init_fortune_module );</span><br><span class="line">module_exit( cleanup_fortune_module );</span><br></pre></td></tr></table></figure>

<p>效果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@plato]<span class="comment"># insmod fortune.ko</span></span><br><span class="line">[root@plato]<span class="comment"># echo &quot;Success is an individual proposition.  </span></span><br><span class="line">          Thomas Watson<span class="string">&quot; &gt; /proc/fortune</span></span><br><span class="line"><span class="string">[root@plato]# echo &quot;</span>If a man does his best, what <span class="keyword">else</span> is there?  </span><br><span class="line">                Gen. Patton<span class="string">&quot; &gt; /proc/fortune</span></span><br><span class="line"><span class="string">[root@plato]# echo &quot;</span>Cats: All your base are belong to us.  </span><br><span class="line">                      Zero Wing<span class="string">&quot; &gt; /proc/fortune</span></span><br><span class="line"><span class="string">[root@plato]# cat /proc/fortune</span></span><br><span class="line"><span class="string">Success is an individual proposition.  Thomas Watson</span></span><br><span class="line"><span class="string">[root@plato]# cat /proc/fortune</span></span><br><span class="line"><span class="string">If a man does his best, what else is there?  General Patton</span></span><br><span class="line"><span class="string">[root@plato]#</span></span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2022/06/17/linux-debug-setting/" class="prev">PREV</a><a href="/2022/06/17/debug_vmx_in_esxi/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '28b1a73c3ed656a9a85d',     
    clientSecret: '59837bb4cbe7b2f12df366fdbcb37fa4ba084d44',     
    id: 'Fri Jun 17 2022 19:38:05 GMT+0800',    
    repo: 'blog-comment',     
    owner: '474172261',     
    admin: '474172261',     
})   
gitalk.render('gitalk-container')</script><div class="copyright"><p>© 2015 - 2023 <a href="http://474172261.github.io">VictorV</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>